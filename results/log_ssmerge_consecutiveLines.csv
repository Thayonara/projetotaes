revision;file;methodsignature;leftbody;basebody;rightbody
/home/paper219/Desktop/analysis/demonstration//projects/BottomBar/revisions/rev_9f16fe4_dbbaa12/rev_9f16fe4-dbbaa12;/bottom-bar/src/main/java/com/roughike/bottombar/BottomBar;onLongClick(View);        if ((mIsShiftingMode || mIsTabletMode) && v.getTag().equals(TAG_BOTTOM_BAR_VIEW_INACTIVE)) {
            Toast.makeText(mContext, mItems[findItemPosition(v)].getTitle(mContext), Toast.LENGTH_SHORT).show();;        if (mIsShiftingMode && v.getTag().equals(TAG_BOTTOM_BAR_VIEW_INACTIVE)) {
            Toast.makeText(mContext, mItems[findItemPosition(v)].getTitle(mContext), Toast.LENGTH_SHORT).show();;        if (mIsShiftingMode && v.getTag().equals(TAG_BOTTOM_BAR_VIEW_INACTIVE)) {
            Toast.makeText(getContext(), mItems[findItemPosition(v)].getTitle(getContext()), Toast.LENGTH_SHORT).show();
/home/paper219/Desktop/analysis/demonstration//projects/BottomBar/revisions/rev_9f16fe4_dbbaa12/rev_9f16fe4-dbbaa12;/bottom-bar/src/main/java/com/roughike/bottombar/BottomBar;updateItems(BottomBarItemBase[]);            icon.setImageDrawable(bottomBarItemBase.getIcon(mContext));;            icon.setImageDrawable(bottomBarItemBase.getIcon(mContext));
            title.setText(bottomBarItemBase.getTitle(mContext));;            icon.setImageDrawable(bottomBarItemBase.getIcon(getContext()));
            title.setText(bottomBarItemBase.getTitle(getContext()));
/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_0d5677b_09c2b0c/rev_0d5677b-09c2b0c;/modules/swagger-jaxrs/src/main/scala/com/wordnik/swagger/jaxrs/ApiHelpMessageBodyWriter;writeTo(Documentation,Class<?>,Type,Annotation[],MediaType,MultivaluedMap<String,Object>,OutputStream);        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(entityStream));
        bw.write(getStringRepresentation(documentation));
        bw.flush();;        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(entityStream));
        bw.write(getStringRepresentation(documentation).getBytes());
        bw.flush();;        entityStream.write(getStringRepresentation(documentation).getBytes());
        entityStream.flush();
/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_62f911d_a5ea4f1/rev_62f911d-a5ea4f1;/modules/swagger-jaxrs/src/main/java/com/wordnik/swagger/jaxrs/Reader;parseMethod(Method);        responseClass = apiResponse.response();

        if( StringUtils.isNotEmpty( apiResponse.reference() )){
          response.schema( new RefProperty( apiResponse.reference() ));
        }
        else if(responseClass != null && !responseClass.equals(java.lang.Void.class)) {
          Map<String, Model> models = ModelConverters.getInstance().read(responseClass);;        responseClass = apiResponse.response();
        if(responseClass != null && !responseClass.equals(java.lang.Void.class)) {
          Map<String, Model> models = ModelConverters.getInstance().read(responseClass);;        responseType = apiResponse.response();
        if(responseType != null && !isVoid(responseType)) {
          Map<String, Model> models = ModelConverters.getInstance().read(responseType);
/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_fbc78e9_3b06d82/rev_fbc78e9-3b06d82;/modules/swagger-jaxrs/src/main/java/io/swagger/jaxrs/Reader;parseMethod(Method);    return parseMethod(method, Collections.<Parameter> emptyList());;    Operation operation = new Operation();

    ApiOperation apiOperation = getAnnotation(method, ApiOperation.class);
    ApiResponses responseAnnotation = getAnnotation(method, ApiResponses.class);

    String operationId = method.getName();
    String responseContainer = null;

    Type responseType = null;
    Map<String,Property> defaultResponseHeaders = new HashMap<String, Property>();

    if(apiOperation != null) {
      if(apiOperation.hidden())
        return null;
      if(!"".equals(apiOperation.nickname()))
        operationId = method.getName();

      defaultResponseHeaders = parseResponseHeaders(apiOperation.responseHeaders());

      operation
        .summary(apiOperation.value())
        .description(apiOperation.notes());

      if(apiOperation.response() != null && !isVoid(apiOperation.response()))
        responseType = apiOperation.response();
      if(!"".equals(apiOperation.responseContainer()))
        responseContainer = apiOperation.responseContainer();
      if(apiOperation.authorizations()!= null) {
        List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();
        for(Authorization auth : apiOperation.authorizations()) {
          if(auth.value() != null && !"".equals(auth.value())) {
            SecurityRequirement security = new SecurityRequirement();
            security.setName(auth.value());
            AuthorizationScope[] scopes = auth.scopes();
            for(AuthorizationScope scope : scopes) {
              if(scope.scope() != null && !"".equals(scope.scope())) {
                security.addScope(scope.scope());
              }
            }
            securities.add(security);
          }
        }
        if(securities.size() > 0) {
          for(SecurityRequirement sec : securities)
            operation.security(sec);
        }
      }
      if (apiOperation.consumes() != null && !apiOperation.consumes().isEmpty()) {
        operation.consumes(apiOperation.consumes());
      }
      if (apiOperation.produces() != null && !apiOperation.produces().isEmpty()) {
        operation.produces(apiOperation.produces());
      }
    }

    if( apiOperation != null && StringUtils.isNotEmpty( apiOperation.responseReference() )){
      Response response = new Response().description(SUCCESSFUL_OPERATION);
      response.schema( new RefProperty( apiOperation.responseReference() ));
      operation.addResponse(String.valueOf(apiOperation.code()), response);
    }
    else if(responseType == null) {
      // pick out response from method declaration
      LOGGER.debug("picking up response class from method " + method);
      responseType = method.getGenericReturnType();
    }
    if(isValidResponse(responseType)) {
      int responseCode = 200;
      if (apiOperation != null) {
        responseCode = apiOperation.code();
      }
      if(isPrimitive(responseType)) {
        Property property = ModelConverters.getInstance().readAsProperty(responseType);
        if(property != null) {
          Property responseProperty = ContainerWrapper.wrapContainer(responseContainer, property);
          operation.response(responseCode, new Response()
            .description(SUCCESSFUL_OPERATION)
            .schema(responseProperty)
            .headers(defaultResponseHeaders));
        }
      } else {
        Map<String, Model> models = ModelConverters.getInstance().read(responseType);
        if(models.size() == 0) {
          Property p = ModelConverters.getInstance().readAsProperty(responseType);
          operation.response(responseCode, new Response()
            .description(SUCCESSFUL_OPERATION)
            .schema(p)
            .headers(defaultResponseHeaders));
        }
        for(String key: models.keySet()) {
          Model model = models.get( key );
          Property property = StringUtils.isNotEmpty( model.getReference() ) ?
                  new RefProperty( model.getReference() ) :
                  new RefProperty().asDefault(key);

          Property responseProperty = ContainerWrapper.wrapContainer(responseContainer, property);
          operation.response(responseCode, new Response()
            .description(SUCCESSFUL_OPERATION)
            .schema(responseProperty)
            .headers(defaultResponseHeaders));
          swagger.model(key, models.get(key));
        }
        models = ModelConverters.getInstance().readAll(responseType);
        for(String key: models.keySet()) {
          swagger.model(key, models.get(key));
        }
      }
    }

    operation.operationId(operationId);

    Annotation annotation;
    if (apiOperation != null && apiOperation.consumes() != null && apiOperation.consumes().isEmpty()) {
      annotation = getAnnotation(method, Consumes.class);
      if(annotation != null) {
        String[] apiConsumes = ((Consumes)annotation).value();
        for(String mediaType: apiConsumes)
          operation.consumes(mediaType);
      }
    }

    if (apiOperation != null && apiOperation.produces() != null && apiOperation.produces().isEmpty()) {
      annotation = getAnnotation(method, Produces.class);
      if(annotation != null) {
        String[] apiProduces = ((Produces)annotation).value();
        for(String mediaType: apiProduces)
          operation.produces(mediaType);
      }
    }

    List<ApiResponse> apiResponses = new ArrayList<ApiResponse>();
    if(responseAnnotation != null) {
      for(ApiResponse apiResponse: responseAnnotation.value()) {
        Map<String,Property> responseHeaders = parseResponseHeaders(apiResponse.responseHeaders());

        Response response = new Response()
          .description(apiResponse.message())
          .headers(responseHeaders);

        if(apiResponse.code() == 0)
          operation.defaultResponse(response);
        else
          operation.response(apiResponse.code(), response);

        responseType = apiResponse.response();

        if( StringUtils.isNotEmpty( apiResponse.reference() )){
          response.schema( new RefProperty( apiResponse.reference() ));
        }
        else if(responseType != null && !isVoid(responseType)) {
          Map<String, Model> models = ModelConverters.getInstance().read(responseType);
          for(String key: models.keySet()) {
            Model model = models.get( key );
            Property property = StringUtils.isNotEmpty( model.getReference() ) ?
                    new RefProperty( model.getReference() ) :
                    new RefProperty().asDefault(key);

            Property responseProperty = ContainerWrapper.wrapContainer(apiResponse.responseContainer(), property);
            response.schema(responseProperty);

            if( StringUtils.isEmpty(model.getReference())) {
              swagger.model(key, models.get(key));
            }
          }
          models = ModelConverters.getInstance().readAll(responseType);
          for(String key: models.keySet()) {
            Model model = models.get(key);
            if( StringUtils.isEmpty(model.getReference())) {
              swagger.model(key, model);
            }
          }
        }
      }
    }
    boolean isDeprecated = false;
    annotation = method.getAnnotation(Deprecated.class);
    if(annotation != null)
      isDeprecated = true;

    boolean hidden = false;
    if(apiOperation != null)
      hidden = apiOperation.hidden();

    // process parameters
    Type[] genericParameterTypes = method.getGenericParameterTypes();
    Annotation[][] paramAnnotations = method.getParameterAnnotations();
    for(int i = 0; i < genericParameterTypes.length; i++) {
      Type type = genericParameterTypes[i];
      List<Parameter> parameters = getParameters(type,Arrays.asList(paramAnnotations[i]));

      for(Parameter parameter : parameters) {
        operation.parameter(parameter);
      }
    }

    if(operation.getResponses() == null) {
      Response response = new Response().description(SUCCESSFUL_OPERATION);
      operation.defaultResponse(response);
    }
    return operation;;    Operation operation = new Operation();

    ApiOperation apiOperation = getAnnotation(method, ApiOperation.class);
    ApiResponses responseAnnotation = getAnnotation(method, ApiResponses.class);

    String operationId = method.getName();
    String responseContainer = null;

    Type responseType = null;
    Map<String,Property> defaultResponseHeaders = new HashMap<String, Property>();

    if(apiOperation != null) {
      if(apiOperation.hidden())
        return null;
      if(!"".equals(apiOperation.nickname()))
        operationId = method.getName();

      defaultResponseHeaders = parseResponseHeaders(apiOperation.responseHeaders());

      operation
        .summary(apiOperation.value())
        .description(apiOperation.notes());

      if(apiOperation.response() != null && !isVoid(apiOperation.response()))
        responseType = apiOperation.response();
      if(!"".equals(apiOperation.responseContainer()))
        responseContainer = apiOperation.responseContainer();
      if(apiOperation.authorizations()!= null) {
        List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();
        for(Authorization auth : apiOperation.authorizations()) {
          if(auth.value() != null && !"".equals(auth.value())) {
            SecurityRequirement security = new SecurityRequirement();
            security.setName(auth.value());
            AuthorizationScope[] scopes = auth.scopes();
            for(AuthorizationScope scope : scopes) {
              if(scope.scope() != null && !"".equals(scope.scope())) {
                security.addScope(scope.scope());
              }
            }
            securities.add(security);
          }
        }
        if(securities.size() > 0) {
          for(SecurityRequirement sec : securities)
            operation.security(sec);
        }
      }
      if (apiOperation.consumes() != null && !apiOperation.consumes().isEmpty()) {
        operation.consumes(apiOperation.consumes());
      }
      if (apiOperation.produces() != null && !apiOperation.produces().isEmpty()) {
        operation.produces(apiOperation.produces());
      }
    }

    if( apiOperation != null && StringUtils.isNotEmpty( apiOperation.responseReference() )){
      Response response = new Response().description(SUCCESSFUL_OPERATION);
      response.schema( new RefProperty( apiOperation.responseReference() ));
      operation.addResponse(String.valueOf(apiOperation.code()), response);
    }
    else if(responseType == null) {
      // pick out response from method declaration
      LOGGER.debug("picking up response class from method " + method);
      responseType = method.getGenericReturnType();
    }
    if(isValidResponse(responseType)) {
      final Property property = ModelConverters.getInstance().readAsProperty(responseType);
      if (property != null) {
        final Property responseProperty = ContainerWrapper.wrapContainer(responseContainer, property);
        final int responseCode = apiOperation == null ? 200 : apiOperation.code();
        operation.response(responseCode, new Response().description(SUCCESSFUL_OPERATION).schema(responseProperty)
            .headers(defaultResponseHeaders));
        appendModels(responseType);
      }
    }

    operation.operationId(operationId);

    Annotation annotation;
    if (apiOperation != null && apiOperation.consumes() != null && apiOperation.consumes().isEmpty()) {
      annotation = getAnnotation(method, Consumes.class);
      if(annotation != null) {
        String[] apiConsumes = ((Consumes)annotation).value();
        for(String mediaType: apiConsumes)
          operation.consumes(mediaType);
      }
    }

    if (apiOperation != null && apiOperation.produces() != null && apiOperation.produces().isEmpty()) {
      annotation = getAnnotation(method, Produces.class);
      if(annotation != null) {
        String[] apiProduces = ((Produces)annotation).value();
        for(String mediaType: apiProduces)
          operation.produces(mediaType);
      }
    }

    List<ApiResponse> apiResponses = new ArrayList<ApiResponse>();
    if(responseAnnotation != null) {
      for(ApiResponse apiResponse: responseAnnotation.value()) {
        Map<String,Property> responseHeaders = parseResponseHeaders(apiResponse.responseHeaders());

        Response response = new Response()
          .description(apiResponse.message())
          .headers(responseHeaders);

        if(apiResponse.code() == 0)
          operation.defaultResponse(response);
        else
          operation.response(apiResponse.code(), response);

        if( StringUtils.isNotEmpty( apiResponse.reference() )){
          response.schema( new RefProperty( apiResponse.reference() ));
        } else if (!isVoid(apiResponse.response())) {
          responseType = apiResponse.response();
          final Property property = ModelConverters.getInstance().readAsProperty(responseType);
          if (property != null) {
            response.schema(ContainerWrapper.wrapContainer(apiResponse.responseContainer(), property));
            appendModels(responseType);
          }
        }
      }
    }
    boolean isDeprecated = false;
    annotation = method.getAnnotation(Deprecated.class);
    if(annotation != null)
      isDeprecated = true;

    boolean hidden = false;
    if(apiOperation != null)
      hidden = apiOperation.hidden();

    // process parameters
    Type[] genericParameterTypes = method.getGenericParameterTypes();
    Annotation[][] paramAnnotations = method.getParameterAnnotations();
    for(int i = 0; i < genericParameterTypes.length; i++) {
      Type type = genericParameterTypes[i];
      List<Parameter> parameters = getParameters(type,Arrays.asList(paramAnnotations[i]));

      for(Parameter parameter : parameters) {
        operation.parameter(parameter);
      }
    }

    if(operation.getResponses() == null) {
      Response response = new Response().description(SUCCESSFUL_OPERATION);
      operation.defaultResponse(response);
    }
    return operation;
/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_500c792_efd7ef6/rev_500c792-efd7ef6;/modules/swagger-jaxrs/src/main/java/io/swagger/jaxrs/Reader;read(Class<?>,String,String,boolean,String[],String[],Map<String,Tag>,List<Parameter>);        Api api = (Api) cls.getAnnotation(Api.class);
        Map<String, SecurityScope> globalScopes = new HashMap<String, SecurityScope>();

        Map<String, Tag> tags = new HashMap<String, Tag>();
        List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();

        String[] consumes = new String[0];
        String[] produces = new String[0];
        final Set<Scheme> globalSchemes = EnumSet.noneOf(Scheme.class);

        // only read if allowing hidden apis OR api is not marked as hidden
        final boolean readable = (api != null && readHidden) || (api != null && !api.hidden());
        if (readable) {
            // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
            Set<String> tagStrings = extractTags(api);
            for (String tagString : tagStrings) {
                Tag tag = new Tag().name(tagString);
                tags.put(tagString, tag);
            }
            if (parentTags != null) {
                tags.putAll(parentTags);
            }
            for (String tagName : tags.keySet()) {
                swagger.tag(tags.get(tagName));
            }

            if (!api.produces().isEmpty()) {
                produces = new String[]{api.produces()};
            } else if (cls.getAnnotation(Produces.class) != null) {
                produces = ((Produces) cls.getAnnotation(Produces.class)).value();
            }
            if (!api.consumes().isEmpty()) {
                consumes = new String[]{api.consumes()};
            } else if (cls.getAnnotation(Consumes.class) != null) {
                consumes = ((Consumes) cls.getAnnotation(Consumes.class)).value();
            }
            globalSchemes.addAll(parseSchemes(api.protocols()));
            Authorization[] authorizations = api.authorizations();

            for (Authorization auth : authorizations) {
                if (auth.value() != null && !"".equals(auth.value())) {
                    SecurityRequirement security = new SecurityRequirement();
                    security.setName(auth.value());
                    AuthorizationScope[] scopes = auth.scopes();
                    for (AuthorizationScope scope : scopes) {
                        if (scope.scope() != null && !"".equals(scope.scope())) {
                            security.addScope(scope.scope());
                        }
                    }
                    securities.add(security);
                }
            }
        }

        // allow reading the JAX-RS APIs without @Api annotation
        if (readable || (api == null && config.isScanAllResources())) {
            // merge consumes, produces

            // look for method-level annotated properties

            // handle sub-resources by looking at return type

            final List<Parameter> globalParameters = new ArrayList<Parameter>();

            // look for constructor-level annotated properties
            globalParameters.addAll(ReaderUtils.collectConstructorParameters(cls, swagger));

            // look for field-level annotated properties
            globalParameters.addAll(ReaderUtils.collectFieldParameters(cls, swagger));

            // parse the method
            final javax.ws.rs.Path apiPath = cls.getAnnotation(javax.ws.rs.Path.class);
            Method methods[] = cls.getMethods();
            for (Method method : methods) {
                if (ReflectionUtils.isOverriddenMethod(method, cls)) {
                    continue;
                }
                javax.ws.rs.Path methodPath = ReflectionUtils.getAnnotation(method, javax.ws.rs.Path.class);

                String operationPath = getPath(apiPath, methodPath, parentPath);
                Map<String, String> regexMap = new HashMap<String, String>();
                operationPath = PathUtils.parsePath(operationPath, regexMap);
                if (operationPath != null) {
                    if (isIgnored(operationPath)) {
                        continue;
                    }

                    final ApiOperation apiOperation = ReflectionUtils.getAnnotation(method, ApiOperation.class);
                    String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

                    Operation operation = null;
                    if(apiOperation != null || config.isScanAllResources() || httpMethod != null || methodPath != null) { 
                        operation = parseMethod(cls, method, globalParameters);
                    }
                    if (operation == null) {
                        continue;
                    }
                    if (parentParameters != null) {
                        for (Parameter param : parentParameters) {
                            operation.parameter(param);
                        }
                    }
                    for (Parameter param : operation.getParameters()) {
                        if (regexMap.get(param.getName()) != null) {
                            String pattern = regexMap.get(param.getName());
                            param.setPattern(pattern);
                        }
                    }

                    if (apiOperation != null) {
                        for (Scheme scheme : parseSchemes(apiOperation.protocols())) {
                            operation.scheme(scheme);
                        }
                    }

                    if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {
                        for (Scheme scheme : globalSchemes) {
                            operation.scheme(scheme);
                        }
                    }

                    String[] apiConsumes = consumes;
                    if (parentConsumes != null) {
                        Set<String> both = new HashSet<String>(Arrays.asList(apiConsumes));
                        both.addAll(new HashSet<String>(Arrays.asList(parentConsumes)));
                        if (operation.getConsumes() != null) {
                            both.addAll(new HashSet<String>(operation.getConsumes()));
                        }
                        apiConsumes = both.toArray(new String[both.size()]);
                    }

                    String[] apiProduces = produces;
                    if (parentProduces != null) {
                        Set<String> both = new HashSet<String>(Arrays.asList(apiProduces));
                        both.addAll(new HashSet<String>(Arrays.asList(parentProduces)));
                        if (operation.getProduces() != null) {
                            both.addAll(new HashSet<String>(operation.getProduces()));
                        }
                        apiProduces = both.toArray(new String[both.size()]);
                    }
                    final Class<?> subResource = getSubResource(method);
                    if (subResource != null) {
                        read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters());
                    }

                    // can't continue without a valid http method
                    httpMethod = httpMethod == null ? parentMethod : httpMethod;
                    if (httpMethod != null) {
                        if (apiOperation != null) {
                            boolean hasExplicitTag = false;
                            for (String tag : apiOperation.tags()) {
                                if (!"".equals(tag)) {
                                    operation.tag(tag);
                                    swagger.tag(new Tag().name(tag));
                                }
                            }

                            if (operation != null) {
                                addExtensionProperties(apiOperation.extensions(), operation.getVendorExtensions());
                            }
                        }
                        if (operation != null) {
                            if (operation.getConsumes() == null) {
                                for (String mediaType : apiConsumes) {
                                    operation.consumes(mediaType);
                                }
                            }
                            if (operation.getProduces() == null) {
                                for (String mediaType : apiProduces) {
                                    operation.produces(mediaType);
                                }
                            }

                            if (operation.getTags() == null) {
                                for (String tagString : tags.keySet()) {
                                    operation.tag(tagString);
                                }
                            }
                            // Only add global @Api securities if operation doesn't already have more specific securities
                            if (operation.getSecurity() == null) {
                                for (SecurityRequirement security : securities) {
                                    operation.security(security);
                                }
                            }

                            Path path = swagger.getPath(operationPath);
                            if (path == null) {
                                path = new Path();
                                swagger.path(operationPath, path);
                            }
                            path.set(httpMethod, operation);

                            readImplicitParameters(method, operation);
                        }
                    }
                }
            }
        }

        return swagger;;        Api api = (Api) cls.getAnnotation(Api.class);
        Map<String, SecurityScope> globalScopes = new HashMap<String, SecurityScope>();

        Map<String, Tag> tags = new HashMap<String, Tag>();
        List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();

        String[] consumes = new String[0];
        String[] produces = new String[0];
        final Set<Scheme> globalSchemes = EnumSet.noneOf(Scheme.class);

        // only read if allowing hidden apis OR api is not marked as hidden
        final boolean readable = (api != null && readHidden) || (api != null && !api.hidden());
        if (readable) {
            // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
            Set<String> tagStrings = extractTags(api);
            for (String tagString : tagStrings) {
                Tag tag = new Tag().name(tagString);
                tags.put(tagString, tag);
            }
            if (parentTags != null) {
                tags.putAll(parentTags);
            }
            for (String tagName : tags.keySet()) {
                swagger.tag(tags.get(tagName));
            }

            if (!api.produces().isEmpty()) {
                produces = new String[]{api.produces()};
            } else if (cls.getAnnotation(Produces.class) != null) {
                produces = ((Produces) cls.getAnnotation(Produces.class)).value();
            }
            if (!api.consumes().isEmpty()) {
                consumes = new String[]{api.consumes()};
            } else if (cls.getAnnotation(Consumes.class) != null) {
                consumes = ((Consumes) cls.getAnnotation(Consumes.class)).value();
            }
            globalSchemes.addAll(parseSchemes(api.protocols()));
            Authorization[] authorizations = api.authorizations();

            for (Authorization auth : authorizations) {
                if (auth.value() != null && !"".equals(auth.value())) {
                    SecurityRequirement security = new SecurityRequirement();
                    security.setName(auth.value());
                    AuthorizationScope[] scopes = auth.scopes();
                    for (AuthorizationScope scope : scopes) {
                        if (scope.scope() != null && !"".equals(scope.scope())) {
                            security.addScope(scope.scope());
                        }
                    }
                    securities.add(security);
                }
            }
        }

        // allow reading the JAX-RS APIs without @Api annotation
        if (readable || (api == null && config.isScanAllResources())) {
            // merge consumes, produces

            // look for method-level annotated properties

            // handle sub-resources by looking at return type

            final List<Parameter> globalParameters = new ArrayList<Parameter>();

            // look for constructor-level annotated properties
            globalParameters.addAll(ReaderUtils.collectConstructorParameters(cls, swagger));

            // look for field-level annotated properties
            globalParameters.addAll(ReaderUtils.collectFieldParameters(cls, swagger));

            // parse the method
            final javax.ws.rs.Path apiPath = cls.getAnnotation(javax.ws.rs.Path.class);
            Method methods[] = cls.getMethods();
            for (Method method : methods) {
                if (ReflectionUtils.isOverriddenMethod(method, cls)) {
                    continue;
                }
                javax.ws.rs.Path methodPath = getAnnotation(method, javax.ws.rs.Path.class);

                String operationPath = getPath(apiPath, methodPath, parentPath);
                Map<String, String> regexMap = new HashMap<String, String>();
                operationPath = PathUtils.parsePath(operationPath, regexMap);
                if (operationPath != null) {
                    if (isIgnored(operationPath)) {
                        continue;
                    }

                    final ApiOperation apiOperation = getAnnotation(method, ApiOperation.class);
                    String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

                    Operation operation = null;
                    if(apiOperation != null || config.isScanAllResources() || httpMethod != null || methodPath != null) { 
                        operation = parseMethod(cls, method, globalParameters);
                    }
                    if (operation == null) {
                        continue;
                    }
                    if (parentParameters != null) {
                        for (Parameter param : parentParameters) {
                            operation.parameter(param);
                        }
                    }
                    for (Parameter param : operation.getParameters()) {
                        if (regexMap.get(param.getName()) != null) {
                            String pattern = regexMap.get(param.getName());
                            param.setPattern(pattern);
                        }
                    }

                    if (apiOperation != null) {
                        for (Scheme scheme : parseSchemes(apiOperation.protocols())) {
                            operation.scheme(scheme);
                        }
                    }

                    if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {
                        for (Scheme scheme : globalSchemes) {
                            operation.scheme(scheme);
                        }
                    }

                    String[] apiConsumes = consumes;
                    if (parentConsumes != null) {
                        Set<String> both = new HashSet<String>(Arrays.asList(apiConsumes));
                        both.addAll(new HashSet<String>(Arrays.asList(parentConsumes)));
                        if (operation.getConsumes() != null) {
                            both.addAll(new HashSet<String>(operation.getConsumes()));
                        }
                        apiConsumes = both.toArray(new String[both.size()]);
                    }

                    String[] apiProduces = produces;
                    if (parentProduces != null) {
                        Set<String> both = new HashSet<String>(Arrays.asList(apiProduces));
                        both.addAll(new HashSet<String>(Arrays.asList(parentProduces)));
                        if (operation.getProduces() != null) {
                            both.addAll(new HashSet<String>(operation.getProduces()));
                        }
                        apiProduces = both.toArray(new String[both.size()]);
                    }
                    final Class<?> subResource = getSubResource(method);
                    if (subResource != null) {
                        read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters());
                    }

                    // can't continue without a valid http method
                    httpMethod = httpMethod == null ? parentMethod : httpMethod;
                    if (httpMethod != null) {
                        if (apiOperation != null) {
                            boolean hasExplicitTag = false;
                            for (String tag : apiOperation.tags()) {
                                if (!"".equals(tag)) {
                                    operation.tag(tag);
                                    swagger.tag(new Tag().name(tag));
                                }
                            }

                            if (operation != null) {
                                addExtensionProperties(apiOperation.extensions(), operation.getVendorExtensions());
                            }
                        }
                        if (operation != null) {
                            if (operation.getConsumes() == null) {
                                for (String mediaType : apiConsumes) {
                                    operation.consumes(mediaType);
                                }
                            }
                            if (operation.getProduces() == null) {
                                for (String mediaType : apiProduces) {
                                    operation.produces(mediaType);
                                }
                            }

                            if (operation.getTags() == null) {
                                for (String tagString : tags.keySet()) {
                                    operation.tag(tagString);
                                }
                            }
                            // Only add global @Api securities if operation doesn't already have more specific securities
                            if (operation.getSecurity() == null) {
                                for (SecurityRequirement security : securities) {
                                    operation.security(security);
                                }
                            }

                            Path path = swagger.getPath(operationPath);
                            if (path == null) {
                                path = new Path();
                                swagger.path(operationPath, path);
                            }
                            path.set(httpMethod, operation);

                            readImplicitParameters(method, operation);
                        }
                    }
                }
            }
        }

        return swagger;;        return read(cls, parentPath, parentMethod, readHidden, parentConsumes, parentProduces, parentTags, parentParameters, new HashSet<Class<?>>());
/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_0011790_17587ab/rev_0011790-17587ab;/modules/swagger-jaxrs/src/main/java/io/swagger/jaxrs/config/WebXMLReader;WebXMLReader(ServletConfig);        basePath = servletConfig.getInitParameter("swagger.api.basepath");
        title = servletConfig.getInitParameter("swagger.api.title");;        String shouldPrettyPrint = servletConfig.getInitParameter("swagger.pretty.print");
        if (shouldPrettyPrint != null) {
            scanner.setPrettyPrint(Boolean.parseBoolean(shouldPrettyPrint));
        }
        basePath = servletConfig.getInitParameter("swagger.api.basepath");
        title = servletConfig.getInitParameter("swagger.api.title");;        String shouldPrettyPrint = servletConfig.getInitParameter("swagger.pretty.print");
        if (shouldPrettyPrint != null) {
            scanner.setPrettyPrint(Boolean.parseBoolean(shouldPrettyPrint));
        }

        // we support full base path (i.e full URL to the server) or just base path
        this.host = servletConfig.getInitParameter("swagger.api.host");
        String schemesString = servletConfig.getInitParameter("swagger.api.schemes");

        // split the CSV string and update the `schemes` variable
        if(schemesString != null) {
            String[] parts = schemesString.split(",");
            List<String> schemes = new ArrayList<String>();
            for(String scheme : parts) {
                String s = scheme.trim();
                if(!s.isEmpty()) {
                    schemes.add(s);
                }
            }
            this.schemes = schemes.toArray(new String[schemes.size()]);
        }
        this.title = servletConfig.getInitParameter("swagger.api.title");
/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_0ed8dce_ca27b61/rev_0ed8dce-ca27b61;/modules/swagger-core/src/main/java/io/swagger/util/ParameterProcessor;applyAnnotations(Swagger,Parameter,Type,List<Annotation>);                } else {
                    p.setType(param.getDataType());
                }
            }
            if (helper.getMin() != null || helper.getDecimalMin() != null) {
                p.setMinimum(helper.getMin() != null ? new Double(helper.getMin()) : helper.getDecimalMin());
                if (helper.isMinExclusive()) {
                    p.setExclusiveMinimum(true);
                }
            }

            if (helper.getMax() != null || helper.getDecimalMax() != null) {
                p.setMaximum(helper.getMax() != null ? new Double(helper.getMax()) : helper.getDecimalMax());
                if (helper.isMaxExclusive()) {
                    p.setExclusiveMaximum(true);;                }
                else {
                    p.setType(param.getDataType());;                } else if("long".equalsIgnoreCase(param.getDataType())) {
                    p.setProperty(new LongProperty());
                } else {
                    p.setType(param.getDataType());
/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_29d996b_e990bcd/rev_29d996b-e990bcd;/src/com/google/bitcoin/core/Peer;startBlockChainDownload();public void startBlockChainDownload() throws IOException {
        for (PeerEventListener listener : eventListeners) {
            synchronized (listener) {
                listener.onChainDownloadStarted(this, getPeerBlocksToGet());
            };public CountDownLatch startBlockChainDownload() throws IOException {
        // Chain will overflow signed int blocks in ~41,000 years.
        int chainHeight = (int) conn.getVersionMessage().bestHeight;
        if (chainHeight <= 0) {
            // This should not happen because we shouldn't have given the user a Peer that is to another client-mode
            // node. If that happens it means the user overrode us somewhere.
            throw new  RuntimeException("Peer does not have block chain");;public CountDownLatch startBlockChainDownload() throws IOException {
        // Chain will overflow signed int blocks in ~41,000 years.
        int chainHeight = (int) conn.getVersionMessage().bestHeight;
        if (chainHeight <= 0) {
            // This should not happen because we shouldn't have given the user a Peer that is to another client-mode
            // node. If that happens it means the user overrode us somewhere.
            throw new RuntimeException("Peer does not have block chain");
/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_29d996b_e990bcd/rev_29d996b-e990bcd;/src/com/google/bitcoin/core/Peer;startBlockChainDownload();
        if (getPeerBlocksToGet() > 0) {;        int blocksToGet = chainHeight - blockChain.getChainHead().getHeight();
        chainCompletionLatch = new CountDownLatch(blocksToGet);
        if (blocksToGet > 0) {;        int blocksToGet = chainHeight - blockChain.getChainHead().getHeight();
        if (blocksToGet < 0) {
            // This peer has fewer blocks than we do. It isn't usable.
            // TODO: We can't do the right thing here until Mirons patch lands. For now just return a zero latch.
            return new CountDownLatch(0);
        }
        chainCompletionLatch = new CountDownLatch(blocksToGet);
        if (blocksToGet > 0) {
/home/paper219/Desktop/analysis/demonstration//projects/graphql-java/revisions/rev_9d94784_8f1681d/rev_9d94784-8f1681d;/src/main/java/graphql/GraphQL;execute(String,String,Object,Map<String,Object>);
        ExecutionId executionId = idProvider.generate(requestString, operationName, context);

        Execution execution = new Execution(executionStrategy);
        return execution.execute(executionId, graphQLSchema, context, document, operationName, arguments);;        Execution execution = new Execution(executionStrategy);
        return execution.execute(graphQLSchema, context, document, operationName, arguments);;        Execution execution = new Execution(queryStrategy, mutationStrategy);
        return execution.execute(graphQLSchema, context, document, operationName, arguments);
/home/paper219/Desktop/analysis/demonstration//projects/graphql-java/revisions/rev_d4097e9_a339c65/rev_d4097e9-a339c65;/src/main/java/graphql/GraphQL;GraphQL(GraphQLSchema);        //noinspection deprecation
        this(graphQLSchema, null);;        this(graphQLSchema, null);;        this(graphQLSchema, null, null);
/home/paper219/Desktop/analysis/demonstration//projects/graphql-java/revisions/rev_56eb2a7_b20ae0a/rev_56eb2a7-b20ae0a;/src/main/java/graphql/GraphQL;GraphQL(GraphQLSchema,ExecutionStrategy);public GraphQL(GraphQLSchema graphQLSchema, ExecutionStrategy executionStrategy) {
        this(graphQLSchema, executionStrategy, NoOpInstrumentation.INSTANCE);;public GraphQL(GraphQLSchema graphQLSchema, ExecutionStrategy executionStrategy) {
        this.graphQLSchema = graphQLSchema;
        this.executionStrategy = executionStrategy;;public GraphQL(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy) {
        this(graphQLSchema, queryStrategy, null);
/home/paper219/Desktop/analysis/demonstration//projects/graphql-java/revisions/rev_50fd10b_f493a19/rev_50fd10b-f493a19;/src/main/java/graphql/GraphQL;GraphQL(GraphQLSchema,ExecutionStrategy,ExecutionStrategy);public GraphQL(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy) {
        this(graphQLSchema,queryStrategy,mutationStrategy,NoOpInstrumentation.INSTANCE);;public GraphQL(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy) {
        this.graphQLSchema = graphQLSchema;
        this.queryStrategy = queryStrategy;
        this.mutationStrategy = mutationStrategy;;@SuppressWarnings("DeprecatedIsStillUsed")
    public GraphQL(GraphQLSchema graphQLSchema, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy) {
        this.graphQLSchema = graphQLSchema;
        this.queryStrategy = queryStrategy;
        this.mutationStrategy = mutationStrategy;
/home/paper219/Desktop/analysis/demonstration//projects/graphql-java/revisions/rev_a48f27d_5e9f899/rev_a48f27d-5e9f899;/src/main/java/graphql/GraphQL;build();            //noinspection deprecation
            return new GraphQL(graphQLSchema, queryExecutionStrategy, mutationExecutionStrategy, instrumentation);;            //noinspection deprecation
            return new GraphQL(graphQLSchema, queryExecutionStrategy, mutationExecutionStrategy);;            return new GraphQL(graphQLSchema, queryExecutionStrategy, mutationExecutionStrategy, idProvider);
/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_0537297_34bb99e/rev_0537297-34bb99e;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform;CounterToRateMetricTransform(MetricObserver,long,TimeUnit);@edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "SE_BAD_FIELD_INNER_CLASS",
            justification = "ignore that LinkedHashMap is serializable");@edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "SE_BAD_FIELD_INNER_CLASS",
            justification = "We don't use serialization - ignore that LinkedHashMap is serializable");@edu.umd.cs.findbugs.annotations.SuppressWarnings(
        value = "SE_BAD_FIELD_INNER_CLASS",
        justification = "We don't use serialization - ignore that LinkedHashMap is serializable")
/home/paper219/Desktop/analysis/demonstration//projects/xodus/revisions/rev_0145206_7481a4c/rev_0145206-7481a4c;/openAPI/src/main/java/jetbrains/exodus/entitystore/PersistentEntityStoreConfig;PersistentEntityStoreConfig();        this(false);;        //noinspection unchecked
        super(new Pair[]{
                new Pair(REFACTORING_NULL_INDICES, false),
                new Pair(REFACTORING_BLOB_NULL_INDICES, false),
                new Pair(REFACTORING_HEAVY_LINKS, false),
                new Pair(REFACTORING_HEAVY_PROPS, false),
                new Pair(REFACTORING_DELETE_REDUNDANT_BLOBS, false),
                new Pair(MAX_IN_PLACE_BLOB_SIZE, 10000),
                new Pair(CACHING_DISABLED, false),
                new Pair(EXPLAIN_ON, false),
                new Pair(UNIQUE_INDICES_USE_BTREE, false),
                new Pair(DEBUG_LINK_DATA_GETTER, false),
                new Pair(ENTITY_ITERABLE_CACHE_SIZE, defaultEntityIterableCacheSize()),
                new Pair(ENTITY_ITERABLE_CACHE_THREAD_COUNT, Runtime.getRuntime().availableProcessors() > 3 ? 2 : 1),
                new Pair(ENTITY_ITERABLE_CACHE_CACHING_TIMEOUT, 10000L),
                new Pair(ENTITY_ITERABLE_CACHE_DEFERRED_DELAY, 2000),
                new Pair(ENTITY_ITERABLE_CACHE_MAX_KEY_SIZE, 1024),
                new Pair(ENTITY_ITERABLE_CACHE_MAX_SIZE_OF_DIRECT_VALUE, 512),
                new Pair(TRANSACTION_PROPS_CACHE_SIZE, 1024),
                new Pair(TRANSACTION_LINKS_CACHE_SIZE, 4096),
                new Pair(TRANSACTION_BLOB_STRINGS_CACHE_SIZE, 128)
        });;        //noinspection unchecked
        super(new Pair[]{
                new Pair(REFACTORING_NULL_INDICES, false),
                new Pair(REFACTORING_BLOB_NULL_INDICES, false),
                new Pair(REFACTORING_HEAVY_LINKS, false),
                new Pair(REFACTORING_HEAVY_PROPS, false),
                new Pair(REFACTORING_DELETE_REDUNDANT_BLOBS, false),
                new Pair(MAX_IN_PLACE_BLOB_SIZE, 10000),
                new Pair(CACHING_DISABLED, false),
                new Pair(REORDERING_DISABLED, false),
                new Pair(EXPLAIN_ON, false),
                new Pair(UNIQUE_INDICES_USE_BTREE, false),
                new Pair(DEBUG_LINK_DATA_GETTER, false),
                new Pair(ENTITY_ITERABLE_CACHE_SIZE, defaultEntityIterableCacheSize()),
                new Pair(ENTITY_ITERABLE_CACHE_THREAD_COUNT, Runtime.getRuntime().availableProcessors() > 3 ? 2 : 1),
                new Pair(ENTITY_ITERABLE_CACHE_CACHING_TIMEOUT, 10000L),
                new Pair(ENTITY_ITERABLE_CACHE_DEFERRED_DELAY, 2000),
                new Pair(ENTITY_ITERABLE_CACHE_MAX_KEY_SIZE, 1024),
                new Pair(ENTITY_ITERABLE_CACHE_MAX_SIZE_OF_DIRECT_VALUE, 512),
                new Pair(TRANSACTION_PROPS_CACHE_SIZE, 1024),
                new Pair(TRANSACTION_LINKS_CACHE_SIZE, 4096),
                new Pair(TRANSACTION_BLOB_STRINGS_CACHE_SIZE, 128)
        });
/home/paper219/Desktop/analysis/demonstration//projects/xodus/revisions/rev_bad3ed8_210f741/rev_bad3ed8-210f741;/entity-store/src/main/java/jetbrains/exodus/entitystore/EntityIterableCacheAdapter;cacheObject(EntityIterableHandle,CachedWrapperIterable);        if (isHandleTooLong(key)) {
            return;
        }
        cache.cacheObject(key, new CacheItem(it, config.getEntityIterableCacheMaxSizeOfDirectValue()));;        if (isHandleTooLong(key)) {
            return;
        }
        cache.cacheObject(key, new CacheItem(it, maxSizeOfDirectValue));;        cache.cacheObject(key, new CacheItem(it, maxSizeOfDirectValue));
/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_cade836_8895c6b/rev_cade836-8895c6b;/src/main/java/io/reactivex/netty/protocol/http/client/HttpRequest;withContent(T);        if (!contentSet.compareAndSet(false, true)) {
            throw new IllegalStateException("Content has already been set");
        }
        if (!headers.isContentLengthSet()) {
            headers.set(HttpHeaders.Names.TRANSFER_ENCODING, "chunked");
        }
        contentFactory = new SimpleContentSourceFactory<T>(new ContentSource.SingletonSource<T>(content));;        if (!headers.isContentLengthSet()) {
            headers.set(HttpHeaders.Names.TRANSFER_ENCODING, "chunked");
        }
        contentSource = new ContentSource.SingletonSource<T>(content);;        contentSource = new ContentSource.SingletonSource<T>(content);
/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_9a0e62f_5841056/rev_9a0e62f-5841056;/rx-netty/src/main/java/io/reactivex/netty/client/ClientChannelFactoryImpl;connect(Subscriber<?superObservableConnection<I,O>>,RxClient.ServerInfo,ClientConnectionFactory<I,O,?extendsObservableConnection<I,O>>);                                 final ClientConnectionFactory<I, O,? extends ObservableConnection<I, O>> connectionFactory) {
        final long startTimeMillis = Clock.newStartTimeMillis();
        eventsSubject.onEvent(ClientMetricsEvent.CONNECT_START);;                                 final ClientConnectionFactory<I, O,? extends ObservableConnection<I, O>> connectionFactory) {;                                 final ClientConnectionFactory<I, O, ? extends ObservableConnection<I, O>> connectionFactory) {
/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_9a0e62f_5841056/rev_9a0e62f-5841056;/rx-netty/src/main/java/io/reactivex/netty/client/AbstractClientBuilder;build();        C client = createClient();
        if (null != eventListenersFactory) {
            MetricEventsListener<? extends ClientMetricsEvent<?>> listener =
                    newMetricsListener(eventListenersFactory, client);
            client.subscribe(listener);
        }
        return client;;        return createClient();;        if(null != sslEngineFactory) {
            appendPipelineConfigurator(PipelineConfigurators.<O,I>sslConfigurator(sslEngineFactory));
        }
        return createClient();
/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_9a0e62f_5841056/rev_9a0e62f-5841056;/rx-netty/src/main/java/io/reactivex/netty/server/ConnectionLifecycleHandler;channelActive(ChannelHandlerContext);        connection = connectionFactory.newConnection(ctx);
        final long startTimeMillis = Clock.newStartTimeMillis();
        eventsSubject.onEvent(ServerMetricsEvent.NEW_CLIENT_CONNECTED);;        connection = connectionFactory.newConnection(ctx);;            super.channelActive(ctx); // Called before connection handler call to finish the pipeline before the connection
                                      // is handled.
/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_9a0e62f_5841056/rev_9a0e62f-5841056;/rx-netty/src/main/java/io/reactivex/netty/server/ConnectionLifecycleHandler;channelActive(ChannelHandlerContext);        super.channelActive(ctx); // Called before connection handler call to finish the pipeline before the connection
                                  // is handled.

        Observable<Void> handledObservable;
        try {
            eventsSubject.onEvent(ServerMetricsEvent.CONNECTION_HANDLING_START, Clock.onEndMillis(startTimeMillis));
            handledObservable = connectionHandler.handle(connection);
        } catch (Throwable throwable) {
            handledObservable = Observable.error(throwable);
        }

        if (null == handledObservable) {
            handledObservable = Observable.empty();;        super.channelActive(ctx); // Called before connection handler call to finish the pipeline before the connection
                                  // is handled.

        Observable<Void> handledObservable;
        try {
            handledObservable = connectionHandler.handle(connection);
        } catch (Throwable throwable) {
            handledObservable = Observable.error(throwable);
        }

        if (null == handledObservable) {
            handledObservable = Observable.empty();;            handleConnection();
        } else {
            super.channelActive(ctx);
/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_9a0e62f_5841056/rev_9a0e62f-5841056;/rx-netty/src/main/java/io/reactivex/netty/server/AbstractServerBuilder;build();        S server = createServer();
        if (null != eventListenersFactory) {
            MetricEventsListener<? extends ServerMetricsEvent<?>> listener = newMetricsListener(eventListenersFactory,
                                                                                             server);
            server.subscribe(listener);
        }
        return server;;        return createServer();;        if(null != sslEngineFactory) {
            appendPipelineConfigurator(PipelineConfigurators.<I, O>sslConfigurator(sslEngineFactory));
        }
        return createServer();
