revision;file;nodeIdentifier1;;nodeIdentifier2;conflict
/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_52d21ee_0cd5aaf/rev_52d21ee-0cd5aaf.revisions;/modules/swagger-oauth2-auth-server/src/main/scala/com/wordnik/swagger/auth/service/TokenScope.java;public static Long getUsername() ;public static String getUsername() ;
  public static Long getUsername() {
    return (Long)userThreadLocal.get();
=======
  public static String getUsername() {
    return (String)userThreadLocal.get();


/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a.revisions;/modules/swagger-annotations/src/main/java/com/wordnik/swagger/annotations/Api.java;boolean hidden() default false;boolean hidden() default false;
  /**
   * The 'path' that is going to be used to host the API Declaration of the
   * resource.
   * <p>
   * For JAX-RS resources, this would normally have the same value as the {@code @Path}
   * on the resource, but can be any other value as well. It will serve as the path
   * where the documentation is hosted.
   * <p>
   * For Servlets, this path has to be the path serving the Servlet.
   * <p>
   * If the value isn't preceded with a slash, one would be added to it.
   * 
   * @return the document location value, or empty string if not set
   */
  String value() default "";

  /**
   * A list of tags for API documentation control. 
   * Tags can be used for logical grouping of operations by resources or any other qualifier.
   * 
   * @since 1.5.2
   *
   * @return a string array of tag values
   */
  String[] tags() default "";

  /**
   * Corresponds to the `description` field of the Resource Listing API operation.
   * <p>
   * This should be a short description of the resource.
   *
   * @return a longer description about this API
   */
  String description() default "";

  /**
   * Corresponds to the `basePath` field of the API Declaration.
   * <p>
   * The `basePath` is derived automatically by Swagger. This property allows
   * overriding the default value if needed.  for swagger 2.0 specifications, this
   * value is no longer supported
   *
   * @since 1.3.7
   *
   * @return the basePath for this operation
   */
  @Deprecated
  String basePath() default "";

  /**
   * Optional explicit ordering of this API resource in the Resource Listing.
   * As of swagger-spec 2.0, this value is no longer used
   *
   *
   * @return the position of this API in the resource listing
   */
  @Deprecated
  int position() default 0;

  /**
   * Corresponds to the `produces` field of the API Declaration.
   * <p>
   * Takes in comma-separated values of content types.
   * For example, "application/json, application/xml" would suggest this API Resource
   * generates JSON and XML output.
   * <p>
   * For JAX-RS resources, this would automatically take the value of the {@code @Produces}
   * annotation if such exists. It can also be used to override the {@code @Produces} values
   * for the Swagger documentation.
   *
   * @return the supported media types supported by the server, or an empty string if not set
   */
  String produces() default "";

  /**
   * Corresponds to the `consumes` field of the API Declaration.
   * <p>
   * Takes in comma-separated values of content types.
   * For example, "application/json, application/xml" would suggest this API Resource
   * accepts JSON and XML input.
   * <p>
   * For JAX-RS resources, this would automatically take the value of the {@code @Consumes}
   * annotation if such exists. It can also be used to override the {@code @Consumes} values
   * for the Swagger documentation.
   * 
   * @return the consumes value, or empty string if not set
   */
  String consumes() default "";

  /**
   * This property is currently not in use.
   * 
   * @return the protocols supported by the server
   */
  String protocols() default "";

  /**
   * Corresponds to the `authorizations` field of the API Declaration.
   * <p>
   * Takes in a list of the required authorizations for this API Resource.
   * This may be overridden by specific operations.
   *
   * @see Authorization
   *
   * @return an array of authorizations required by the server, or a single, empty authorization value if not set
   */
  Authorization[] authorizations() default @Authorization(value = "", type = "");

  /**
   * Hides the api.
   *
   * @since 1.3.8
   *
   * @return true if the api should be hidden from the swagger documentation
   */
  boolean hidden() default false;
=======
    /**
     * The 'path' that is going to be used to host the API Declaration of the
     * resource.
     * <p/>
     * For JAX-RS resources, this would normally have the same value as the {@code @Path}
     * on the resource, but can be any other value as well. It will serve as the path
     * where the documentation is hosted.
     * <p/>
     * For Servlets, this path has to be the path serving the Servlet.
     * <p/>
     * If the value isn't preceded with a slash, one would be added to it.
     */
    String value();

    /**
     * Corresponds to the `description` field of the Resource Listing API operation.
     * <p/>
     * This should be a short description of the resource.
     */
    String description() default "";

    /**
     * Corresponds to the `basePath` field of the API Declaration.
     * <p/>
     * The `basePath` is derived automatically by Swagger. This property allows
     * overriding the default value if needed.
     *
     * @since 1.3.7
     */
    String basePath() default "";

    /**
     * Optional explicit ordering of this API resource in the Resource Listing.
     */
    int position() default 0;

    /**
     * Corresponds to the `produces` field of the API Declaration.
     * <p/>
     * Takes in comma-separated values of content types.
     * For example, "application/json, application/xml" would suggest this API Resource
     * generates JSON and XML output.
     * <p/>
     * For JAX-RS resources, this would automatically take the value of the {@code @Produces}
     * annotation if such exists. It can also be used to override the {@code @Produces} values
     * for the Swagger documentation.
     */
    String produces() default "";

    /**
     * Corresponds to the `consumes` field of the API Declaration.
     * <p/>
     * Takes in comma-separated values of content types.
     * For example, "application/json, application/xml" would suggest this API Resource
     * accepts JSON and XML input.
     * <p/>
     * For JAX-RS resources, this would automatically take the value of the {@code @Consumes}
     * annotation if such exists. It can also be used to override the {@code @Consumes} values
     * for the Swagger documentation.
     */
    String consumes() default "";

    /**
     * This property is currently not in use.
     */
    String protocols() default "";

    /**
     * Corresponds to the `authorizations` field of the API Declaration.
     * <p/>
     * Takes in a list of the required authorizations for this API Resource.
     * This may be overridden by specific operations.
     *
     * @see Authorization
     */
    Authorization[] authorizations() default @Authorization("");

    /**
     * Hides the api.
     *
     * @since 1.3.8
     */
    boolean hidden() default false;


/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_c784806_eaf37e8/rev_c784806-eaf37e8.revisions;/modules/swagger-jaxrs/src/main/java/com/wordnik/swagger/jaxrs/Reader.java;  enum ContainerWrapper ;  enum ContainerWrapper ;

  private boolean isIgnored(String path) {
    for (String item : config.getIgnoredRoutes()) {
      final int length = item.length();
      if (path.startsWith(item) && (path.length() == length || path.startsWith(PATH_DELIMITER, length))) {
        return true;
      }
    }
    return false;
  }

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }
=======

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }



/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_c784806_eaf37e8/rev_c784806-eaf37e8.revisions;/modules/swagger-jaxrs/src/main/java/com/wordnik/swagger/jaxrs/Reader.java;  LIST("list") ;  LIST("list") ;

  private boolean isIgnored(String path) {
    for (String item : config.getIgnoredRoutes()) {
      final int length = item.length();
      if (path.startsWith(item) && (path.length() == length || path.startsWith(PATH_DELIMITER, length))) {
        return true;
      }
    }
    return false;
  }

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }
=======

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }



/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_c784806_eaf37e8/rev_c784806-eaf37e8.revisions;/modules/swagger-jaxrs/src/main/java/com/wordnik/swagger/jaxrs/Reader.java;LIST("list") ;LIST("list") ;

  private boolean isIgnored(String path) {
    for (String item : config.getIgnoredRoutes()) {
      final int length = item.length();
      if (path.startsWith(item) && (path.length() == length || path.startsWith(PATH_DELIMITER, length))) {
        return true;
      }
    }
    return false;
  }

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }
=======

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }



/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_c784806_eaf37e8/rev_c784806-eaf37e8.revisions;/modules/swagger-jaxrs/src/main/java/com/wordnik/swagger/jaxrs/Reader.java;ARRAY("array") ;ARRAY("array") ;

  private boolean isIgnored(String path) {
    for (String item : config.getIgnoredRoutes()) {
      final int length = item.length();
      if (path.startsWith(item) && (path.length() == length || path.startsWith(PATH_DELIMITER, length))) {
        return true;
      }
    }
    return false;
  }

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }
=======

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }



/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_c784806_eaf37e8/rev_c784806-eaf37e8.revisions;/modules/swagger-jaxrs/src/main/java/com/wordnik/swagger/jaxrs/Reader.java;MAP("map") ;MAP("map") ;

  private boolean isIgnored(String path) {
    for (String item : config.getIgnoredRoutes()) {
      final int length = item.length();
      if (path.startsWith(item) && (path.length() == length || path.startsWith(PATH_DELIMITER, length))) {
        return true;
      }
    }
    return false;
  }

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }
=======

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }



/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_c784806_eaf37e8/rev_c784806-eaf37e8.revisions;/modules/swagger-jaxrs/src/main/java/com/wordnik/swagger/jaxrs/Reader.java;SET("set") ;SET("set") ;

  private boolean isIgnored(String path) {
    for (String item : config.getIgnoredRoutes()) {
      final int length = item.length();
      if (path.startsWith(item) && (path.length() == length || path.startsWith(PATH_DELIMITER, length))) {
        return true;
      }
    }
    return false;
  }

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }
=======

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }



/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_c784806_eaf37e8/rev_c784806-eaf37e8.revisions;/modules/swagger-jaxrs/src/main/java/com/wordnik/swagger/jaxrs/Reader.java;;   private final String container;   ContainerWrapper(String container) ;;   private final String container;   ContainerWrapper(String container) ;

  private boolean isIgnored(String path) {
    for (String item : config.getIgnoredRoutes()) {
      final int length = item.length();
      if (path.startsWith(item) && (path.length() == length || path.startsWith(PATH_DELIMITER, length))) {
        return true;
      }
    }
    return false;
  }

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }
=======

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }



/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_c784806_eaf37e8/rev_c784806-eaf37e8.revisions;/modules/swagger-jaxrs/src/main/java/com/wordnik/swagger/jaxrs/Reader.java;private final String container;private final String container;

  private boolean isIgnored(String path) {
    for (String item : config.getIgnoredRoutes()) {
      final int length = item.length();
      if (path.startsWith(item) && (path.length() == length || path.startsWith(PATH_DELIMITER, length))) {
        return true;
      }
    }
    return false;
  }

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }
=======

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }



/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_c784806_eaf37e8/rev_c784806-eaf37e8.revisions;/modules/swagger-jaxrs/src/main/java/com/wordnik/swagger/jaxrs/Reader.java;ContainerWrapper(String container) ;ContainerWrapper(String container) ;

  private boolean isIgnored(String path) {
    for (String item : config.getIgnoredRoutes()) {
      final int length = item.length();
      if (path.startsWith(item) && (path.length() == length || path.startsWith(PATH_DELIMITER, length))) {
        return true;
      }
    }
    return false;
  }

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }
=======

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }



/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_c784806_eaf37e8/rev_c784806-eaf37e8.revisions;/modules/swagger-jaxrs/src/main/java/com/wordnik/swagger/jaxrs/Reader.java;public Property wrap(String container, Property property) ;public Property wrap(String container, Property property) ;

  private boolean isIgnored(String path) {
    for (String item : config.getIgnoredRoutes()) {
      final int length = item.length();
      if (path.startsWith(item) && (path.length() == length || path.startsWith(PATH_DELIMITER, length))) {
        return true;
      }
    }
    return false;
  }

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }
=======

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }



/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_c784806_eaf37e8/rev_c784806-eaf37e8.revisions;/modules/swagger-jaxrs/src/main/java/com/wordnik/swagger/jaxrs/Reader.java;public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) ;public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) ;

  private boolean isIgnored(String path) {
    for (String item : config.getIgnoredRoutes()) {
      final int length = item.length();
      if (path.startsWith(item) && (path.length() == length || path.startsWith(PATH_DELIMITER, length))) {
        return true;
      }
    }
    return false;
  }

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }
=======

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }



/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_c784806_eaf37e8/rev_c784806-eaf37e8.revisions;/modules/swagger-jaxrs/src/main/java/com/wordnik/swagger/jaxrs/Reader.java;protected abstract Property doWrap(Property property);protected abstract Property doWrap(Property property);

  private boolean isIgnored(String path) {
    for (String item : config.getIgnoredRoutes()) {
      final int length = item.length();
      if (path.startsWith(item) && (path.length() == length || path.startsWith(PATH_DELIMITER, length))) {
        return true;
      }
    }
    return false;
  }

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }
=======

  enum ContainerWrapper {
    LIST("list") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    ARRAY("array") {
      @Override
      protected Property doWrap(Property property) {
        return new ArrayProperty(property);
      }
    },
    MAP("map") {
      @Override
      protected Property doWrap(Property property) {
        return new MapProperty(property);
      }
    },
    SET("set") {
      @Override
      protected Property doWrap(Property property) {
        ArrayProperty arrayProperty = new ArrayProperty(property);
        arrayProperty.setUniqueItems(true);
        return arrayProperty;
      }
    };

    private final String container;

    ContainerWrapper(String container) {
      this.container = container;
    }

    public Property wrap(String container, Property property) {
      if (this.container.equalsIgnoreCase(container)) {
        return doWrap(property);
      }
      return null;
    }

    public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
      final Set<ContainerWrapper> tmp = allowed.length > 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);
      for (ContainerWrapper wrapper : tmp) {
        final Property prop = wrapper.wrap(container, property);
        if (prop != null) {
          return prop;
        }
      }
      return property;
    }

    protected abstract Property doWrap(Property property);
  }



/home/paper219/Desktop/analysis/demonstration//projects/Swagger-core/revisions/rev_6de2d16_6f801c0/rev_6de2d16-6f801c0.revisions;/modules/swagger-models/src/main/java/io/swagger/models/Operation.java;@Override    public String toString() ;@Override	public String toString() ;

    public Operation vendorExtensions(Map<String, Object> vendorExtensions) {
        this.vendorExtensions.putAll( vendorExtensions );
        return this;
    }

    @Override
    public String toString() {
        return super.toString() + "[" + operationId + "]";
    }
=======

	@Override
	public String toString() {
		return super.toString() + "[" + operationId + "]";
	}


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;private byte[] content;private byte[] content;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;private byte[] signature;private byte[] signature;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;private long version ;private long version ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;private Date relayUntil;private Date relayUntil;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;private Date expiration;private Date expiration;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;private long id;private long id;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;private long cancel;private long cancel;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;private Set<Long> cancelSet;private Set<Long> cancelSet;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;private long minVer, maxVer;private long minVer, maxVer;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;private Set<String> matchingSubVers;private Set<String> matchingSubVers;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;private long priority;private long priority;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;private String comment, statusBar, reserved;private String comment, statusBar, reserved;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;private static final long MAX_SET_SIZE ;private static final long MAX_SET_SIZE ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException ;public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;@Override    void parse() throws ProtocolException ;@Override    void parse() throws ProtocolException ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public boolean isSignatureValid() ;public boolean isSignatureValid() ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;@Override    protected void parseLite() throws ProtocolException ;@Override    protected void parseLite() throws ProtocolException ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public Date getRelayUntil() ;public Date getRelayUntil() ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public void setRelayUntil(Date relayUntil) ;public void setRelayUntil(Date relayUntil) ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public Date getExpiration() ;public Date getExpiration() ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public void setExpiration(Date expiration) ;public void setExpiration(Date expiration) ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public long getId() ;public long getId() ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public void setId(long id) ;public void setId(long id) ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public long getCancel() ;public long getCancel() ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public void setCancel(long cancel) ;public void setCancel(long cancel) ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public long getMinVer() ;public long getMinVer() ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public void setMinVer(long minVer) ;public void setMinVer(long minVer) ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public long getMaxVer() ;public long getMaxVer() ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public void setMaxVer(long maxVer) ;public void setMaxVer(long maxVer) ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public long getPriority() ;public long getPriority() ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public void setPriority(long priority) ;public void setPriority(long priority) ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public String getComment() ;public String getComment() ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public void setComment(String comment) ;public void setComment(String comment) ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public String getStatusBar() ;public String getStatusBar() ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public void setStatusBar(String statusBar) ;public void setStatusBar(String statusBar) ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public String getReserved() ;public String getReserved() ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c.revisions;/src/com/google/bitcoin/core/AlertMessage.java;public void setReserved(String reserved) ;public void setReserved(String reserved) ;
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;private static final Logger LOGGER ;private static final Logger LOGGER ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;private final MetricObserver observer;private final MetricObserver observer;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;private final Cache<MetricConfig,CounterValue> cache;private final Cache<MetricConfig,CounterValue> cache;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;public CounterToRateMetricTransform(            MetricObserver observer, long heartbeat, TimeUnit unit) ;public CounterToRateMetricTransform(            MetricObserver observer, long heartbeat, TimeUnit unit) ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;public String getName() ;public String getName() ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;public void update(List<Metric> metrics) ;public void update(List<Metric> metrics) ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;public void reset() ;public void reset() ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;private boolean isCounter(Metric m) ;private boolean isCounter(Metric m) ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;  private static class CounterValue ;  private static class CounterValue ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;private final long timestamp;private final long timestamp;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;private final double value;private final double value;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;public CounterValue(long timestamp, double value) ;public CounterValue(long timestamp, double value) ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;public CounterValue(Metric m) ;public CounterValue(Metric m) ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;public double computeRate(CounterValue prev) ;public double computeRate(CounterValue prev) ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/test/java/com/netflix/servo/publish/CounterToRateMetricTransformTest.java;private static final TagList GAUGE ;private static final TagList GAUGE ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.netflix.servo.BasicTagList;
import com.netflix.servo.Metric;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.netflix.servo.BasicTagList.*;
import static org.testng.Assert.*;

public class CounterToRateMetricTransformTest {

    private static final TagList GAUGE =
        BasicTagList.copyOf(DataSourceType.GAUGE);

    private static final TagList COUNTER =
        BasicTagList.copyOf(DataSourceType.COUNTER);

    private List<Metric> mkList(long ts, int value) {
        return ImmutableList.of(
            new Metric("m1", EMPTY, ts, value),
            new Metric("m2", GAUGE, ts, value),
            new Metric("m3", COUNTER, ts, value)
        );
    }

    private Map<String,Double> mkMap(List<List<Metric>> updates) {
        Map<String,Double> map = Maps.newHashMap();
        for (Metric m : updates.get(0)) {
            map.put(m.getConfig().getName(), m.getValue().doubleValue());
        }
        return map;
    }

    @Test
    public void testSimpleRate() throws Exception {
        MemoryMetricObserver mmo = new MemoryMetricObserver("m", 1);
        MetricObserver transform =
            new CounterToRateMetricTransform(mmo, 120, TimeUnit.SECONDS);
        Map<String,Double> metrics = null;

        // First sample
        transform.update(mkList(0, 0));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 2);
        assertEquals(metrics.get("m3"), null);

        // Delta of 5 in 5 seconds
        transform.update(mkList(5000, 5));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 1.0, 0.00001);

        // Delta of 15 in 5 seconds
        transform.update(mkList(10000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 3.0, 0.00001);

        // No change from previous sample
        transform.update(mkList(15000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);

        // Decrease from previous sample
        transform.update(mkList(20000, 19));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.netflix.servo.tag.BasicTagList;
import com.netflix.servo.Metric;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.netflix.servo.tag.BasicTagList.*;
import static org.testng.Assert.*;

public class CounterToRateMetricTransformTest {

    private static final TagList GAUGE =
        BasicTagList.copyOf(DataSourceType.GAUGE);

    private static final TagList COUNTER =
        BasicTagList.copyOf(DataSourceType.COUNTER);

    private List<Metric> mkList(long ts, int value) {
        return ImmutableList.of(
            new Metric("m1", EMPTY, ts, value),
            new Metric("m2", GAUGE, ts, value),
            new Metric("m3", COUNTER, ts, value)
        );
    }

    private Map<String,Double> mkMap(List<List<Metric>> updates) {
        Map<String,Double> map = Maps.newHashMap();
        for (Metric m : updates.get(0)) {
            map.put(m.getConfig().getName(), m.getValue().doubleValue());
        }
        return map;
    }

    @Test
    public void testSimpleRate() throws Exception {
        MemoryMetricObserver mmo = new MemoryMetricObserver("m", 1);
        MetricObserver transform =
            new CounterToRateMetricTransform(mmo, 120, TimeUnit.SECONDS);
        Map<String,Double> metrics = null;

        // First sample
        transform.update(mkList(0, 0));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 2);
        assertEquals(metrics.get("m3"), null);

        // Delta of 5 in 5 seconds
        transform.update(mkList(5000, 5));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 1.0, 0.00001);

        // Delta of 15 in 5 seconds
        transform.update(mkList(10000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 3.0, 0.00001);

        // No change from previous sample
        transform.update(mkList(15000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);

        // Decrease from previous sample
        transform.update(mkList(20000, 19));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/test/java/com/netflix/servo/publish/CounterToRateMetricTransformTest.java;private static final TagList COUNTER ;private static final TagList COUNTER ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.netflix.servo.BasicTagList;
import com.netflix.servo.Metric;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.netflix.servo.BasicTagList.*;
import static org.testng.Assert.*;

public class CounterToRateMetricTransformTest {

    private static final TagList GAUGE =
        BasicTagList.copyOf(DataSourceType.GAUGE);

    private static final TagList COUNTER =
        BasicTagList.copyOf(DataSourceType.COUNTER);

    private List<Metric> mkList(long ts, int value) {
        return ImmutableList.of(
            new Metric("m1", EMPTY, ts, value),
            new Metric("m2", GAUGE, ts, value),
            new Metric("m3", COUNTER, ts, value)
        );
    }

    private Map<String,Double> mkMap(List<List<Metric>> updates) {
        Map<String,Double> map = Maps.newHashMap();
        for (Metric m : updates.get(0)) {
            map.put(m.getConfig().getName(), m.getValue().doubleValue());
        }
        return map;
    }

    @Test
    public void testSimpleRate() throws Exception {
        MemoryMetricObserver mmo = new MemoryMetricObserver("m", 1);
        MetricObserver transform =
            new CounterToRateMetricTransform(mmo, 120, TimeUnit.SECONDS);
        Map<String,Double> metrics = null;

        // First sample
        transform.update(mkList(0, 0));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 2);
        assertEquals(metrics.get("m3"), null);

        // Delta of 5 in 5 seconds
        transform.update(mkList(5000, 5));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 1.0, 0.00001);

        // Delta of 15 in 5 seconds
        transform.update(mkList(10000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 3.0, 0.00001);

        // No change from previous sample
        transform.update(mkList(15000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);

        // Decrease from previous sample
        transform.update(mkList(20000, 19));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.netflix.servo.tag.BasicTagList;
import com.netflix.servo.Metric;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.netflix.servo.tag.BasicTagList.*;
import static org.testng.Assert.*;

public class CounterToRateMetricTransformTest {

    private static final TagList GAUGE =
        BasicTagList.copyOf(DataSourceType.GAUGE);

    private static final TagList COUNTER =
        BasicTagList.copyOf(DataSourceType.COUNTER);

    private List<Metric> mkList(long ts, int value) {
        return ImmutableList.of(
            new Metric("m1", EMPTY, ts, value),
            new Metric("m2", GAUGE, ts, value),
            new Metric("m3", COUNTER, ts, value)
        );
    }

    private Map<String,Double> mkMap(List<List<Metric>> updates) {
        Map<String,Double> map = Maps.newHashMap();
        for (Metric m : updates.get(0)) {
            map.put(m.getConfig().getName(), m.getValue().doubleValue());
        }
        return map;
    }

    @Test
    public void testSimpleRate() throws Exception {
        MemoryMetricObserver mmo = new MemoryMetricObserver("m", 1);
        MetricObserver transform =
            new CounterToRateMetricTransform(mmo, 120, TimeUnit.SECONDS);
        Map<String,Double> metrics = null;

        // First sample
        transform.update(mkList(0, 0));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 2);
        assertEquals(metrics.get("m3"), null);

        // Delta of 5 in 5 seconds
        transform.update(mkList(5000, 5));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 1.0, 0.00001);

        // Delta of 15 in 5 seconds
        transform.update(mkList(10000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 3.0, 0.00001);

        // No change from previous sample
        transform.update(mkList(15000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);

        // Decrease from previous sample
        transform.update(mkList(20000, 19));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/test/java/com/netflix/servo/publish/CounterToRateMetricTransformTest.java;private List<Metric> mkList(long ts, int value) ;private List<Metric> mkList(long ts, int value) ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.netflix.servo.BasicTagList;
import com.netflix.servo.Metric;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.netflix.servo.BasicTagList.*;
import static org.testng.Assert.*;

public class CounterToRateMetricTransformTest {

    private static final TagList GAUGE =
        BasicTagList.copyOf(DataSourceType.GAUGE);

    private static final TagList COUNTER =
        BasicTagList.copyOf(DataSourceType.COUNTER);

    private List<Metric> mkList(long ts, int value) {
        return ImmutableList.of(
            new Metric("m1", EMPTY, ts, value),
            new Metric("m2", GAUGE, ts, value),
            new Metric("m3", COUNTER, ts, value)
        );
    }

    private Map<String,Double> mkMap(List<List<Metric>> updates) {
        Map<String,Double> map = Maps.newHashMap();
        for (Metric m : updates.get(0)) {
            map.put(m.getConfig().getName(), m.getValue().doubleValue());
        }
        return map;
    }

    @Test
    public void testSimpleRate() throws Exception {
        MemoryMetricObserver mmo = new MemoryMetricObserver("m", 1);
        MetricObserver transform =
            new CounterToRateMetricTransform(mmo, 120, TimeUnit.SECONDS);
        Map<String,Double> metrics = null;

        // First sample
        transform.update(mkList(0, 0));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 2);
        assertEquals(metrics.get("m3"), null);

        // Delta of 5 in 5 seconds
        transform.update(mkList(5000, 5));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 1.0, 0.00001);

        // Delta of 15 in 5 seconds
        transform.update(mkList(10000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 3.0, 0.00001);

        // No change from previous sample
        transform.update(mkList(15000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);

        // Decrease from previous sample
        transform.update(mkList(20000, 19));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.netflix.servo.tag.BasicTagList;
import com.netflix.servo.Metric;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.netflix.servo.tag.BasicTagList.*;
import static org.testng.Assert.*;

public class CounterToRateMetricTransformTest {

    private static final TagList GAUGE =
        BasicTagList.copyOf(DataSourceType.GAUGE);

    private static final TagList COUNTER =
        BasicTagList.copyOf(DataSourceType.COUNTER);

    private List<Metric> mkList(long ts, int value) {
        return ImmutableList.of(
            new Metric("m1", EMPTY, ts, value),
            new Metric("m2", GAUGE, ts, value),
            new Metric("m3", COUNTER, ts, value)
        );
    }

    private Map<String,Double> mkMap(List<List<Metric>> updates) {
        Map<String,Double> map = Maps.newHashMap();
        for (Metric m : updates.get(0)) {
            map.put(m.getConfig().getName(), m.getValue().doubleValue());
        }
        return map;
    }

    @Test
    public void testSimpleRate() throws Exception {
        MemoryMetricObserver mmo = new MemoryMetricObserver("m", 1);
        MetricObserver transform =
            new CounterToRateMetricTransform(mmo, 120, TimeUnit.SECONDS);
        Map<String,Double> metrics = null;

        // First sample
        transform.update(mkList(0, 0));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 2);
        assertEquals(metrics.get("m3"), null);

        // Delta of 5 in 5 seconds
        transform.update(mkList(5000, 5));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 1.0, 0.00001);

        // Delta of 15 in 5 seconds
        transform.update(mkList(10000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 3.0, 0.00001);

        // No change from previous sample
        transform.update(mkList(15000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);

        // Decrease from previous sample
        transform.update(mkList(20000, 19));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/test/java/com/netflix/servo/publish/CounterToRateMetricTransformTest.java;private Map<String,Double> mkMap(List<List<Metric>> updates) ;private Map<String,Double> mkMap(List<List<Metric>> updates) ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.netflix.servo.BasicTagList;
import com.netflix.servo.Metric;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.netflix.servo.BasicTagList.*;
import static org.testng.Assert.*;

public class CounterToRateMetricTransformTest {

    private static final TagList GAUGE =
        BasicTagList.copyOf(DataSourceType.GAUGE);

    private static final TagList COUNTER =
        BasicTagList.copyOf(DataSourceType.COUNTER);

    private List<Metric> mkList(long ts, int value) {
        return ImmutableList.of(
            new Metric("m1", EMPTY, ts, value),
            new Metric("m2", GAUGE, ts, value),
            new Metric("m3", COUNTER, ts, value)
        );
    }

    private Map<String,Double> mkMap(List<List<Metric>> updates) {
        Map<String,Double> map = Maps.newHashMap();
        for (Metric m : updates.get(0)) {
            map.put(m.getConfig().getName(), m.getValue().doubleValue());
        }
        return map;
    }

    @Test
    public void testSimpleRate() throws Exception {
        MemoryMetricObserver mmo = new MemoryMetricObserver("m", 1);
        MetricObserver transform =
            new CounterToRateMetricTransform(mmo, 120, TimeUnit.SECONDS);
        Map<String,Double> metrics = null;

        // First sample
        transform.update(mkList(0, 0));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 2);
        assertEquals(metrics.get("m3"), null);

        // Delta of 5 in 5 seconds
        transform.update(mkList(5000, 5));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 1.0, 0.00001);

        // Delta of 15 in 5 seconds
        transform.update(mkList(10000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 3.0, 0.00001);

        // No change from previous sample
        transform.update(mkList(15000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);

        // Decrease from previous sample
        transform.update(mkList(20000, 19));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.netflix.servo.tag.BasicTagList;
import com.netflix.servo.Metric;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.netflix.servo.tag.BasicTagList.*;
import static org.testng.Assert.*;

public class CounterToRateMetricTransformTest {

    private static final TagList GAUGE =
        BasicTagList.copyOf(DataSourceType.GAUGE);

    private static final TagList COUNTER =
        BasicTagList.copyOf(DataSourceType.COUNTER);

    private List<Metric> mkList(long ts, int value) {
        return ImmutableList.of(
            new Metric("m1", EMPTY, ts, value),
            new Metric("m2", GAUGE, ts, value),
            new Metric("m3", COUNTER, ts, value)
        );
    }

    private Map<String,Double> mkMap(List<List<Metric>> updates) {
        Map<String,Double> map = Maps.newHashMap();
        for (Metric m : updates.get(0)) {
            map.put(m.getConfig().getName(), m.getValue().doubleValue());
        }
        return map;
    }

    @Test
    public void testSimpleRate() throws Exception {
        MemoryMetricObserver mmo = new MemoryMetricObserver("m", 1);
        MetricObserver transform =
            new CounterToRateMetricTransform(mmo, 120, TimeUnit.SECONDS);
        Map<String,Double> metrics = null;

        // First sample
        transform.update(mkList(0, 0));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 2);
        assertEquals(metrics.get("m3"), null);

        // Delta of 5 in 5 seconds
        transform.update(mkList(5000, 5));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 1.0, 0.00001);

        // Delta of 15 in 5 seconds
        transform.update(mkList(10000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 3.0, 0.00001);

        // No change from previous sample
        transform.update(mkList(15000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);

        // Decrease from previous sample
        transform.update(mkList(20000, 19));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);
    }


/home/paper219/Desktop/analysis/demonstration//projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7.revisions;/servo-core/src/test/java/com/netflix/servo/publish/CounterToRateMetricTransformTest.java;@Test    public void testSimpleRate() throws Exception ;@Test    public void testSimpleRate() throws Exception ;
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.netflix.servo.BasicTagList;
import com.netflix.servo.Metric;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.netflix.servo.BasicTagList.*;
import static org.testng.Assert.*;

public class CounterToRateMetricTransformTest {

    private static final TagList GAUGE =
        BasicTagList.copyOf(DataSourceType.GAUGE);

    private static final TagList COUNTER =
        BasicTagList.copyOf(DataSourceType.COUNTER);

    private List<Metric> mkList(long ts, int value) {
        return ImmutableList.of(
            new Metric("m1", EMPTY, ts, value),
            new Metric("m2", GAUGE, ts, value),
            new Metric("m3", COUNTER, ts, value)
        );
    }

    private Map<String,Double> mkMap(List<List<Metric>> updates) {
        Map<String,Double> map = Maps.newHashMap();
        for (Metric m : updates.get(0)) {
            map.put(m.getConfig().getName(), m.getValue().doubleValue());
        }
        return map;
    }

    @Test
    public void testSimpleRate() throws Exception {
        MemoryMetricObserver mmo = new MemoryMetricObserver("m", 1);
        MetricObserver transform =
            new CounterToRateMetricTransform(mmo, 120, TimeUnit.SECONDS);
        Map<String,Double> metrics = null;

        // First sample
        transform.update(mkList(0, 0));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 2);
        assertEquals(metrics.get("m3"), null);

        // Delta of 5 in 5 seconds
        transform.update(mkList(5000, 5));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 1.0, 0.00001);

        // Delta of 15 in 5 seconds
        transform.update(mkList(10000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 3.0, 0.00001);

        // No change from previous sample
        transform.update(mkList(15000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);

        // Decrease from previous sample
        transform.update(mkList(20000, 19));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.netflix.servo.tag.BasicTagList;
import com.netflix.servo.Metric;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.netflix.servo.tag.BasicTagList.*;
import static org.testng.Assert.*;

public class CounterToRateMetricTransformTest {

    private static final TagList GAUGE =
        BasicTagList.copyOf(DataSourceType.GAUGE);

    private static final TagList COUNTER =
        BasicTagList.copyOf(DataSourceType.COUNTER);

    private List<Metric> mkList(long ts, int value) {
        return ImmutableList.of(
            new Metric("m1", EMPTY, ts, value),
            new Metric("m2", GAUGE, ts, value),
            new Metric("m3", COUNTER, ts, value)
        );
    }

    private Map<String,Double> mkMap(List<List<Metric>> updates) {
        Map<String,Double> map = Maps.newHashMap();
        for (Metric m : updates.get(0)) {
            map.put(m.getConfig().getName(), m.getValue().doubleValue());
        }
        return map;
    }

    @Test
    public void testSimpleRate() throws Exception {
        MemoryMetricObserver mmo = new MemoryMetricObserver("m", 1);
        MetricObserver transform =
            new CounterToRateMetricTransform(mmo, 120, TimeUnit.SECONDS);
        Map<String,Double> metrics = null;

        // First sample
        transform.update(mkList(0, 0));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 2);
        assertEquals(metrics.get("m3"), null);

        // Delta of 5 in 5 seconds
        transform.update(mkList(5000, 5));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 1.0, 0.00001);

        // Delta of 15 in 5 seconds
        transform.update(mkList(10000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 3.0, 0.00001);

        // No change from previous sample
        transform.update(mkList(15000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);

        // Decrease from previous sample
        transform.update(mkList(20000, 19));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);
    }


/home/paper219/Desktop/analysis/demonstration//projects/graphql-java/revisions/rev_0072285_3e63dc1/rev_0072285-3e63dc1.revisions;/src/main/java/graphql/schema/idl/errors/NotAnInputTypeError.java;public NotAnInputTypeError(TypeDefinition typeDefinition) ;public NotAnInputTypeError(TypeDefinition typeDefinition) ;
package graphql.schema.idl.errors;

import graphql.language.TypeDefinition;

import static java.lang.String.format;

public class NotAnInputTypeError extends BaseError {

    public NotAnInputTypeError(TypeDefinition typeDefinition) {
        super(typeDefinition, format("expected InputType, but found %s type %s", typeDefinition.getName(), lineCol(typeDefinition)));
    }
}=======
package graphql.schema.idl.errors;

import graphql.language.TypeDefinition;

import static java.lang.String.format;

public class NotAnInputTypeError extends BaseError {

    public NotAnInputTypeError(TypeDefinition typeDefinition) {
        super(typeDefinition, format("expected InputType, but found %s type", typeDefinition.getName()));
    }


/home/paper219/Desktop/analysis/demonstration//projects/graphql-java/revisions/rev_0072285_3e63dc1/rev_0072285-3e63dc1.revisions;/src/main/java/graphql/schema/idl/errors/NotAnOutputTypeError.java;public NotAnOutputTypeError(TypeDefinition typeDefinition) ;public NotAnOutputTypeError(TypeDefinition typeDefinition) ;
package graphql.schema.idl.errors;

import graphql.language.TypeDefinition;

import static java.lang.String.format;

public class NotAnOutputTypeError extends BaseError {

    public NotAnOutputTypeError(TypeDefinition typeDefinition) {
        super(typeDefinition, format("expected OutputType, but found %s type %s", typeDefinition.getName(), lineCol(typeDefinition)));
    }
}=======
package graphql.schema.idl.errors;

import graphql.language.TypeDefinition;

import static java.lang.String.format;

public class NotAnOutputTypeError extends BaseError {

    public NotAnOutputTypeError(TypeDefinition typeDefinition) {
        super(typeDefinition, format("expected OutputType, but found %s type", typeDefinition.getName()));
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClient.java;public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) ;public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) ;
    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }
=======
    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed
     * {@code sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link SSLEngineFactory} for all secured connections created by the newly created client
     *                                                 instance.
     *
     * @return A new {@link HttpClient} instance.
     */
    public abstract HttpClient<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClient.java;public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) ;public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) ;
    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }
=======
    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed
     * {@code sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link SSLEngineFactory} for all secured connections created by the newly created client
     *                                                 instance.
     *
     * @return A new {@link HttpClient} instance.
     */
    public abstract HttpClient<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClient.java;public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) ;public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) ;
    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }
=======
    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed
     * {@code sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link SSLEngineFactory} for all secured connections created by the newly created client
     *                                                 instance.
     *
     * @return A new {@link HttpClient} instance.
     */
    public abstract HttpClient<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClient.java;public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) ;public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) ;
    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }
=======
    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed
     * {@code sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link SSLEngineFactory} for all secured connections created by the newly created client
     *                                                 instance.
     *
     * @return A new {@link HttpClient} instance.
     */
    public abstract HttpClient<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClient.java;public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,                                                        Class<? extends Channel> channelClass, String host, int port) ;public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,                                                        Class<? extends Channel> channelClass, String host, int port) ;
    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }
=======
    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed
     * {@code sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link SSLEngineFactory} for all secured connections created by the newly created client
     *                                                 instance.
     *
     * @return A new {@link HttpClient} instance.
     */
    public abstract HttpClient<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClient.java;public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,                                                        Class<? extends Channel> channelClass, String name, String host,                                                        int port) ;public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,                                                        Class<? extends Channel> channelClass, String name, String host,                                                        int port) ;
    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }
=======
    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed
     * {@code sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link SSLEngineFactory} for all secured connections created by the newly created client
     *                                                 instance.
     *
     * @return A new {@link HttpClient} instance.
     */
    public abstract HttpClient<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClient.java;public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,                                                        Class<? extends Channel> channelClass,                                                        ServerPool<ClientMetricsEvent<?>> serverPool) ;public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,                                                        Class<? extends Channel> channelClass,                                                        ServerPool<ClientMetricsEvent<?>> serverPool) ;
    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }
=======
    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed
     * {@code sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link SSLEngineFactory} for all secured connections created by the newly created client
     *                                                 instance.
     *
     * @return A new {@link HttpClient} instance.
     */
    public abstract HttpClient<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClient.java;public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,                                                        Class<? extends Channel> channelClass, String name,                                                        ServerPool<ClientMetricsEvent<?>> serverPool) ;public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,                                                        Class<? extends Channel> channelClass, String name,                                                        ServerPool<ClientMetricsEvent<?>> serverPool) ;
    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }
=======
    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed
     * {@code sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link SSLEngineFactory} for all secured connections created by the newly created client
     *                                                 instance.
     *
     * @return A new {@link HttpClient} instance.
     */
    public abstract HttpClient<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClient.java;public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) ;public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) ;
    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }
=======
    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed
     * {@code sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link SSLEngineFactory} for all secured connections created by the newly created client
     *                                                 instance.
     *
     * @return A new {@link HttpClient} instance.
     */
    public abstract HttpClient<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClient.java;public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) ;public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) ;
    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }
=======
    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed
     * {@code sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link SSLEngineFactory} for all secured connections created by the newly created client
     *                                                 instance.
     *
     * @return A new {@link HttpClient} instance.
     */
    public abstract HttpClient<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClient.java;public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,                                                        Class<? extends Channel> channelClass,                                                        SocketAddress remoteAddress) ;public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,                                                        Class<? extends Channel> channelClass,                                                        SocketAddress remoteAddress) ;
    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }
=======
    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed
     * {@code sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link SSLEngineFactory} for all secured connections created by the newly created client
     *                                                 instance.
     *
     * @return A new {@link HttpClient} instance.
     */
    public abstract HttpClient<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClient.java;public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,                                                        Class<? extends Channel> channelClass, String name,                                                        SocketAddress remoteAddress) ;public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,                                                        Class<? extends Channel> channelClass, String name,                                                        SocketAddress remoteAddress) ;
    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }
=======
    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed
     * {@code sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link SSLEngineFactory} for all secured connections created by the newly created client
     *                                                 instance.
     *
     * @return A new {@link HttpClient} instance.
     */
    public abstract HttpClient<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClient.java;private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) ;private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) ;
    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }
=======
    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed
     * {@code sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link SSLEngineFactory} for all secured connections created by the newly created client
     *                                                 instance.
     *
     * @return A new {@link HttpClient} instance.
     */
    public abstract HttpClient<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    public static HttpClient<ByteBuf, ByteBuf> newClient(ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String host, int port) {
        return newClient(HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, String host, int port) {
        return _newClient(TcpClient.newClient(name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String host, int port) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, host, port);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name, String host,
                                                        int port) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, new InetSocketAddress(host, port)));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, serverPool);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        ServerPool<ClientMetricsEvent<?>> serverPool) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, serverPool));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(SocketAddress remoteAddress) {
        return newClient(HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(String name, SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(name, remoteAddress));
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass,
                                                        SocketAddress remoteAddress) {
        return newClient(eventLoopGroup, channelClass, HTTP_CLIENT_NO_NAME, remoteAddress);
    }

    public static HttpClient<ByteBuf, ByteBuf> newClient(EventLoopGroup eventLoopGroup,
                                                        Class<? extends Channel> channelClass, String name,
                                                        SocketAddress remoteAddress) {
        return _newClient(TcpClient.newClient(eventLoopGroup, channelClass, name, remoteAddress));
    }

    private static HttpClient<ByteBuf, ByteBuf> _newClient(TcpClient<ByteBuf, ByteBuf> tcpClient) {
        return HttpClientImpl.create(tcpClient);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,                                                                       Func0<ChannelHandler> handlerFactory);public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,                                                                       Func0<ChannelHandler> handlerFactory);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,                                                                       Func0<ChannelHandler> handlerFactory);public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,                                                                       Func0<ChannelHandler> handlerFactory);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,                                                                      Func0<ChannelHandler> handlerFactory);public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,                                                                      Func0<ChannelHandler> handlerFactory);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,                                                                      Func0<ChannelHandler> handlerFactory);public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,                                                                      Func0<ChannelHandler> handlerFactory);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,                                                                        Func0<ChannelHandler> handlerFactory);public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,                                                                        Func0<ChannelHandler> handlerFactory);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,                                                                        String name,                                                                        Func0<ChannelHandler> handlerFactory);public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,                                                                        String name,                                                                        Func0<ChannelHandler> handlerFactory);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,                                                                       Func0<ChannelHandler> handlerFactory);public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,                                                                       Func0<ChannelHandler> handlerFactory);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,                                                                       String name,                                                                       Func0<ChannelHandler> handlerFactory);public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,                                                                       String name,                                                                       Func0<ChannelHandler> handlerFactory);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract int getServerPort();public abstract int getServerPort();
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract void startAndWait(RequestHandler<I, O> requestHandler);public abstract void startAndWait(RequestHandler<I, O> requestHandler);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract void shutdown();public abstract void shutdown();
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract void waitTillShutdown();public abstract void waitTillShutdown();
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public static HttpServer<ByteBuf, ByteBuf> newServer() ;public static HttpServer<ByteBuf, ByteBuf> newServer() ;
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public static HttpServer<ByteBuf, ByteBuf> newServer(int port) ;public static HttpServer<ByteBuf, ByteBuf> newServer(int port) ;
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,                                                         Class<? extends ServerChannel> channelClass) ;public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,                                                         Class<? extends ServerChannel> channelClass) ;
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,                                                         EventLoopGroup clientGroup,                                                         Class<? extends ServerChannel> channelClass) ;public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,                                                         EventLoopGroup clientGroup,                                                         Class<? extends ServerChannel> channelClass) ;
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f.revisions;/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) ;private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) ;
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }


/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_be2a71b_752d772/rev_be2a71b-752d772.revisions;/rxnetty-common/src/main/java/io/reactivex/netty/threads/RxJavaEventloopScheduler.java;private final EventLoopGroup eventLoopGroup;private final EventLoopGroup eventLoopGroup;
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package io.reactivex.netty.threads;

import io.netty.channel.EventLoop;
import io.netty.channel.EventLoopGroup;
import io.netty.util.concurrent.Future;
import rx.Scheduler;
import rx.Subscription;
import rx.annotations.Beta;
import rx.functions.Action0;
import rx.internal.schedulers.EventLoopsScheduler;
import rx.internal.schedulers.ScheduledAction;
import rx.internal.util.SubscriptionList;
import rx.subscriptions.CompositeSubscription;
import rx.subscriptions.Subscriptions;

import java.util.concurrent.TimeUnit;

/**
 * A scheduler that uses a provided {@link EventLoopGroup} instance to schedule tasks. This should typically be used as
 * a computation scheduler or any other scheduler that do not schedule blocking tasks. <p>
 */
@Beta
public class RxJavaEventloopScheduler extends Scheduler {

    private final EventLoopGroup eventLoopGroup;

    public RxJavaEventloopScheduler(EventLoopGroup eventLoopGroup) {
        this.eventLoopGroup = eventLoopGroup;
    }

    @Override
    public Worker createWorker() {
        final EventLoop eventLoop = eventLoopGroup.next();
        return new EventloopWorker(eventLoop);
    }

    /**
     * This code is more or less copied from RxJava's {@link EventLoopsScheduler} worker code.
     **/
    /*Visible for testing*/static class EventloopWorker extends Worker {

        /**
         * Why are there two subscription holders?
         *
         * The serial subscriptions are used for non-delayed schedules which are always executed (and hence removed)
         * in order. Since SubscriptionList holds the subs as a linked list, removals are optimal for serial removes.
         * OTOH, delayed schedules are executed (and hence removed) out of order and hence a CompositeSubscription,
         * that stores the subs in a hash structure is more optimal for removals.
         */
        private final SubscriptionList serial;
        private final CompositeSubscription timed;
        private final SubscriptionList both;
        private final EventLoop eventLoop;

        public EventloopWorker(EventLoop eventLoop) {
            this.eventLoop = eventLoop;
            serial = new SubscriptionList();
            timed = new CompositeSubscription();
            both = new SubscriptionList(serial, timed);
        }

        @Override
        public Subscription schedule(final Action0 action) {
            return schedule(action, 0, TimeUnit.DAYS);
        }

        @Override
        public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {

            if (isUnsubscribed()) {
                return Subscriptions.unsubscribed();
            }

            final ScheduledAction sa;

            if (delayTime <= 0) {
                sa = new ScheduledAction(action, serial);
                serial.add(sa);
            } else {
                sa = new ScheduledAction(action, timed);
                timed.add(sa);
            }

            final Future<?> result = eventLoop.schedule(sa, delayTime, unit);
            Subscription cancelFuture = Subscriptions.create(new Action0() {
                @Override
                public void call() {
                    result.cancel(false);
                }
            });
            sa.add(cancelFuture); /*An unsubscribe of the returned sub should cancel the future*/
            return sa;
        }

        @Override
        public void unsubscribe() {
            both.unsubscribe();
        }

        @Override
        public boolean isUnsubscribed() {
            return both.isUnsubscribed();
        }

        /*Visible for testing*/boolean hasScheduledSubscriptions() {
            return serial.hasSubscriptions();
        }

        /*Visible for testing*/boolean hasDelayScheduledSubscriptions() {
            return timed.hasSubscriptions();
        }
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package io.reactivex.netty.threads;

import io.netty.channel.EventLoop;
import io.netty.channel.EventLoopGroup;
import io.netty.util.concurrent.Future;
import rx.Scheduler;
import rx.Subscription;
import rx.annotations.Beta;
import rx.functions.Action0;
import rx.internal.util.SubscriptionList;
import rx.subscriptions.Subscriptions;

import java.util.concurrent.TimeUnit;

/**
 * A scheduler that uses a provided {@link EventLoopGroup} instance to schedule tasks. This should typically be used as
 * a computation scheduler or any other scheduler that do not schedule blocking tasks. <p>
 */
@Beta
public class RxJavaEventloopScheduler extends Scheduler {

    private final EventLoopGroup eventLoopGroup;

    public RxJavaEventloopScheduler(EventLoopGroup eventLoopGroup) {
        this.eventLoopGroup = eventLoopGroup;
    }

    @Override
    public Worker createWorker() {
        final EventLoop eventLoop = eventLoopGroup.next();

        return new Worker() {

            private final SubscriptionList subs = new SubscriptionList();

            @Override
            public Subscription schedule(final Action0 action) {
                if (isUnsubscribed()) {
                    return Subscriptions.unsubscribed();
                }

                /*If already on the eventloop then execute the action, else schedule it on the eventloop*/
                if (eventLoop.inEventLoop()) {
                    action.call();
                    return Subscriptions.empty();
                } else {
                    final Future<?> result = eventLoop.submit(new Runnable() {
                        @Override
                        public void run() {
                            action.call();
                        }
                    });

                    Subscription toReturn = fromFuture(result);
                    subs.add(toReturn);
                    return toReturn;
                }
            }

            @Override
            public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {

                if (delayTime <= 0) {
                    return schedule(action);
                }

                if (isUnsubscribed()) {
                    return Subscriptions.unsubscribed();
                }

                final Future<?> result = eventLoop.schedule(new Runnable() {
                    @Override
                    public void run() {
                        action.call();
                    }
                }, delayTime, unit);

                Subscription toReturn = fromFuture(result);
                subs.add(toReturn);
                return toReturn;
            }

            @Override
            public void unsubscribe() {
                subs.unsubscribe();
            }

            @Override
            public boolean isUnsubscribed() {
                return subs.isUnsubscribed();
            }

            private Subscription fromFuture(final Future<?> result) {
                return Subscriptions.create(new Action0() {
                    @Override
                    public void call() {
                        result.cancel(false);
                    }
                });
            }
        };
    }



/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_be2a71b_752d772/rev_be2a71b-752d772.revisions;/rxnetty-common/src/main/java/io/reactivex/netty/threads/RxJavaEventloopScheduler.java;public RxJavaEventloopScheduler(EventLoopGroup eventLoopGroup) ;public RxJavaEventloopScheduler(EventLoopGroup eventLoopGroup) ;
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package io.reactivex.netty.threads;

import io.netty.channel.EventLoop;
import io.netty.channel.EventLoopGroup;
import io.netty.util.concurrent.Future;
import rx.Scheduler;
import rx.Subscription;
import rx.annotations.Beta;
import rx.functions.Action0;
import rx.internal.schedulers.EventLoopsScheduler;
import rx.internal.schedulers.ScheduledAction;
import rx.internal.util.SubscriptionList;
import rx.subscriptions.CompositeSubscription;
import rx.subscriptions.Subscriptions;

import java.util.concurrent.TimeUnit;

/**
 * A scheduler that uses a provided {@link EventLoopGroup} instance to schedule tasks. This should typically be used as
 * a computation scheduler or any other scheduler that do not schedule blocking tasks. <p>
 */
@Beta
public class RxJavaEventloopScheduler extends Scheduler {

    private final EventLoopGroup eventLoopGroup;

    public RxJavaEventloopScheduler(EventLoopGroup eventLoopGroup) {
        this.eventLoopGroup = eventLoopGroup;
    }

    @Override
    public Worker createWorker() {
        final EventLoop eventLoop = eventLoopGroup.next();
        return new EventloopWorker(eventLoop);
    }

    /**
     * This code is more or less copied from RxJava's {@link EventLoopsScheduler} worker code.
     **/
    /*Visible for testing*/static class EventloopWorker extends Worker {

        /**
         * Why are there two subscription holders?
         *
         * The serial subscriptions are used for non-delayed schedules which are always executed (and hence removed)
         * in order. Since SubscriptionList holds the subs as a linked list, removals are optimal for serial removes.
         * OTOH, delayed schedules are executed (and hence removed) out of order and hence a CompositeSubscription,
         * that stores the subs in a hash structure is more optimal for removals.
         */
        private final SubscriptionList serial;
        private final CompositeSubscription timed;
        private final SubscriptionList both;
        private final EventLoop eventLoop;

        public EventloopWorker(EventLoop eventLoop) {
            this.eventLoop = eventLoop;
            serial = new SubscriptionList();
            timed = new CompositeSubscription();
            both = new SubscriptionList(serial, timed);
        }

        @Override
        public Subscription schedule(final Action0 action) {
            return schedule(action, 0, TimeUnit.DAYS);
        }

        @Override
        public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {

            if (isUnsubscribed()) {
                return Subscriptions.unsubscribed();
            }

            final ScheduledAction sa;

            if (delayTime <= 0) {
                sa = new ScheduledAction(action, serial);
                serial.add(sa);
            } else {
                sa = new ScheduledAction(action, timed);
                timed.add(sa);
            }

            final Future<?> result = eventLoop.schedule(sa, delayTime, unit);
            Subscription cancelFuture = Subscriptions.create(new Action0() {
                @Override
                public void call() {
                    result.cancel(false);
                }
            });
            sa.add(cancelFuture); /*An unsubscribe of the returned sub should cancel the future*/
            return sa;
        }

        @Override
        public void unsubscribe() {
            both.unsubscribe();
        }

        @Override
        public boolean isUnsubscribed() {
            return both.isUnsubscribed();
        }

        /*Visible for testing*/boolean hasScheduledSubscriptions() {
            return serial.hasSubscriptions();
        }

        /*Visible for testing*/boolean hasDelayScheduledSubscriptions() {
            return timed.hasSubscriptions();
        }
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package io.reactivex.netty.threads;

import io.netty.channel.EventLoop;
import io.netty.channel.EventLoopGroup;
import io.netty.util.concurrent.Future;
import rx.Scheduler;
import rx.Subscription;
import rx.annotations.Beta;
import rx.functions.Action0;
import rx.internal.util.SubscriptionList;
import rx.subscriptions.Subscriptions;

import java.util.concurrent.TimeUnit;

/**
 * A scheduler that uses a provided {@link EventLoopGroup} instance to schedule tasks. This should typically be used as
 * a computation scheduler or any other scheduler that do not schedule blocking tasks. <p>
 */
@Beta
public class RxJavaEventloopScheduler extends Scheduler {

    private final EventLoopGroup eventLoopGroup;

    public RxJavaEventloopScheduler(EventLoopGroup eventLoopGroup) {
        this.eventLoopGroup = eventLoopGroup;
    }

    @Override
    public Worker createWorker() {
        final EventLoop eventLoop = eventLoopGroup.next();

        return new Worker() {

            private final SubscriptionList subs = new SubscriptionList();

            @Override
            public Subscription schedule(final Action0 action) {
                if (isUnsubscribed()) {
                    return Subscriptions.unsubscribed();
                }

                /*If already on the eventloop then execute the action, else schedule it on the eventloop*/
                if (eventLoop.inEventLoop()) {
                    action.call();
                    return Subscriptions.empty();
                } else {
                    final Future<?> result = eventLoop.submit(new Runnable() {
                        @Override
                        public void run() {
                            action.call();
                        }
                    });

                    Subscription toReturn = fromFuture(result);
                    subs.add(toReturn);
                    return toReturn;
                }
            }

            @Override
            public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {

                if (delayTime <= 0) {
                    return schedule(action);
                }

                if (isUnsubscribed()) {
                    return Subscriptions.unsubscribed();
                }

                final Future<?> result = eventLoop.schedule(new Runnable() {
                    @Override
                    public void run() {
                        action.call();
                    }
                }, delayTime, unit);

                Subscription toReturn = fromFuture(result);
                subs.add(toReturn);
                return toReturn;
            }

            @Override
            public void unsubscribe() {
                subs.unsubscribe();
            }

            @Override
            public boolean isUnsubscribed() {
                return subs.isUnsubscribed();
            }

            private Subscription fromFuture(final Future<?> result) {
                return Subscriptions.create(new Action0() {
                    @Override
                    public void call() {
                        result.cancel(false);
                    }
                });
            }
        };
    }



/home/paper219/Desktop/analysis/demonstration//projects/RxNetty/revisions/rev_be2a71b_752d772/rev_be2a71b-752d772.revisions;/rxnetty-common/src/main/java/io/reactivex/netty/threads/RxJavaEventloopScheduler.java;@Override    public Worker createWorker() ;@Override    public Worker createWorker() ;
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package io.reactivex.netty.threads;

import io.netty.channel.EventLoop;
import io.netty.channel.EventLoopGroup;
import io.netty.util.concurrent.Future;
import rx.Scheduler;
import rx.Subscription;
import rx.annotations.Beta;
import rx.functions.Action0;
import rx.internal.schedulers.EventLoopsScheduler;
import rx.internal.schedulers.ScheduledAction;
import rx.internal.util.SubscriptionList;
import rx.subscriptions.CompositeSubscription;
import rx.subscriptions.Subscriptions;

import java.util.concurrent.TimeUnit;

/**
 * A scheduler that uses a provided {@link EventLoopGroup} instance to schedule tasks. This should typically be used as
 * a computation scheduler or any other scheduler that do not schedule blocking tasks. <p>
 */
@Beta
public class RxJavaEventloopScheduler extends Scheduler {

    private final EventLoopGroup eventLoopGroup;

    public RxJavaEventloopScheduler(EventLoopGroup eventLoopGroup) {
        this.eventLoopGroup = eventLoopGroup;
    }

    @Override
    public Worker createWorker() {
        final EventLoop eventLoop = eventLoopGroup.next();
        return new EventloopWorker(eventLoop);
    }

    /**
     * This code is more or less copied from RxJava's {@link EventLoopsScheduler} worker code.
     **/
    /*Visible for testing*/static class EventloopWorker extends Worker {

        /**
         * Why are there two subscription holders?
         *
         * The serial subscriptions are used for non-delayed schedules which are always executed (and hence removed)
         * in order. Since SubscriptionList holds the subs as a linked list, removals are optimal for serial removes.
         * OTOH, delayed schedules are executed (and hence removed) out of order and hence a CompositeSubscription,
         * that stores the subs in a hash structure is more optimal for removals.
         */
        private final SubscriptionList serial;
        private final CompositeSubscription timed;
        private final SubscriptionList both;
        private final EventLoop eventLoop;

        public EventloopWorker(EventLoop eventLoop) {
            this.eventLoop = eventLoop;
            serial = new SubscriptionList();
            timed = new CompositeSubscription();
            both = new SubscriptionList(serial, timed);
        }

        @Override
        public Subscription schedule(final Action0 action) {
            return schedule(action, 0, TimeUnit.DAYS);
        }

        @Override
        public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {

            if (isUnsubscribed()) {
                return Subscriptions.unsubscribed();
            }

            final ScheduledAction sa;

            if (delayTime <= 0) {
                sa = new ScheduledAction(action, serial);
                serial.add(sa);
            } else {
                sa = new ScheduledAction(action, timed);
                timed.add(sa);
            }

            final Future<?> result = eventLoop.schedule(sa, delayTime, unit);
            Subscription cancelFuture = Subscriptions.create(new Action0() {
                @Override
                public void call() {
                    result.cancel(false);
                }
            });
            sa.add(cancelFuture); /*An unsubscribe of the returned sub should cancel the future*/
            return sa;
        }

        @Override
        public void unsubscribe() {
            both.unsubscribe();
        }

        @Override
        public boolean isUnsubscribed() {
            return both.isUnsubscribed();
        }

        /*Visible for testing*/boolean hasScheduledSubscriptions() {
            return serial.hasSubscriptions();
        }

        /*Visible for testing*/boolean hasDelayScheduledSubscriptions() {
            return timed.hasSubscriptions();
        }
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package io.reactivex.netty.threads;

import io.netty.channel.EventLoop;
import io.netty.channel.EventLoopGroup;
import io.netty.util.concurrent.Future;
import rx.Scheduler;
import rx.Subscription;
import rx.annotations.Beta;
import rx.functions.Action0;
import rx.internal.util.SubscriptionList;
import rx.subscriptions.Subscriptions;

import java.util.concurrent.TimeUnit;

/**
 * A scheduler that uses a provided {@link EventLoopGroup} instance to schedule tasks. This should typically be used as
 * a computation scheduler or any other scheduler that do not schedule blocking tasks. <p>
 */
@Beta
public class RxJavaEventloopScheduler extends Scheduler {

    private final EventLoopGroup eventLoopGroup;

    public RxJavaEventloopScheduler(EventLoopGroup eventLoopGroup) {
        this.eventLoopGroup = eventLoopGroup;
    }

    @Override
    public Worker createWorker() {
        final EventLoop eventLoop = eventLoopGroup.next();

        return new Worker() {

            private final SubscriptionList subs = new SubscriptionList();

            @Override
            public Subscription schedule(final Action0 action) {
                if (isUnsubscribed()) {
                    return Subscriptions.unsubscribed();
                }

                /*If already on the eventloop then execute the action, else schedule it on the eventloop*/
                if (eventLoop.inEventLoop()) {
                    action.call();
                    return Subscriptions.empty();
                } else {
                    final Future<?> result = eventLoop.submit(new Runnable() {
                        @Override
                        public void run() {
                            action.call();
                        }
                    });

                    Subscription toReturn = fromFuture(result);
                    subs.add(toReturn);
                    return toReturn;
                }
            }

            @Override
            public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {

                if (delayTime <= 0) {
                    return schedule(action);
                }

                if (isUnsubscribed()) {
                    return Subscriptions.unsubscribed();
                }

                final Future<?> result = eventLoop.schedule(new Runnable() {
                    @Override
                    public void run() {
                        action.call();
                    }
                }, delayTime, unit);

                Subscription toReturn = fromFuture(result);
                subs.add(toReturn);
                return toReturn;
            }

            @Override
            public void unsubscribe() {
                subs.unsubscribe();
            }

            @Override
            public boolean isUnsubscribed() {
                return subs.isUnsubscribed();
            }

            private Subscription fromFuture(final Future<?> result) {
                return Subscriptions.create(new Action0() {
                    @Override
                    public void call() {
                        result.cancel(false);
                    }
                });
            }
        };
    }



/home/paper219/Desktop/analysis/demonstration//projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e.revisions;/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java;private void writeInjectAdapterConstructor(JavaWriter writer, ExecutableElement constructor,      TypeElement type, String strippedTypeName, String adapterName) throws IOException ;private void writeInjectAdapterConstructor(JavaWriter writer, ExecutableElement constructor,      TypeElement type, String strippedTypeName, String adapterName) throws IOException ;
  private void writeInjectAdapterConstructor(JavaWriter writer, ExecutableElement constructor,
      TypeElement type, String strippedTypeName, String adapterName) throws IOException {
    writer.beginMethod(null, adapterName, EnumSet.of(PUBLIC));
    String key = (constructor != null)
        ? JavaWriter.stringLiteral(GeneratorKeys.get(type.asType()))
        : null;
    String membersKey = JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(type.asType()));
    boolean singleton = type.getAnnotation(Singleton.class) != null;
    writer.emitStatement("super(%s, %s, %s, %s.class)",
        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), strippedTypeName);
    writer.endMethod();
=======
  private void writeParameterBindingsFields(
      JavaWriter writer, ExecutableElement constructor, boolean disambiguateFields)
      throws IOException {
    for (VariableElement parameter : constructor.getParameters()) {
      writer.emitField(JavaWriter.type(Binding.class,
          typeToString(parameter.asType())),
          parameterName(disambiguateFields, parameter), EnumSet.of(PRIVATE));
    }
  }

  private void writeSupertypeInjectorField(JavaWriter writer, TypeMirror supertype)
      throws IOException {
    writer.emitField(JavaWriter.type(Binding.class, rawTypeToString(supertype, '.')), "supertype",
        EnumSet.of(PRIVATE));
  }

  private void writeInjectAdapterConstructor(JavaWriter writer, ExecutableElement constructor,
      TypeElement type, String strippedTypeName, String adapterName) throws IOException {
    writer.beginMethod(null, adapterName, EnumSet.of(PUBLIC));
    String key = (constructor != null)
        ? JavaWriter.stringLiteral(GeneratorKeys.get(type.asType()))
        : null;
    String membersKey = JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(type.asType()));
    boolean singleton = type.getAnnotation(Singleton.class) != null;
    writer.emitStatement("super(%s, %s, %s, %s.class)",
        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), strippedTypeName);
    writer.endMethod();


/home/paper219/Desktop/analysis/demonstration//projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e.revisions;/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java;private void writeAttachMethod(JavaWriter writer, ExecutableElement constructor,      List<Element> fields, boolean disambiguateFields, String typeName, TypeMirror supertype,      boolean extendsBinding) throws IOException ;private void writeAttachMethod(JavaWriter writer, ExecutableElement constructor,      List<Element> fields, boolean disambiguateFields, String typeName, TypeMirror supertype,      boolean extendsBinding) throws IOException ;
  }

  /**
   * Writes the {@code attach()} method for the generated adapters. The {@code supertype} provided
   * is the next injectable ancestor.
   */
  private void writeAttachMethod(JavaWriter writer, ExecutableElement constructor,
      List<Element> fields, boolean disambiguateFields, String typeName, TypeMirror supertype,
      boolean extendsBinding) throws IOException {
=======
  }

  private void writeAttachMethod(JavaWriter writer, ExecutableElement constructor,
      List<Element> fields, boolean disambiguateFields, String typeName, TypeMirror supertype,
      boolean extendsBinding) throws IOException {


/home/paper219/Desktop/analysis/demonstration//projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e.revisions;/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java;private void writeGetDependenciesMethod(JavaWriter writer, ExecutableElement constructor,      List<Element> fields, boolean disambiguateFields, TypeMirror supertype,      boolean extendsBinding) throws IOException ;private void writeGetDependenciesMethod(JavaWriter writer, ExecutableElement constructor,      List<Element> fields, boolean disambiguateFields, TypeMirror supertype,      boolean extendsBinding) throws IOException ;
          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)), typeName);
    }
    writer.endMethod();
    writer.emitEmptyLine();
  }

  /**
   * Writes the {@code getDependencies()} method for the generated adapters. The {@code supertype}
   * provided is the next injectable ancestor.
   */
  private void writeGetDependenciesMethod(JavaWriter writer, ExecutableElement constructor,
      List<Element> fields, boolean disambiguateFields, TypeMirror supertype,
      boolean extendsBinding) throws IOException {
    writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
    if (extendsBinding) {
      writer.emitAnnotation(Override.class);
    }
    String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
    writer.beginMethod("void", "getDependencies", EnumSet.of(PUBLIC), setOfBindings, "getBindings",
        setOfBindings, "injectMembersBindings");
    if (constructor != null) {
      for (Element parameter : constructor.getParameters()) {
        writer.emitStatement("getBindings.add(%s)", parameterName(disambiguateFields, parameter));
      }
    }
    for (Element field : fields) {
      writer.emitStatement("injectMembersBindings.add(%s)", fieldName(disambiguateFields, field));
    }
    if (supertype != null) {
      writer.emitStatement("nextInjectableAncestor.getDependencies(null, injectMembersBindings)");
=======
          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)), typeName);
    }
    if (supertype != null) {
      writer.emitStatement(
          "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader()"
              + ", false, true)",
          "supertype",
          writer.compressType(JavaWriter.type(Binding.class, rawTypeToString(supertype, '.'))),
          JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)), typeName);
    }
    writer.endMethod();
    writer.emitEmptyLine();
  }

  private void writeGetDependenciesMethod(JavaWriter writer, ExecutableElement constructor,
      List<Element> fields, boolean disambiguateFields, TypeMirror supertype,
      boolean extendsBinding) throws IOException {
    writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
    if (extendsBinding) {
      writer.emitAnnotation(Override.class);
    }
    String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
    writer.beginMethod("void", "getDependencies", EnumSet.of(PUBLIC), setOfBindings, "getBindings",
        setOfBindings, "injectMembersBindings");
    if (constructor != null) {
      for (Element parameter : constructor.getParameters()) {
        writer.emitStatement("getBindings.add(%s)", parameterName(disambiguateFields, parameter));
      }
    }
    for (Element field : fields) {
      writer.emitStatement("injectMembersBindings.add(%s)", fieldName(disambiguateFields, field));
    }
    if (supertype != null) {
      writer.emitStatement("injectMembersBindings.add(%s)", "supertype");
    }
    writer.endMethod();
    writer.emitEmptyLine();
  }

  private void writeGetMethod(JavaWriter writer, ExecutableElement constructor,
      boolean disambiguateFields, boolean injectMembers, String strippedTypeName)
      throws IOException {
    writer.emitJavadoc(AdapterJavadocs.GET_METHOD, strippedTypeName);
    writer.emitAnnotation(Override.class);
    writer.beginMethod(strippedTypeName, "get", EnumSet.of(PUBLIC));
    StringBuilder newInstance = new StringBuilder();
    newInstance.append(strippedTypeName).append(" result = new ");
    newInstance.append(strippedTypeName).append('(');
    boolean first = true;
    for (VariableElement parameter : constructor.getParameters()) {
      if (!first) newInstance.append(", ");
      else first = false;
      newInstance.append(parameterName(disambiguateFields, parameter)).append(".get()");
    }
    newInstance.append(')');
    writer.emitStatement(newInstance.toString());
    if (injectMembers) {
      writer.emitStatement("injectMembers(result)");


/home/paper219/Desktop/analysis/demonstration//projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e.revisions;/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java;private void writeMembersInjectMethod(JavaWriter writer, List<Element> fields,      boolean disambiguateFields, String strippedTypeName, TypeMirror supertype)      throws IOException ;private void writeMembersInjectMethod(JavaWriter writer, List<Element> fields,      boolean disambiguateFields, String strippedTypeName, TypeMirror supertype)      throws IOException ;
  private void writeGetMethod(JavaWriter writer, ExecutableElement constructor,
      boolean disambiguateFields, boolean injectMembers, String strippedTypeName)
      throws IOException {
    writer.emitJavadoc(AdapterJavadocs.GET_METHOD, strippedTypeName);
    writer.emitAnnotation(Override.class);
    writer.beginMethod(strippedTypeName, "get", EnumSet.of(PUBLIC));
    StringBuilder newInstance = new StringBuilder();
    newInstance.append(strippedTypeName).append(" result = new ");
    newInstance.append(strippedTypeName).append('(');
    boolean first = true;
    for (VariableElement parameter : constructor.getParameters()) {
      if (!first) newInstance.append(", ");
      else first = false;
      newInstance.append(parameterName(disambiguateFields, parameter)).append(".get()");
    }
    newInstance.append(')');
    writer.emitStatement(newInstance.toString());
    if (injectMembers) {
      writer.emitStatement("injectMembers(result)");
    }
    writer.emitStatement("return result");
    writer.endMethod();
    writer.emitEmptyLine();
  }

  /**
   * Writes the {@code injectMembers()} method for the generated adapters. The {@code supertype}
   * provided is the next injectable ancestor.
   */
  private void writeMembersInjectMethod(JavaWriter writer, List<Element> fields,
      boolean disambiguateFields, String strippedTypeName, TypeMirror supertype)
      throws IOException {
    writer.emitJavadoc(AdapterJavadocs.MEMBERS_INJECT_METHOD, strippedTypeName);
    writer.emitAnnotation(Override.class);
    writer.beginMethod("void", "injectMembers", EnumSet.of(PUBLIC), strippedTypeName, "object");
    for (Element field : fields) {
      writer.emitStatement("object.%s = %s.get()",
          field.getSimpleName(),
          fieldName(disambiguateFields, field));
    }
    if (supertype != null) {
      writer.emitStatement("nextInjectableAncestor.injectMembers(object)");
    }
    writer.endMethod();
    writer.emitEmptyLine();
  }

  private void writeStaticInjectMethod(JavaWriter writer, List<Element> fields, String typeName)
      throws IOException {
=======
  private void writeMembersInjectMethod(JavaWriter writer, List<Element> fields,
      boolean disambiguateFields, String strippedTypeName, TypeMirror supertype)
      throws IOException {
    writer.emitJavadoc(AdapterJavadocs.MEMBERS_INJECT_METHOD, strippedTypeName);
    writer.emitAnnotation(Override.class);
    writer.beginMethod("void", "injectMembers", EnumSet.of(PUBLIC), strippedTypeName, "object");
    for (Element field : fields) {
      writer.emitStatement("object.%s = %s.get()",
          field.getSimpleName(),
          fieldName(disambiguateFields, field));
    }
    if (supertype != null) {
      writer.emitStatement("supertype.injectMembers(object)");
    }
    writer.endMethod();
    writer.emitEmptyLine();
  }

  private void writeStaticInjectMethod(JavaWriter writer, List<Element> fields, String typeName)
      throws IOException {


/home/paper219/Desktop/analysis/demonstration//projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e.revisions;/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java;private void writeStaticInjectMethod(JavaWriter writer, List<Element> fields, String typeName)      throws IOException ;private void writeStaticInjectMethod(JavaWriter writer, List<Element> fields, String typeName)      throws IOException ;
  private void writeGetMethod(JavaWriter writer, ExecutableElement constructor,
      boolean disambiguateFields, boolean injectMembers, String strippedTypeName)
      throws IOException {
    writer.emitJavadoc(AdapterJavadocs.GET_METHOD, strippedTypeName);
    writer.emitAnnotation(Override.class);
    writer.beginMethod(strippedTypeName, "get", EnumSet.of(PUBLIC));
    StringBuilder newInstance = new StringBuilder();
    newInstance.append(strippedTypeName).append(" result = new ");
    newInstance.append(strippedTypeName).append('(');
    boolean first = true;
    for (VariableElement parameter : constructor.getParameters()) {
      if (!first) newInstance.append(", ");
      else first = false;
      newInstance.append(parameterName(disambiguateFields, parameter)).append(".get()");
    }
    newInstance.append(')');
    writer.emitStatement(newInstance.toString());
    if (injectMembers) {
      writer.emitStatement("injectMembers(result)");
    }
    writer.emitStatement("return result");
    writer.endMethod();
    writer.emitEmptyLine();
  }

  /**
   * Writes the {@code injectMembers()} method for the generated adapters. The {@code supertype}
   * provided is the next injectable ancestor.
   */
  private void writeMembersInjectMethod(JavaWriter writer, List<Element> fields,
      boolean disambiguateFields, String strippedTypeName, TypeMirror supertype)
      throws IOException {
    writer.emitJavadoc(AdapterJavadocs.MEMBERS_INJECT_METHOD, strippedTypeName);
    writer.emitAnnotation(Override.class);
    writer.beginMethod("void", "injectMembers", EnumSet.of(PUBLIC), strippedTypeName, "object");
    for (Element field : fields) {
      writer.emitStatement("object.%s = %s.get()",
          field.getSimpleName(),
          fieldName(disambiguateFields, field));
    }
    if (supertype != null) {
      writer.emitStatement("nextInjectableAncestor.injectMembers(object)");
    }
    writer.endMethod();
    writer.emitEmptyLine();
  }

  private void writeStaticInjectMethod(JavaWriter writer, List<Element> fields, String typeName)
      throws IOException {
=======
  private void writeMembersInjectMethod(JavaWriter writer, List<Element> fields,
      boolean disambiguateFields, String strippedTypeName, TypeMirror supertype)
      throws IOException {
    writer.emitJavadoc(AdapterJavadocs.MEMBERS_INJECT_METHOD, strippedTypeName);
    writer.emitAnnotation(Override.class);
    writer.beginMethod("void", "injectMembers", EnumSet.of(PUBLIC), strippedTypeName, "object");
    for (Element field : fields) {
      writer.emitStatement("object.%s = %s.get()",
          field.getSimpleName(),
          fieldName(disambiguateFields, field));
    }
    if (supertype != null) {
      writer.emitStatement("supertype.injectMembers(object)");
    }
    writer.endMethod();
    writer.emitEmptyLine();
  }

  private void writeStaticInjectMethod(JavaWriter writer, List<Element> fields, String typeName)
      throws IOException {


