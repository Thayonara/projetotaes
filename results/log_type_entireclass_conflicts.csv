/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_5369ed1_0b9b59c/rev_5369ed1-0b9b59c/samples/java-jersey2/src/main/java/com/wordnik/swagger/sample/resource/QueryResultBean.java;<<<<<<< MINE
=======
/**
 *  Copyright 2013 Wordnik, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resource;

import javax.ws.rs.*;

public class QueryResultBean {
  @QueryParam("skip")
  private Integer skip;

  @QueryParam("limit")
  private Integer limit;


  public Integer getSkip() {
    return skip;
  }
  public void setSkip(Integer skip) {
    this.skip = skip;
  }

  public Integer getLimit() {
    return limit;
  }
  public void setLimit(Integer limit) {
    this.limit = limit;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_eb281d3_9fc507c/rev_eb281d3-9fc507c/modules/swagger-annotations/src/main/java/com/wordnik/swagger/annotations/ApiResponse.java;<<<<<<< MINE
 * An ApiResponse represents a type of response from a server.  This can be used to
 * describe both success codes as well as errors.
 * If your Api has different response classes, you can describe them here by associating
 * a response class with a response code.  Note, Swagger does not allow multiple response
 * types for a single response code.
=======
 * Describes a possible response of an operation.
 * <p/>
 * This can be used to describe possible success and error codes from your REST API call.
 * You may or may not use this to describe the return type of the operation (normally a
 * successful code), but the successful response should be described as well using the
 * {@link ApiOperation}.
 * <p/>
 * If your API has uses a different response class for these responses, you can describe them
 * here by associating a response class with a response code.
 * Note, Swagger does not allow multiple response types for a single response code.
 * <p/>
 * This annotation is not used directly and will not be parsed by Swagger. It should be used
 * within the {@link ApiResponses}.
 *
 * @see ApiOperation
 * @see ApiResponses
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/modules/swagger-jaxrs/src/main/scala/com/wordnik/swagger/jaxrs/json/JacksonJsonProvider.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.jaxrs.json;

import javax.ws.rs.Produces;

import javax.ws.rs.core.MediaType;
import javax.ws.rs.ext.Provider;

import com.wordnik.swagger.core.util.JsonUtil;
import com.fasterxml.jackson.jaxrs.json.JacksonJaxbJsonProvider;
import com.fasterxml.jackson.databind.*;



import com.fasterxml.jackson.module.scala.DefaultScalaModule;

import com.fasterxml.jackson.core.JsonGenerator.Feature;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;


@Provider
@Produces(MediaType.APPLICATION_JSON)
public class JacksonJsonProvider extends JacksonJaxbJsonProvider {
  private static ObjectMapper commonMapper = null;

  public JacksonJsonProvider() {
    if(commonMapper == null){
        ObjectMapper mapper = new ObjectMapper();

        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        mapper.setSerializationInclusion(JsonInclude.Include.NON_DEFAULT);
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        
        commonMapper = mapper;
    }
    super.setMapper(commonMapper);
  }
  
  
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/modules/swagger-annotations/src/main/java/com/wordnik/swagger/annotations/Api.java;<<<<<<< MINE
 * Marks a class as a Swagger resource.
 * <p>
 * The resource affects both the root document of Swagger, the Resource
 * Listing, and the API Declaration of that specific resource.
 * <p>
 * Swagger will only include and introspect only classes that are annotated
 * with {@code @Api} and will ignore other resources (JAX-RS endpoints, Servlets and
 * so on).
=======
 * Marks a class as a Swagger resource.
 * <p/>
 * The resource affects both the root document of Swagger, the Resource
 * Listing, and the API Declaration of that specific resource.
 * <p/>
 * Swagger will only include and introspect only classes that are annotated
 * with {@code @Api} and will ignore other resources (JAX-RS endpoints, Servlets and
 * so on).
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/resource/SampleExceptionMapper.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resource;

import com.wordnik.swagger.sample.exception.ApiException;
import com.wordnik.swagger.sample.exception.BadRequestException;
import com.wordnik.swagger.sample.exception.NotFoundException;
import com.wordnik.swagger.sample.model.ApiResponse;

import javax.ws.rs.ext.*;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

@Provider
public class SampleExceptionMapper implements ExceptionMapper<Exception> {
  public Response toResponse(Exception exception) {
    if (exception instanceof javax.ws.rs.WebApplicationException) {
      javax.ws.rs.WebApplicationException e = (javax.ws.rs.WebApplicationException) exception;
      return Response
          .status(e.getResponse().getStatus())
          .entity(new ApiResponse(e.getResponse().getStatus(),
              exception.getMessage())).build();
    } else if (exception instanceof com.fasterxml.jackson.core.JsonParseException) {
      return Response.status(400)
          .entity(new ApiResponse(400, "bad input")).build();
    } else if (exception instanceof NotFoundException) {
      return Response
          .status(Status.NOT_FOUND)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof BadRequestException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof ApiException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else {
      return Response.status(500)
          .entity(new ApiResponse(500, "something bad happened"))
          .build();
    }
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/resource/JavaRestResourceUtil.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resource;

import java.text.SimpleDateFormat;

import java.util.Date;

public class JavaRestResourceUtil {
  public int getInt(int minVal, int maxVal, int defaultValue, String inputString) {
    int output = defaultValue;
    try {
      output = Integer.parseInt(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) {
      if (output < minVal) output = minVal;
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public long getLong(long minVal, long maxVal, long defaultValue, String inputString) {
    long output = defaultValue;
    try {
      output = Long.parseLong(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { if (output < minVal) output = minVal; }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public double getDouble(double minVal, double maxVal, double defaultValue, String inputString) {
    double output = defaultValue;
    try {
      output = Double.parseDouble(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { 
      if (output < minVal) output = minVal; 
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public boolean getBoolean(boolean defaultValue, String booleanString) {
    boolean output = defaultValue;
    if (booleanString == null) output = defaultValue;

    //  treat "", "YES" as "true"
    if ("".equals(booleanString)) output = true;
    else if ("YES".equalsIgnoreCase(booleanString)) output = true;
    else if ("NO".equalsIgnoreCase(booleanString)) output = false;
    else {
      try {
        output = Boolean.parseBoolean(booleanString);
      }
      catch (Exception e){
        output = defaultValue;
      }
    }
    return output;
  }
  
  public Date getDate(Date defaultValue, String dateString){
    try {
      return new SimpleDateFormat("yyyy-MM-dd").parse(dateString);
    }
    catch(Exception e) {
      return defaultValue;
    }
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/exception/ApiException.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class ApiException extends Exception{
  private int code;
  public ApiException (int code, String msg) {
    super(msg);
    this.code = code;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/exception/NotFoundException.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class NotFoundException extends ApiException {
  private int code;
  public NotFoundException (int code, String msg) {
    super(code, msg);
    this.code = code;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/exception/BadRequestException.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class BadRequestException extends ApiException{
  private int code;
  public BadRequestException (int code, String msg) {
    super(code, msg);
    this.code = code;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/SwaggerExampleGuiceContextListener.java;<<<<<<< MINE
=======
package com.wordnik.swagger.sample;

import com.google.inject.Guice;
import com.google.inject.Injector;
import com.google.inject.Singleton;
import com.google.inject.servlet.GuiceServletContextListener;
import com.google.inject.servlet.ServletModule;
import com.wordnik.swagger.config.ConfigFactory;
import com.wordnik.swagger.config.FilterFactory;
import com.wordnik.swagger.config.ScannerFactory;
import com.wordnik.swagger.config.SwaggerConfig;
import com.wordnik.swagger.jaxrs.config.DefaultJaxrsScanner;
import com.wordnik.swagger.jaxrs.config.ReflectiveJaxrsScanner;
import com.wordnik.swagger.jaxrs.reader.DefaultJaxrsApiReader;
import com.wordnik.swagger.model.*;
import com.wordnik.swagger.reader.ClassReaders;
import com.wordnik.swagger.sample.util.ApiAuthorizationFilterImpl;
import com.wordnik.swagger.sample.util.ApiOriginFilter;
import com.wordnik.swagger.sample.util.CustomFilter;
import org.glassfish.jersey.servlet.ServletContainer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SwaggerExampleGuiceContextListener extends GuiceServletContextListener {

    @Override
    protected Injector getInjector() {
        return Guice.createInjector(new ServletModule() {
            @Override
            protected void configureServlets() {
                bind(ServletContainer.class).in(Singleton.class);
                bind(ApiOriginFilter.class).in(Singleton.class);

                Map<String, String> props = new HashMap<String, String>();
                props.put("javax.ws.rs.Application", Application.class.getName());
                props.put("jersey.config.server.wadl.disableWadl", "true");
                serve("/api/*").with(ServletContainer.class, props);

                ReflectiveJaxrsScanner scanner = new ReflectiveJaxrsScanner();
                scanner.setResourcePackage(getClass().getPackage().getName());
                ScannerFactory.setScanner(scanner);
                SwaggerConfig config = ConfigFactory.config();
                config.setApiVersion("1.0.0");

                String basePath = "http://localhost:8002/api";
                if (System.getProperties().contains("swagger.basePath")) {
                    basePath = System.getProperty("swagger.basePath");
                }
                config.setBasePath(basePath);
                ConfigFactory.setConfig(config);

                FilterFactory.setFilter(new ApiAuthorizationFilterImpl());
                ScannerFactory.setScanner(new DefaultJaxrsScanner());
                ClassReaders.setReader(new DefaultJaxrsApiReader());

                bootstrap();

                filter("/*").through(ApiOriginFilter.class);
            }
        });
    }

    private void bootstrap() {
        FilterFactory.setFilter(new CustomFilter());

        ApiInfo info = new ApiInfo(
                "Swagger Sample App",                             /* title */
                "This is a sample server Petstore server.  You can find out more about Swagger " +
                        "at <a href=\"http://swagger.io\">http://swagger.io</a> or on irc.freenode.net, #swagger.  For this sample, " +
                        "you can use the api key \"special-key\" to test the authorization filters",
                "http://helloreverb.com/terms/",                  /* TOS URL */
                "apiteam@wordnik.com",                            /* Contact */
                "Apache 2.0",                                     /* license */
                "http://www.apache.org/licenses/LICENSE-2.0.html" /* license URL */
        );

        List<AuthorizationScope> scopes = new ArrayList<AuthorizationScope>();
        scopes.add(new AuthorizationScope("email", "Access to your email address"));
        scopes.add(new AuthorizationScope("pets", "Access to your pets"));


        List<GrantType> grantTypes = new ArrayList<GrantType>();

        ImplicitGrant implicitGrant = new ImplicitGrant(
                new LoginEndpoint("http://localhost:8002/oauth/dialog"),
                "access_code");

        grantTypes.add(implicitGrant);

        AuthorizationType oauth = new OAuthBuilder().scopes(scopes).grantTypes(grantTypes).build();

        //  ConfigFactory.config().addAuthorization(oauth);
        ConfigFactory.config().setApiInfo(info);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/model/ApiResponse.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.XmlTransient;

@javax.xml.bind.annotation.XmlRootElement
public class ApiResponse {
  public static final int ERROR = 1;
  public static final int WARNING = 2;
  public static final int INFO = 3;
  public static final int OK = 4;
  public static final int TOO_BUSY = 5;

  int code;
  String type;
  String message;
  
  public ApiResponse(){}
  
  public ApiResponse(int code, String message){
    this.code = code;
    switch(code){
    case ERROR:
      setType("error");
      break;
    case WARNING:
      setType("warning");
      break;
    case INFO:
      setType("info");
      break;
    case OK:
      setType("ok");
      break;
    case TOO_BUSY:
      setType("too busy");
      break;
    default:
      setType("unknown");
      break;
    }
    this.message = message;
  }

  @XmlTransient
  public int getCode() {
    return code;
  }

  public void setCode(int code) {
    this.code = code;
  }

  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/model/Pet.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import java.util.List;
import java.util.ArrayList;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Pet")
public class Pet {
  private long id;
  private Category category;
  private String name;
  private List<String> photoUrls = new ArrayList<String>();
  private List<Tag> tags = new ArrayList<Tag>();
  private String status;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "category")
  public Category getCategory() {
    return category;
  }

  public void setCategory(Category category) {
    this.category = category;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  @XmlElementWrapper(name = "photoUrls")
  @XmlElement(name = "photoUrl")
  public List<String> getPhotoUrls() {
    return photoUrls;
  }

  public void setPhotoUrls(List<String> photoUrls) {
    this.photoUrls = photoUrls;
  }

  @XmlElementWrapper(name = "tags")
  @XmlElement(name = "tag")
  public List<Tag> getTags() {
    return tags;
  }

  public void setTags(List<Tag> tags) {
    this.tags = tags;
  }

  @XmlElement(name = "status")
  @ApiModelProperty(value = "pet status in the store", allowableValues = "available,pending,sold")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/model/Order.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import java.util.Date;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Order")
public class Order {
  private long id;
  private long petId;
  private int quantity;
  private Date shipDate;
  private String status;
    private boolean complete;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

    public boolean isComplete() {
        return complete;
    }

    public void setComplete(boolean complete) {
        this.complete = complete;
    }


  @XmlElement(name = "petId")
  public long getPetId() {
    return petId;
  }

  public void setPetId(long petId) {
    this.petId = petId;
  }

  @XmlElement(name = "quantity")
  public int getQuantity() {
    return quantity;
  }

  public void setQuantity(int quantity) {
    this.quantity = quantity;
  }

  @XmlElement(name = "status")
  @ApiModelProperty(value = "Order Status", allowableValues = "placed, approved, delivered")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }

  @XmlElement(name = "shipDate")
  public Date getShipDate() {
    return shipDate;
  }

  public void setShipDate(Date shipDate) {
    this.shipDate = shipDate;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/model/User.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "User")
public class User {
  private long id;
  private String username;
  private String firstName;
  private String lastName;
  private String email;
  private String password;
  private String phone;
  private int userStatus;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "firstName")
  public String getFirstName() {
    return firstName;
  }

  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }

  @XmlElement(name = "username")
  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  @XmlElement(name = "lastName")
  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }

  @XmlElement(name = "email")
  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  @XmlElement(name = "password")
  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  @XmlElement(name = "phone")
  public String getPhone() {
    return phone;
  }

  public void setPhone(String phone) {
    this.phone = phone;
  }

  @XmlElement(name = "userStatus")
  @ApiModelProperty(value = "User Status", allowableValues = "1-registered,2-active,3-closed")
  public int getUserStatus() {
    return userStatus;
  }

  public void setUserStatus(int userStatus) {
    this.userStatus = userStatus;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/model/Tag.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Tag")
public class Tag {
  private long id;
  private String name;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/model/Category.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Category")
public class Category {
  private long id;
  private String name;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/util/ApiAuthorizationFilterImpl.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import com.wordnik.swagger.model.*;
import com.wordnik.swagger.core.filter.SwaggerSpecFilter;

import org.slf4j.*;

import java.util.Map;
import java.util.List;

import javax.servlet.ServletConfig;
import javax.servlet.http.HttpServlet;
/**
 * 
 * The rules are maintained in simple map with key as path and a boolean value
 * indicating given path is secure or not. For method level security the key is
 * combination of http method and path .
 * 
 * If the resource or method is secure then it can only be viewed using a
 * secured api key
 * 
 * Note: Objective of this class is not to provide fully functional
 * implementation of authorization filter. This is only a sample demonstration
 * how API authorization filter works.
 * 
 */

public class ApiAuthorizationFilterImpl implements SwaggerSpecFilter {
  static Logger logger = LoggerFactory.getLogger(ApiAuthorizationFilterImpl.class);

  public boolean isOperationAllowed(Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if(isAuthorized) {
      return true;
    }
    else {
      if(operation.method() != "GET" || api.path().indexOf("/store") != -1) {
        return false;
      }
      else return true;
    }
  }

  public boolean isParamAllowed(Parameter parameter, Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if((parameter.paramAccess().isDefined() && parameter.paramAccess().get().equals("internal")) && !isAuthorized) 
      return false;
    else 
      return true;
  }

  public boolean checkKey(Map<String, List<String>> params, Map<String, List<String>> headers) {
    String keyValue = null;
    if(params.containsKey("api_key"))
      keyValue = params.get("api_key").get(0);
    else {
      if(headers.containsKey("api_key"))
        keyValue = headers.get("api_key").get(0);
    }
    if("special-key".equals(keyValue))
      return true;
    else
      return false;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/util/ApiOriginFilter.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import java.io.IOException;

import javax.servlet.*;
import javax.servlet.http.HttpServletResponse;

public class ApiOriginFilter implements javax.servlet.Filter {
  @Override
  public void doFilter(ServletRequest request, ServletResponse response,
      FilterChain chain) throws IOException, ServletException {
    HttpServletResponse res = (HttpServletResponse) response;
    res.addHeader("Access-Control-Allow-Origin", "*");
    res.addHeader("Access-Control-Allow-Methods", "GET, POST, DELETE, PUT");
    res.addHeader("Access-Control-Allow-Headers", "Content-Type");
    chain.doFilter(request, response);
  }

  @Override
  public void destroy() {
  }

  @Override
  public void init(FilterConfig filterConfig) throws ServletException {
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/util/CustomFilter.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import com.wordnik.swagger.core.filter.SwaggerSpecFilter;
import com.wordnik.swagger.model.*;

public class CustomFilter implements SwaggerSpecFilter {
  @Override
  public boolean isOperationAllowed(
    Operation operation,
    ApiDescription api, 
    java.util.Map<String, java.util.List<String>> params, 
    java.util.Map<String, String> cookies, 
    java.util.Map<String, java.util.List<String>> headers) {
    return true;
  }

  @Override
  public boolean isParamAllowed(
    Parameter parameter, 
    Operation operation, 
    ApiDescription api,
    java.util.Map<String, java.util.List<String>> params, 
    java.util.Map<String, String> cookies,
    java.util.Map<String, java.util.List<String>>  headers) {
    return true;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/data/PetData.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;

import java.util.List;
import java.util.ArrayList;

public class PetData {
  static List<Pet> pets = new ArrayList<Pet>();
  static List<Category> categories = new ArrayList<Category>();

  static {
    categories.add(createCategory(1, "Dogs"));
    categories.add(createCategory(2, "Cats"));
    categories.add(createCategory(3, "Rabbits"));
    categories.add(createCategory(4, "Lions"));

    pets.add(createPet(1, categories.get(1), "Cat 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(2, categories.get(1), "Cat 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
    pets.add(createPet(3, categories.get(1), "Cat 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

    pets.add(createPet(4, categories.get(0), "Dog 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(5, categories.get(0), "Dog 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "sold"));
    pets.add(createPet(6, categories.get(0), "Dog 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

    pets.add(createPet(7, categories.get(3), "Lion 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(8, categories.get(3), "Lion 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
    pets.add(createPet(9, categories.get(3), "Lion 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));

    pets.add(createPet(10, categories.get(2), "Rabbit 1", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));
  }

  public Pet getPetbyId(long petId) {
    for (Pet pet : pets) {
      if (pet.getId() == petId) {
        return pet;
      }
    }
    return null;
  }

  public List<Pet> findPetByStatus(String status) {
    String[] statues = status.split(",");
    List<Pet> result = new java.util.ArrayList<Pet>();
    for (Pet pet : pets) {
      for (String s : statues) {
        if (s.equals(pet.getStatus())) {
          result.add(pet);
        }
      }
    }
    return result;
  }

  public List<Pet> findPetByTags(String tags) {
    String[] tagList = tags.split(",");
    List<Pet> result = new java.util.ArrayList<Pet>();
    for (Pet pet : pets) {
      if (null != pet.getTags()) {
        for (Tag tag : pet.getTags()) {
          for (String tagListString : tagList) {
            if (tagListString.equals(tag.getName()))
              result.add(pet);
          }
        }
      }
    }
    return result;
  }

  public void addPet(Pet pet) {
    if (pets.size() > 0) {
      for (int i = pets.size() - 1; i >= 0; i--) {
        if (pets.get(i).getId() == pet.getId()) {
          pets.remove(i);
        }
      }
    }
    pets.add(pet);
  }

  static Pet createPet(long id, Category cat, String name, String[] urls,
      String[] tags, String status) {
    Pet pet = new Pet();
    pet.setId(id);
    pet.setCategory(cat);
    pet.setName(name);
    if (null != urls) {
      List<String> urlObjs = new ArrayList<String>();
      for (String urlString : urls) {
        urlObjs.add(urlString);
      }
      pet.setPhotoUrls(urlObjs);
    }
    List<Tag> tagObjs = new java.util.ArrayList<Tag>();
    int i = 0;
    if (null != tags) {
      for (String tagString : tags) {
        i = i + 1;
        Tag tag = new Tag();
        tag.setId(i);
        tag.setName(tagString);
        tagObjs.add(tag);
      }
    }
    pet.setTags(tagObjs);
    pet.setStatus(status);
    return pet;
  }

  static Category createCategory(long id, String name) {
    Category category = new Category();
    category.setId(id);
    category.setName(name);
    return category;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/data/UserData.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;

import java.util.List;
import java.util.ArrayList;

public class UserData {
  static List<User> users = new ArrayList<User>();

  static {
    users.add(createUser(1, "user1", "first name 1", "last name 1",
        "email1@test.com", "123-456-7890", 1));
    users.add(createUser(2, "user2", "first name 2", "last name 2",
        "email2@test.com", "123-456-7890", 2));
    users.add(createUser(3, "user3", "first name 3", "last name 3",
        "email3@test.com", "123-456-7890", 3));
    users.add(createUser(4, "user4", "first name 4", "last name 4",
        "email4@test.com", "123-456-7890", 1));
    users.add(createUser(5, "user5", "first name 5", "last name 5",
        "email5@test.com", "123-456-7890", 2));
    users.add(createUser(6, "user6", "first name 6", "last name 6",
        "email6@test.com", "123-456-7890", 3));
    users.add(createUser(7, "user7", "first name 7", "last name 7",
        "email7@test.com", "123-456-7890", 1));
    users.add(createUser(8, "user8", "first name 8", "last name 8",
        "email8@test.com", "123-456-7890", 2));
    users.add(createUser(9, "user9", "first name 9", "last name 9",
        "email9@test.com", "123-456-7890", 3));
    users.add(createUser(10, "user10", "first name 10", "last name 10",
        "email10@test.com", "123-456-7890", 1));
    users.add(createUser(11, "user?10", "first name ?10", "last name ?10",
        "email101@test.com", "123-456-7890", 1));

  }

  public User findUserByName(String username) {
    for (User user : users) {
      if (user.getUsername().equals(username)) {
        return user;
      }
    }
    return null;
  }

  public void addUser(User user) {
    if (users.size() > 0) {
      for (int i = users.size() - 1; i >= 0; i--) {
        if (users.get(i).getUsername().equals(user.getUsername())) {
          users.remove(i);
        }
      }
    }
    users.add(user);
  }

  public void removeUser(String username) {
    if (users.size() > 0) {
      for (int i = users.size() - 1; i >= 0; i--) {
        if (users.get(i).getUsername().equals(username)) {
          users.remove(i);
        }
      }
    }
  }

  private static User createUser(long id, String username, String firstName,
      String lastName, String email, String phone, int userStatus) {
    User user = new User();
    user.setId(id);
    user.setUsername(username);
    user.setFirstName(firstName);
    user.setLastName(lastName);
    user.setEmail(email);
    user.setPassword("XXXXXXXXXXX");
    user.setPhone(phone);
    user.setUserStatus(userStatus);
    return user;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2-guice/src/main/java/com/wordnik/swagger/sample/data/StoreData.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;
import java.util.Date;
import java.util.List;
import java.util.ArrayList;

public class StoreData {
  static List<Order> orders = new ArrayList<Order>();

  static {
    orders.add(createOrder(1, 1, 2, new Date(), "placed"));
    orders.add(createOrder(2, 1, 2, new Date(), "delivered"));
    orders.add(createOrder(3, 2, 2, new Date(), "placed"));
    orders.add(createOrder(4, 2, 2, new Date(), "delivered"));
    orders.add(createOrder(5, 3, 2, new Date(), "placed"));
    orders.add(createOrder(11, 3, 2, new Date(), "placed"));
    orders.add(createOrder(12, 3, 2, new Date(), "placed"));
    orders.add(createOrder(13, 3, 2, new Date(), "placed"));
    orders.add(createOrder(14, 3, 2, new Date(), "placed"));
    orders.add(createOrder(15, 3, 2, new Date(), "placed"));
  }

  public Order findOrderById(long orderId) {
    for (Order order : orders) {
      if (order.getId() == orderId) {
        return order;
      }
    }
    return null;
  }

  public void placeOrder(Order order) {
    if (orders.size() > 0) {
      for (int i = orders.size() - 1; i >= 0; i--) {
        if (orders.get(i).getId() == order.getId()) {
          orders.remove(i);
        }
      }
    }
    orders.add(order);
  }

  public void deleteOrder(long orderId) {
    if (orders.size() > 0) {
      for (int i = orders.size() - 1; i >= 0; i--) {
        if (orders.get(i).getId() == orderId) {
          orders.remove(i);
        }
      }
    }
  }

  private static Order createOrder(long id, long petId, int quantity,
      Date shipDate, String status) {
    Order order = new Order();
    order.setId(id);
    order.setPetId(petId);
    order.setQuantity(quantity);
    order.setShipDate(shipDate);
    order.setStatus(status);
    return order;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs/src/main/java/com/wordnik/swagger/sample/resource/SampleExceptionMapper.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resource;

import com.wordnik.swagger.sample.exception.ApiException;
import com.wordnik.swagger.sample.exception.BadRequestException;
import com.wordnik.swagger.sample.exception.NotFoundException;
import com.wordnik.swagger.sample.model.ApiResponse;

import javax.ws.rs.ext.*;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

@Provider
public class SampleExceptionMapper implements ExceptionMapper<Exception> {
  public Response toResponse(Exception exception) {
    if (exception instanceof javax.ws.rs.WebApplicationException) {
      javax.ws.rs.WebApplicationException e = (javax.ws.rs.WebApplicationException) exception;
      return Response
          .status(e.getResponse().getStatus())
          .entity(new ApiResponse(e.getResponse().getStatus(),
              exception.getMessage())).build();
    } else if (exception instanceof com.fasterxml.jackson.core.JsonParseException) {
      return Response.status(400)
          .entity(new ApiResponse(400, "bad input")).build();
    } else if (exception instanceof NotFoundException) {
      return Response
          .status(Status.NOT_FOUND)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof BadRequestException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof ApiException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else {
      return Response.status(500)
          .entity(new ApiResponse(500, "something bad happened"))
          .build();
    }
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs/src/main/java/com/wordnik/swagger/sample/util/ApiAuthorizationFilterImpl.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import com.wordnik.swagger.model.*;
import com.wordnik.swagger.core.filter.SwaggerSpecFilter;

import org.slf4j.*;

import java.util.Map;
import java.util.List;

import javax.servlet.ServletConfig;
import javax.servlet.http.HttpServlet;
/**
 * 
 * The rules are maintained in simple map with key as path and a boolean value
 * indicating given path is secure or not. For method level security the key is
 * combination of http method and path .
 * 
 * If the resource or method is secure then it can only be viewed using a
 * secured api key
 * 
 * Note: Objective of this class is not to provide fully functional
 * implementation of authorization filter. This is only a sample demonstration
 * how API authorization filter works.
 * 
 */

public class ApiAuthorizationFilterImpl implements SwaggerSpecFilter {
  static Logger logger = LoggerFactory.getLogger(ApiAuthorizationFilterImpl.class);

  public boolean isOperationAllowed(Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if(isAuthorized) {
      return true;
    }
    else {
      if(!"GET".equals(operation.method()) || api.path().indexOf("/store") != -1) {
        return false;
      }
      else return true;
    }
  }

  public boolean isParamAllowed(Parameter parameter, Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if((parameter.paramAccess().isDefined() && parameter.paramAccess().get().equals("internal")) && !isAuthorized) 
      return false;
    else 
      return true;
  }

  public boolean checkKey(Map<String, List<String>> params, Map<String, List<String>> headers) {
    String keyValue = null;
    if(params.containsKey("api_key"))
      keyValue = params.get("api_key").get(0);
    else {
      if(headers.containsKey("api_key"))
        keyValue = headers.get("api_key").get(0);
    }
    if("special-key".equals(keyValue))
      return true;
    else
      return false;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-subresource/src/main/java/com/wordnik/swagger/sample/util/ApiAuthorizationFilterImpl.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import com.wordnik.swagger.model.*;
import com.wordnik.swagger.core.filter.SwaggerSpecFilter;

import org.slf4j.*;

import java.util.Map;
import java.util.List;

import javax.servlet.ServletConfig;
import javax.servlet.http.HttpServlet;
/**
 * 
 * The rules are maintained in simple map with key as path and a boolean value
 * indicating given path is secure or not. For method level security the key is
 * combination of http method and path .
 * 
 * If the resource or method is secure then it can only be viewed using a
 * secured api key
 * 
 * Note: Objective of this class is not to provide fully functional
 * implementation of authorization filter. This is only a sample demonstration
 * how API authorization filter works.
 * 
 */

public class ApiAuthorizationFilterImpl implements SwaggerSpecFilter {
  static Logger logger = LoggerFactory.getLogger(ApiAuthorizationFilterImpl.class);

  public boolean isOperationAllowed(Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if(!"GET".equals(operation.method()) || api.path().indexOf("/store") != -1)
      return false;
    else 
      return true;
  }

  public boolean isParamAllowed(Parameter parameter, Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if((parameter.paramAccess().isDefined() && parameter.paramAccess().get().equals("internal")) && !isAuthorized) 
      return false;
    else 
      return true;
  }

  public boolean checkKey(Map<String, List<String>> params, Map<String, List<String>> headers) {
    String keyValue = null;
    if(params.containsKey("api_key"))
      keyValue = params.get("api_key").get(0);
    else {
      if(headers.containsKey("api_key"))
        keyValue = headers.get("api_key").get(0);
    }
    if("special-key".equals(keyValue))
      return true;
    else
      return false;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-play2/app/api/PetData.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package api;

import models.*;

import java.util.List;
import java.util.ArrayList;

public class PetData {
	static List<Pet> pets = new ArrayList<Pet>();
	static List<Category> categories = new ArrayList<Category>();

	static {
		categories.add(createCategory(1, "Dogs"));
		categories.add(createCategory(2, "Cats"));
		categories.add(createCategory(3, "Rabbits"));
		categories.add(createCategory(4, "Lions"));

		pets.add(createPet(1, categories.get(1), "Cat 1", new String[] {
				"url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
		pets.add(createPet(2, categories.get(1), "Cat 2", new String[] {
				"url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
		pets.add(createPet(3, categories.get(1), "Cat 3", new String[] {
				"url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

		pets.add(createPet(4, categories.get(0), "Dog 1", new String[] {
				"url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
		pets.add(createPet(5, categories.get(0), "Dog 2", new String[] {
				"url1", "url2" }, new String[] { "tag2", "tag3" }, "sold"));
		pets.add(createPet(6, categories.get(0), "Dog 3", new String[] {
				"url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

		pets.add(createPet(7, categories.get(3), "Lion 1", new String[] {
				"url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
		pets.add(createPet(8, categories.get(3), "Lion 2", new String[] {
				"url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
		pets.add(createPet(9, categories.get(3), "Lion 3", new String[] {
				"url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));

		pets.add(createPet(10, categories.get(2), "Rabbit 1", new String[] {
				"url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));
	}

	public Pet getPetbyId(long petId) {
		for (Pet pet : pets) {
			if (pet.getId() == petId) {
				return pet;
			}
		}
		return null;
	}

	public List<Pet> findPetByStatus(String status) {
		String[] statues = status.split(",");
		List<Pet> result = new java.util.ArrayList<Pet>();
		for (Pet pet : pets) {
			for (String s : statues) {
				if (s.equals(pet.getStatus())) {
					result.add(pet);
				}
			}
		}
		return result;
	}

	public List<Pet> findPetByTags(String tags) {
		String[] tagList = tags.split(",");
		List<Pet> result = new java.util.ArrayList<Pet>();
		for (Pet pet : pets) {
			if (null != pet.getTags()) {
				for (Tag tag : pet.getTags()) {
					for (String tagListString : tagList) {
						if (tagListString.equals(tag.getName()))
							result.add(pet);
					}
				}
			}
		}
		return result;
	}

	public void addPet(Pet pet) {
		if (pets.size() > 0) {
			for (int i = pets.size() - 1; i >= 0; i--) {
				if (pets.get(i).getId() == pet.getId()) {
					pets.remove(i);
				}
			}
		}
		pets.add(pet);
	}

	static Pet createPet(long id, Category cat, String name, String[] urls,
			String[] tags, String status) {
		Pet pet = new Pet();
		pet.setId(id);
		pet.setCategory(cat);
		pet.setName(name);
		if (null != urls) {
			List<String> urlObjs = new ArrayList<String>();
			for (String urlString : urls) {
				urlObjs.add(urlString);
			}
			pet.setPhotoUrls(urlObjs);
		}
		List<Tag> tagObjs = new java.util.ArrayList<Tag>();
		int i = 0;
		if (null != tags) {
			for (String tagString : tags) {
				i = i + 1;
				Tag tag = new Tag();
				tag.setId(i);
				tag.setName(tagString);
				tagObjs.add(tag);
			}
		}
		pet.setTags(tagObjs);
		pet.setStatus(status);
		return pet;
	}

	static Category createCategory(long id, String name) {
		Category category = new Category();
		category.setId(id);
		category.setName(name);
		return category;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-play2/app/api/UserData.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package api;

import models.*;

import java.util.List;
import java.util.ArrayList;

public class UserData {
	static List<User> users = new ArrayList<User>();

	static {
		users.add(createUser(1, "user1", "first name 1", "last name 1",
				"email1@test.com", "123-456-7890", 1));
		users.add(createUser(2, "user2", "first name 2", "last name 2",
				"email2@test.com", "123-456-7890", 2));
		users.add(createUser(3, "user3", "first name 3", "last name 3",
				"email3@test.com", "123-456-7890", 3));
		users.add(createUser(4, "user4", "first name 4", "last name 4",
				"email4@test.com", "123-456-7890", 1));
		users.add(createUser(5, "user5", "first name 5", "last name 5",
				"email5@test.com", "123-456-7890", 2));
		users.add(createUser(6, "user6", "first name 6", "last name 6",
				"email6@test.com", "123-456-7890", 3));
		users.add(createUser(7, "user7", "first name 7", "last name 7",
				"email7@test.com", "123-456-7890", 1));
		users.add(createUser(8, "user8", "first name 8", "last name 8",
				"email8@test.com", "123-456-7890", 2));
		users.add(createUser(9, "user9", "first name 9", "last name 9",
				"email9@test.com", "123-456-7890", 3));
		users.add(createUser(10, "user10", "first name 10", "last name 10",
				"email10@test.com", "123-456-7890", 1));
		users.add(createUser(11, "user?10", "first name ?10", "last name ?10",
				"email101@test.com", "123-456-7890", 1));

	}

	public User findUserByName(String username) {
		for (User user : users) {
			if (user.getUsername().equals(username)) {
				return user;
			}
		}
		return null;
	}

	public void addUser(User user) {
		if (users.size() > 0) {
			for (int i = users.size() - 1; i >= 0; i--) {
				if (users.get(i).getUsername().equals(user.getUsername())) {
					users.remove(i);
				}
			}
		}
		users.add(user);
	}

	public void removeUser(String username) {
		if (users.size() > 0) {
			for (int i = users.size() - 1; i >= 0; i--) {
				if (users.get(i).getUsername().equals(username)) {
					users.remove(i);
				}
			}
		}
	}

	private static User createUser(long id, String username, String firstName,
			String lastName, String email, String phone, int userStatus) {
		User user = new User();
		user.setId(id);
		user.setUsername(username);
		user.setFirstName(firstName);
		user.setLastName(lastName);
		user.setEmail(email);
		user.setPassword("XXXXXXXXXXX");
		user.setPhone(phone);
		user.setUserStatus(userStatus);
		return user;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-play2/app/api/StoreData.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package api;

import models.*;
import java.util.Date;
import java.util.List;
import java.util.ArrayList;

public class StoreData {
	static List<Order> orders = new ArrayList<Order>();

	static {
		orders.add(createOrder(1, 1, 2, new Date(), "placed"));
		orders.add(createOrder(2, 1, 2, new Date(), "delivered"));
		orders.add(createOrder(3, 2, 2, new Date(), "placed"));
		orders.add(createOrder(4, 2, 2, new Date(), "delivered"));
		orders.add(createOrder(5, 3, 2, new Date(), "placed"));
		orders.add(createOrder(11, 3, 2, new Date(), "placed"));
		orders.add(createOrder(12, 3, 2, new Date(), "placed"));
		orders.add(createOrder(13, 3, 2, new Date(), "placed"));
		orders.add(createOrder(14, 3, 2, new Date(), "placed"));
		orders.add(createOrder(15, 3, 2, new Date(), "placed"));
	}

	public Order findOrderById(long orderId) {
		for (Order order : orders) {
			if (order.getId() == orderId) {
				return order;
			}
		}
		return null;
	}

	public void placeOrder(Order order) {
		if (orders.size() > 0) {
			for (int i = orders.size() - 1; i >= 0; i--) {
				if (orders.get(i).getId() == order.getId()) {
					orders.remove(i);
				}
			}
		}
		orders.add(order);
	}

	public void deleteOrder(long orderId) {
		if (orders.size() > 0) {
			for (int i = orders.size() - 1; i >= 0; i--) {
				if (orders.get(i).getId() == orderId) {
					orders.remove(i);
				}
			}
		}
	}

	private static Order createOrder(long id, long petId, int quantity,
			Date shipDate, String status) {
		Order order = new Order();
		order.setId(id);
		order.setPetId(petId);
		order.setQuantity(quantity);
		order.setShipDate(shipDate);
		order.setStatus(status);
		return order;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-play2/app/exception/ApiException.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package exception;

public class ApiException extends Exception{
	private int code;
	public ApiException (int code, String msg) {
		super(msg);
		this.code = code;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-play2/app/exception/NotFoundException.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package exception;

public class NotFoundException extends ApiException {
	private int code;
	public NotFoundException (int code, String msg) {
		super(code, msg);
		this.code = code;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-play2/app/exception/BadRequestException.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package exception;

public class BadRequestException extends ApiException{
	private int code;
	public BadRequestException (int code, String msg) {
		super(code, msg);
		this.code = code;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-play2/app/controllers/JavaRestResourceUtil.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package controllers;

import java.text.SimpleDateFormat;

import java.util.Date;

public class JavaRestResourceUtil {
  public int getInt(int minVal, int maxVal, int defaultValue, String inputString) {
    int output = defaultValue;
    try {
    	output = Integer.parseInt(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) {
    	if (output < minVal) output = minVal;
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public long getLong(long minVal, long maxVal, long defaultValue, String inputString) {
    long output = defaultValue;
    try {
    	output = Long.parseLong(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { if (output < minVal) output = minVal; }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public double getDouble(double minVal, double maxVal, double defaultValue, String inputString) {
    double output = defaultValue;
    try {
    	output = Double.parseDouble(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { 
    	if (output < minVal) output = minVal; 
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public boolean getBoolean(boolean defaultValue, String booleanString) {
    boolean output = defaultValue;
    if (booleanString == null) output = defaultValue;

    //	treat "", "YES" as "true"
    if ("".equals(booleanString)) output = true;
    else if ("YES".equalsIgnoreCase(booleanString)) output = true;
    else if ("NO".equalsIgnoreCase(booleanString)) output = false;
    else {
      try {
    	  output = Boolean.parseBoolean(booleanString);
      }
      catch (Exception e){
        output = defaultValue;
      }
    }
    return output;
  }
  
  public Date getDate(Date defaultValue, String dateString){
    try {
    	return new SimpleDateFormat("yyyy-MM-dd").parse(dateString);
    }
    catch(Exception e) {
      return defaultValue;
    }
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-play2/app/controllers/BaseApiController.java;<<<<<<< MINE
=======
package controllers;


import play.mvc.*;
//import play.data.*;
import play.*;

import com.wordnik.swagger.core.util.JsonUtil;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.*;
import java.io.StringWriter;

import models.*;

public class BaseApiController extends Controller {
    static JavaRestResourceUtil ru = new JavaRestResourceUtil();

    protected static ObjectMapper mapper = JsonUtil.mapper();

    public static Result JsonResponse(Object obj) {
        return JsonResponse(obj, 200);
    }

    public static Result JsonResponse(Object obj, int code) {
        StringWriter w = new StringWriter();
        try {
            mapper.writeValue(w, obj);
        } catch (Exception e) {
            // TODO: handle proper return code
            e.printStackTrace();
        }

        response().setContentType("application/json");
        response().setHeader("Access-Control-Allow-Origin", "*");
        response().setHeader("Access-Control-Allow-Methods", "GET, POST, DELETE, PUT");
        response().setHeader("Access-Control-Allow-Headers", "Content-Type, api_key, Authorization");

        return status(code, w.toString());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-play2/app/models/ApiResponse.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package models;

import javax.xml.bind.annotation.XmlTransient;

@javax.xml.bind.annotation.XmlRootElement
public class ApiResponse {
	public static final int ERROR = 1;
	public static final int WARNING = 2;
	public static final int INFO = 3;
	public static final int OK = 4;
	public static final int TOO_BUSY = 5;

	int code;
	String type;
	String message;
	
	public ApiResponse(){}
	
	public ApiResponse(int code, String message){
		this.code = code;
		switch(code){
		case ERROR:
			setType("error");
			break;
		case WARNING:
			setType("warning");
			break;
		case INFO:
			setType("info");
			break;
		case OK:
			setType("ok");
			break;
		case TOO_BUSY:
			setType("too busy");
			break;
		default:
			setType("unknown");
			break;
		}
		this.message = message;
	}

	@XmlTransient
	public int getCode() {
		return code;
	}

	public void setCode(int code) {
		this.code = code;
	}

	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;
	}

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-play2/app/models/Pet.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package models;

import com.wordnik.swagger.annotations.*;

import java.util.List;
import java.util.ArrayList;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Pet")
public class Pet {
	private long id;
	private Category category;
	private String name;
	private List<String> photoUrls = new ArrayList<String>();
	private List<Tag> tags = new ArrayList<Tag>();
	private String status;

	@XmlElement(name = "id")
	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	@XmlElement(name = "category")
	public Category getCategory() {
		return category;
	}

	public void setCategory(Category category) {
		this.category = category;
	}

	@XmlElement(name = "name")
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@XmlElementWrapper(name = "photoUrls")
	@XmlElement(name = "photoUrl")
	public List<String> getPhotoUrls() {
		return photoUrls;
	}

	public void setPhotoUrls(List<String> photoUrls) {
		this.photoUrls = photoUrls;
	}

	@XmlElementWrapper(name = "tags")
	@XmlElement(name = "tag")
	public List<Tag> getTags() {
		return tags;
	}

	public void setTags(List<Tag> tags) {
		this.tags = tags;
	}

	@XmlElement(name = "status")
  @ApiModelProperty(value = "pet status in the store", allowableValues = "available,pending,sold")
  public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-play2/app/models/Order.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package models;

import com.wordnik.swagger.annotations.*;

import java.util.Date;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Order")
public class Order {
	private long id;
	private long petId;
	private int quantity;
	private Date shipDate;
	private String status;
    private boolean complete;

	@XmlElement(name = "id")
	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

    public boolean isComplete() {
        return complete;
    }

    public void setComplete(boolean complete) {
        this.complete = complete;
    }


	@XmlElement(name = "petId")
	public long getPetId() {
		return petId;
	}

	public void setPetId(long petId) {
		this.petId = petId;
	}

	@XmlElement(name = "quantity")
	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	@XmlElement(name = "status")
  @ApiModelProperty(value = "Order Status", allowableValues = "placed,approved,delivered")
	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	@XmlElement(name = "shipDate")
	public Date getShipDate() {
		return shipDate;
	}

	public void setShipDate(Date shipDate) {
		this.shipDate = shipDate;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-play2/app/models/User.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package models;

import com.wordnik.swagger.annotations.*;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "User")
public class User {
	private long id;
	private String username;
	private String firstName;
	private String lastName;
	private String email;
	private String password;
	private String phone;
	private int userStatus;

	@XmlElement(name = "id")
	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	@XmlElement(name = "firstName")
	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	@XmlElement(name = "username")
	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	@XmlElement(name = "lastName")
	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	@XmlElement(name = "email")
	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	@XmlElement(name = "password")
	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	@XmlElement(name = "phone")
	public String getPhone() {
		return phone;
	}

	public void setPhone(String phone) {
		this.phone = phone;
	}

	@XmlElement(name = "userStatus")
  @ApiModelProperty(value = "User Status", allowableValues = "1-registered,2-active,3-closed")
	public int getUserStatus() {
		return userStatus;
	}

	public void setUserStatus(int userStatus) {
		this.userStatus = userStatus;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-play2/app/models/Tag.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package models;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Tag")
public class Tag {
	private long id;
	private String name;

	@XmlElement(name = "id")
	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	@XmlElement(name = "name")
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-play2/app/models/Category.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package models;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Category")
public class Category {
	private long id;
	private String name;

	@XmlElement(name = "id")
	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	@XmlElement(name = "name")
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-cxf/src/main/java/com/wordnik/swagger/sample/util/ApiAuthorizationFilterImpl.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import com.wordnik.swagger.model.*;
import com.wordnik.swagger.core.filter.SwaggerSpecFilter;

import org.slf4j.*;

import java.util.Map;
import java.util.List;

import javax.servlet.ServletConfig;
import javax.servlet.http.HttpServlet;
/**
 * 
 * The rules are maintained in simple map with key as path and a boolean value
 * indicating given path is secure or not. For method level security the key is
 * combination of http method and path .
 * 
 * If the resource or method is secure then it can only be viewed using a
 * secured api key
 * 
 * Note: Objective of this class is not to provide fully functional
 * implementation of authorization filter. This is only a sample demonstration
 * how API authorization filter works.
 * 
 */

public class ApiAuthorizationFilterImpl implements SwaggerSpecFilter {
  static Logger logger = LoggerFactory.getLogger(ApiAuthorizationFilterImpl.class);

  public boolean isOperationAllowed(Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if(isAuthorized) {
      return true;
    }
    else {
      if(!"GET".equals(operation.method()) || api.path().indexOf("/store") != -1) {
        return false;
      }
      else return true;
    }
  }

  public boolean isParamAllowed(Parameter parameter, Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if((parameter.paramAccess().isDefined() && parameter.paramAccess().get().equals("internal")) && !isAuthorized) 
      return false;
    else 
      return true;
  }

  public boolean checkKey(Map<String, List<String>> params, Map<String, List<String>> headers) {
    String keyValue = null;
    if(params.containsKey("api_key"))
      keyValue = params.get("api_key").get(0);
    else {
      if(headers.containsKey("api_key"))
        keyValue = headers.get("api_key").get(0);
    }
    if("special-key".equals(keyValue))
      return true;
    else
      return false;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jersey2/src/main/java/com/wordnik/swagger/sample/util/CustomFilter.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import com.wordnik.swagger.core.filter.SwaggerSpecFilter;
import com.wordnik.swagger.model.*;

public class CustomFilter implements SwaggerSpecFilter {
  @Override
  public boolean isOperationAllowed(
    Operation operation,
    ApiDescription api, 
    java.util.Map<String, java.util.List<String>> params, 
    java.util.Map<String, String> cookies, 
    java.util.Map<String, java.util.List<String>> headers) {
    return true;
  }

  @Override
  public boolean isParamAllowed(
    Parameter parameter, 
    Operation operation, 
    ApiDescription api,
    java.util.Map<String, java.util.List<String>> params, 
    java.util.Map<String, String> cookies,
    java.util.Map<String, java.util.List<String>>  headers) {
    return true;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-grails2/src/java/com/wordnik/swagger/sample/util/ApiAuthorizationFilterImpl.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import com.wordnik.swagger.model.*;
import com.wordnik.swagger.core.filter.SwaggerSpecFilter;

import org.slf4j.*;

import java.util.Map;
import java.util.List;

import javax.servlet.ServletConfig;
import javax.servlet.http.HttpServlet;
/**
 * 
 * The rules are maintained in simple map with key as path and a boolean value
 * indicating given path is secure or not. For method level security the key is
 * combination of http method and path .
 * 
 * If the resource or method is secure then it can only be viewed using a
 * secured api key
 * 
 * Note: Objective of this class is not to provide fully functional
 * implementation of authorization filter. This is only a sample demonstration
 * how API authorization filter works.
 * 
 */

public class ApiAuthorizationFilterImpl implements SwaggerSpecFilter {
  static Logger logger = LoggerFactory.getLogger(ApiAuthorizationFilterImpl.class);

  public boolean isOperationAllowed(Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if(isAuthorized) {
      return true;
    }
    else {
      if(!"GET".equals(operation.method()) || api.path().indexOf("/store") != -1) {
        return false;
      }
      else return true;
    }
  }

  public boolean isParamAllowed(Parameter parameter, Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if((parameter.paramAccess().isDefined() && parameter.paramAccess().get().equals("internal")) && !isAuthorized) 
      return false;
    else 
      return true;
  }

  public boolean checkKey(Map<String, List<String>> params, Map<String, List<String>> headers) {
    String keyValue = null;
    if(params.containsKey("api_key"))
      keyValue = params.get("api_key").get(0);
    else {
      if(headers.containsKey("api_key"))
        keyValue = headers.get("api_key").get(0);
    }
    if("special-key".equals(keyValue))
      return true;
    else
      return false;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-grails2/src/java/com/wordnik/swagger/sample/util/JacksonJsonProvider.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import javax.ws.rs.Produces;

import javax.ws.rs.core.MediaType;
import javax.ws.rs.ext.Provider;

import com.wordnik.swagger.core.util.JsonUtil;
import com.fasterxml.jackson.jaxrs.json.JacksonJaxbJsonProvider;
import com.fasterxml.jackson.databind.*;



import com.fasterxml.jackson.module.scala.DefaultScalaModule;

import com.fasterxml.jackson.core.JsonGenerator.Feature;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;


@Provider
@Produces(MediaType.APPLICATION_JSON)
public class JacksonJsonProvider extends JacksonJaxbJsonProvider {
	private static ObjectMapper commonMapper = null;

	public JacksonJsonProvider() {
		if(commonMapper == null){
		    ObjectMapper mapper = new ObjectMapper();

		    mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
		    mapper.setSerializationInclusion(JsonInclude.Include.NON_DEFAULT);
		    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
		    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
		    
		    commonMapper = mapper;
		}
		super.setMapper(commonMapper);
	}
	
	
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/Bootstrap.java;<<<<<<< MINE
=======
package com.wordnik.swagger.sample;

import com.wordnik.swagger.model.*;
import com.wordnik.swagger.config.*;
import com.wordnik.swagger.sample.util.*;
import com.wordnik.swagger.config.FilterFactory;

import javax.servlet.http.HttpServlet;

import java.util.List;
import java.util.ArrayList;

public class Bootstrap extends HttpServlet {
  static {
    // do any additional initialization here, such as set your base path programmatically as such:
    // ConfigFactory.config().setBasePath("http://www.foo.com/");

    ApiInfo info = new ApiInfo(
      "Swagger Sample App",                             /* title */
      "This is a sample server Petstore server.  You can find out more about Swagger " + 
      "at <a href=\"http://swagger.io\">http://swagger.io</a> or on irc.freenode.net, #swagger.  For this sample, " + 
      "you can use the api key \"special-key\" to test the authorization filters", 
      "http://helloreverb.com/terms/",                  /* TOS URL */
      "apiteam@wordnik.com",                            /* Contact */
      "Apache 2.0",                                     /* license */
      "http://www.apache.org/licenses/LICENSE-2.0.html" /* license URL */
    );

    List<AuthorizationScope> scopes = new ArrayList<AuthorizationScope>();
    scopes.add(new AuthorizationScope("email", "Access to your email address"));
    scopes.add(new AuthorizationScope("pets", "Access to your pets"));

    List<GrantType> grantTypes = new ArrayList<GrantType>();

    ImplicitGrant implicitGrant = new ImplicitGrant(
      new LoginEndpoint("http://localhost:8002/oauth/dialog"), 
      "access_code");

    grantTypes.add(implicitGrant);

    AuthorizationType oauth = new OAuthBuilder().scopes(scopes).grantTypes(grantTypes).build();

    ConfigFactory.config().addAuthorization(oauth);
    ConfigFactory.config().setApiInfo(info);
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/resource/SampleExceptionMapper.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resource;

import com.wordnik.swagger.sample.exception.ApiException;
import com.wordnik.swagger.sample.exception.BadRequestException;
import com.wordnik.swagger.sample.exception.NotFoundException;
import com.wordnik.swagger.sample.model.ApiResponse;

import javax.ws.rs.ext.*;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

@Provider
public class SampleExceptionMapper implements ExceptionMapper<Exception> {
  public Response toResponse(Exception exception) {
    if (exception instanceof javax.ws.rs.WebApplicationException) {
      javax.ws.rs.WebApplicationException e = (javax.ws.rs.WebApplicationException) exception;
      return Response
          .status(e.getResponse().getStatus())
          .entity(new ApiResponse(e.getResponse().getStatus(),
              exception.getMessage())).build();
    } else if (exception instanceof com.fasterxml.jackson.core.JsonParseException) {
      return Response.status(400)
          .entity(new ApiResponse(400, "bad input")).build();
    } else if (exception instanceof NotFoundException) {
      return Response
          .status(Status.NOT_FOUND)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof BadRequestException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof ApiException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else {
      return Response.status(500)
          .entity(new ApiResponse(500, "something bad happened"))
          .build();
    }
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/resource/UserResource.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resource;

import com.wordnik.swagger.sample.data.UserData;
import com.wordnik.swagger.sample.model.User;
import com.wordnik.swagger.sample.exception.ApiException;
import com.wordnik.swagger.sample.exception.NotFoundException;

import javax.ws.rs.core.Response;
import javax.ws.rs.*;

@Path("/user")
@Produces({"application/json", "application/xml"})
public class UserResource {
  static UserData userData = new UserData();

  @POST
  public Response createUser(User user) {
    userData.addUser(user);
    return Response.ok().entity("").build();
  }

  @POST
  @Path("/createWithArray")
  public Response createUsersWithArrayInput(User[] users) {
      for (User user : users) {
          userData.addUser(user);
      }
      return Response.ok().entity("").build();
  }

  @POST
  @Path("/createWithList")
  public Response createUsersWithListInput(java.util.List<User> users) {
      for (User user : users) {
          userData.addUser(user);
      }
      return Response.ok().entity("").build();
  }

  @PUT
  @Path("/{username}")
  public Response updateUser(@PathParam("username") String username, User user) {
    userData.addUser(user);
    return Response.ok().entity("").build();
  }

  @DELETE
  @Path("/{username}")
  public Response deleteUser(String username) {
    userData.removeUser(username);
    return Response.ok().entity("").build();
  }

  @GET
  @Path("/{username}")
  public Response getUserByName(@PathParam("username") String username)
    throws ApiException {
    User user = userData.findUserByName(username);
    if (null != user) {
      return Response.ok().entity(user).build();
    } else {
      throw new NotFoundException(404, "User not found");
    }
  }

  @GET
  @Path("/login")
  public Response loginUser(@QueryParam("username") String username, @QueryParam("password") String password) {
    return Response.ok()
        .entity("logged in user session:" + System.currentTimeMillis())
        .build();
  }

  @GET
  @Path("/logout")
  public Response logoutUser() {
    return Response.ok().entity("").build();
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/resource/PetStoreResource.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resource;

import com.wordnik.swagger.sample.data.StoreData;
import com.wordnik.swagger.sample.model.Order;
import com.wordnik.swagger.sample.exception.NotFoundException;

import javax.ws.rs.core.Response;
import javax.ws.rs.*;

@Path("/store")
@Produces({"application/json", "application/xml"})
public class PetStoreResource {
  static StoreData storeData = new StoreData();
  static JavaRestResourceUtil ru = new JavaRestResourceUtil();

  @GET
  @Path("/order/{orderId}")
  public Response getOrderById(@PathParam("orderId") String orderId)
      throws NotFoundException {
    Order order = storeData.findOrderById(ru.getLong(0, 10000, 0, orderId));
    if (null != order) {
      return Response.ok().entity(order).build();
    } else {
      throw new NotFoundException(404, "Order not found");
    }
  }

  @POST
  @Path("/order")
  public Response placeOrder(Order order) {
    storeData.placeOrder(order);
    return Response.ok().entity("").build();
  }

  @DELETE
  @Path("/order/{orderId}")
  public Response deleteOrder(@PathParam("orderId") String orderId) {
    storeData.deleteOrder(ru.getLong(0, 10000, 0, orderId));
    return Response.ok().entity("").build();
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/resource/PetResource.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resource;

import com.wordnik.swagger.sample.data.PetData;
import com.wordnik.swagger.sample.model.Pet;
import com.wordnik.swagger.sample.exception.NotFoundException;

import javax.ws.rs.core.Response;
import javax.ws.rs.*;

@Path("/pet")
@Produces({"application/json", "application/xml"})
public class PetResource {
  static PetData petData = new PetData();
  static JavaRestResourceUtil ru = new JavaRestResourceUtil();

  @GET
  @Path("/{petId}")
  public Response getPetById(@PathParam("petId") String petId)
      throws NotFoundException {
    Pet pet = petData.getPetbyId(ru.getLong(0, 100000, 0, petId));
    if (null != pet) {
      return Response.ok().entity(pet).build();
    } else {
      throw new NotFoundException(404, "Pet not found");
    }
  }

  @POST
  public Response addPet(Pet pet) {
    petData.addPet(pet);
    return Response.ok().entity("SUCCESS").build();
  }

  @PUT
  public Response updatePet(Pet pet) {
    petData.addPet(pet);
    return Response.ok().entity("SUCCESS").build();
  }

  @GET
  @Path("/findByStatus")
  public Response findPetsByStatus(@QueryParam("status") String status) {
    return Response.ok(petData.findPetByStatus(status)).build();
  }

  @GET
  @Path("/findByTags")
  @Deprecated
  public Response findPetsByTags(@QueryParam("tags") String tags) {
    return Response.ok(petData.findPetByTags(tags)).build();
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/resource/JavaRestResourceUtil.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resource;

import java.text.SimpleDateFormat;

import java.util.Date;

public class JavaRestResourceUtil {
  public int getInt(int minVal, int maxVal, int defaultValue, String inputString) {
    int output = defaultValue;
    try {
      output = Integer.parseInt(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) {
      if (output < minVal) output = minVal;
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public long getLong(long minVal, long maxVal, long defaultValue, String inputString) {
    long output = defaultValue;
    try {
      output = Long.parseLong(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { if (output < minVal) output = minVal; }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public double getDouble(double minVal, double maxVal, double defaultValue, String inputString) {
    double output = defaultValue;
    try {
      output = Double.parseDouble(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { 
      if (output < minVal) output = minVal; 
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public boolean getBoolean(boolean defaultValue, String booleanString) {
    boolean output = defaultValue;
    if (booleanString == null) output = defaultValue;

    //  treat "", "YES" as "true"
    if ("".equals(booleanString)) output = true;
    else if ("YES".equalsIgnoreCase(booleanString)) output = true;
    else if ("NO".equalsIgnoreCase(booleanString)) output = false;
    else {
      try {
        output = Boolean.parseBoolean(booleanString);
      }
      catch (Exception e){
        output = defaultValue;
      }
    }
    return output;
  }
  
  public Date getDate(Date defaultValue, String dateString){
    try {
      return new SimpleDateFormat("yyyy-MM-dd").parse(dateString);
    }
    catch(Exception e) {
      return defaultValue;
    }
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/exception/ApiException.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class ApiException extends Exception{
  private int code;
  public ApiException (int code, String msg) {
    super(msg);
    this.code = code;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/exception/NotFoundException.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class NotFoundException extends ApiException {
  private int code;
  public NotFoundException (int code, String msg) {
    super(code, msg);
    this.code = code;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/exception/BadRequestException.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class BadRequestException extends ApiException{
  private int code;
  public BadRequestException (int code, String msg) {
    super(code, msg);
    this.code = code;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/model/ApiResponse.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.XmlTransient;

@javax.xml.bind.annotation.XmlRootElement
public class ApiResponse {
  public static final int ERROR = 1;
  public static final int WARNING = 2;
  public static final int INFO = 3;
  public static final int OK = 4;
  public static final int TOO_BUSY = 5;

  int code;
  String type;
  String message;
  
  public ApiResponse(){}
  
  public ApiResponse(int code, String message){
    this.code = code;
    switch(code){
    case ERROR:
      setType("error");
      break;
    case WARNING:
      setType("warning");
      break;
    case INFO:
      setType("info");
      break;
    case OK:
      setType("ok");
      break;
    case TOO_BUSY:
      setType("too busy");
      break;
    default:
      setType("unknown");
      break;
    }
    this.message = message;
  }

  @XmlTransient
  public int getCode() {
    return code;
  }

  public void setCode(int code) {
    this.code = code;
  }

  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/model/Pet.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import java.util.List;
import java.util.ArrayList;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Pet")
public class Pet {
  private long id;
  private Category category;
  private String name;
  private List<String> photoUrls = new ArrayList<String>();
  private List<Tag> tags = new ArrayList<Tag>();
  private String status;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "category")
  public Category getCategory() {
    return category;
  }

  public void setCategory(Category category) {
    this.category = category;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  @XmlElementWrapper(name = "photoUrls")
  @XmlElement(name = "photoUrl")
  public List<String> getPhotoUrls() {
    return photoUrls;
  }

  public void setPhotoUrls(List<String> photoUrls) {
    this.photoUrls = photoUrls;
  }

  @XmlElementWrapper(name = "tags")
  @XmlElement(name = "tag")
  public List<Tag> getTags() {
    return tags;
  }

  public void setTags(List<Tag> tags) {
    this.tags = tags;
  }

  @XmlElement(name = "status")
  @ApiModelProperty(value = "pet status in the store", allowableValues = "available,pending,sold")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/model/Order.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import java.util.Date;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Order")
public class Order {
  private long id;
  private long petId;
  private int quantity;
  private Date shipDate;
  private String status;
    private boolean complete;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

    public boolean isComplete() {
        return complete;
    }

    public void setComplete(boolean complete) {
        this.complete = complete;
    }


  @XmlElement(name = "petId")
  public long getPetId() {
    return petId;
  }

  public void setPetId(long petId) {
    this.petId = petId;
  }

  @XmlElement(name = "quantity")
  public int getQuantity() {
    return quantity;
  }

  public void setQuantity(int quantity) {
    this.quantity = quantity;
  }

  @XmlElement(name = "status")
  @ApiModelProperty(value = "Order Status", allowableValues = "placed, approved, delivered")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }

  @XmlElement(name = "shipDate")
  public Date getShipDate() {
    return shipDate;
  }

  public void setShipDate(Date shipDate) {
    this.shipDate = shipDate;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/model/User.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "User")
public class User {
  private long id;
  private String username;
  private String firstName;
  private String lastName;
  private String email;
  private String password;
  private String phone;
  private int userStatus;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "firstName")
  public String getFirstName() {
    return firstName;
  }

  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }

  @XmlElement(name = "username")
  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  @XmlElement(name = "lastName")
  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }

  @XmlElement(name = "email")
  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  @XmlElement(name = "password")
  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  @XmlElement(name = "phone")
  public String getPhone() {
    return phone;
  }

  public void setPhone(String phone) {
    this.phone = phone;
  }

  @XmlElement(name = "userStatus")
  @ApiModelProperty(value = "User Status", allowableValues = "1-registered,2-active,3-closed")
  public int getUserStatus() {
    return userStatus;
  }

  public void setUserStatus(int userStatus) {
    this.userStatus = userStatus;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/model/Tag.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Tag")
public class Tag {
  private long id;
  private String name;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/model/Category.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Category")
public class Category {
  private long id;
  private String name;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/util/ApiAuthorizationFilterImpl.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import com.wordnik.swagger.model.*;
import com.wordnik.swagger.core.filter.SwaggerSpecFilter;

import org.slf4j.*;

import java.util.Map;
import java.util.List;

import javax.servlet.ServletConfig;
import javax.servlet.http.HttpServlet;
/**
 * 
 * The rules are maintained in simple map with key as path and a boolean value
 * indicating given path is secure or not. For method level security the key is
 * combination of http method and path .
 * 
 * If the resource or method is secure then it can only be viewed using a
 * secured api key
 * 
 * Note: Objective of this class is not to provide fully functional
 * implementation of authorization filter. This is only a sample demonstration
 * how API authorization filter works.
 * 
 */

public class ApiAuthorizationFilterImpl implements SwaggerSpecFilter {
  static Logger logger = LoggerFactory.getLogger(ApiAuthorizationFilterImpl.class);

  public boolean isOperationAllowed(Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if(isAuthorized) {
      return true;
    }
    else {
      if(!"GET".equals(operation.method()) || api.path().indexOf("/store") != -1) {
        return false;
      }
      else return true;
    }
  }

  public boolean isParamAllowed(Parameter parameter, Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if((parameter.paramAccess().isDefined() && parameter.paramAccess().get().equals("internal")) && !isAuthorized) 
      return false;
    else 
      return true;
  }

  public boolean checkKey(Map<String, List<String>> params, Map<String, List<String>> headers) {
    String keyValue = null;
    if(params.containsKey("api_key"))
      keyValue = params.get("api_key").get(0);
    else {
      if(headers.containsKey("api_key"))
        keyValue = headers.get("api_key").get(0);
    }
    if("special-key".equals(keyValue))
      return true;
    else
      return false;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/util/ApiOriginFilter.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import java.io.IOException;

import javax.servlet.*;
import javax.servlet.http.HttpServletResponse;

public class ApiOriginFilter implements javax.servlet.Filter {
  @Override
  public void doFilter(ServletRequest request, ServletResponse response,
      FilterChain chain) throws IOException, ServletException {
    HttpServletResponse res = (HttpServletResponse) response;
    res.addHeader("Access-Control-Allow-Origin", "*");
    res.addHeader("Access-Control-Allow-Methods", "GET, POST, DELETE, PUT");
    res.addHeader("Access-Control-Allow-Headers", "Content-Type");
    chain.doFilter(request, response);
  }

  @Override
  public void destroy() {
  }

  @Override
  public void init(FilterConfig filterConfig) throws ServletException {
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/data/PetData.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;

import java.util.List;
import java.util.ArrayList;

public class PetData {
  static List<Pet> pets = new ArrayList<Pet>();
  static List<Category> categories = new ArrayList<Category>();

  static {
    categories.add(createCategory(1, "Dogs"));
    categories.add(createCategory(2, "Cats"));
    categories.add(createCategory(3, "Rabbits"));
    categories.add(createCategory(4, "Lions"));

    pets.add(createPet(1, categories.get(1), "Cat 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(2, categories.get(1), "Cat 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
    pets.add(createPet(3, categories.get(1), "Cat 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

    pets.add(createPet(4, categories.get(0), "Dog 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(5, categories.get(0), "Dog 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "sold"));
    pets.add(createPet(6, categories.get(0), "Dog 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

    pets.add(createPet(7, categories.get(3), "Lion 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(8, categories.get(3), "Lion 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
    pets.add(createPet(9, categories.get(3), "Lion 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));

    pets.add(createPet(10, categories.get(2), "Rabbit 1", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));
  }

  public Pet getPetbyId(long petId) {
    for (Pet pet : pets) {
      if (pet.getId() == petId) {
        return pet;
      }
    }
    return null;
  }

  public List<Pet> findPetByStatus(String status) {
    String[] statues = status.split(",");
    List<Pet> result = new java.util.ArrayList<Pet>();
    for (Pet pet : pets) {
      for (String s : statues) {
        if (s.equals(pet.getStatus())) {
          result.add(pet);
        }
      }
    }
    return result;
  }

  public List<Pet> findPetByTags(String tags) {
    String[] tagList = tags.split(",");
    List<Pet> result = new java.util.ArrayList<Pet>();
    for (Pet pet : pets) {
      if (null != pet.getTags()) {
        for (Tag tag : pet.getTags()) {
          for (String tagListString : tagList) {
            if (tagListString.equals(tag.getName()))
              result.add(pet);
          }
        }
      }
    }
    return result;
  }

  public void addPet(Pet pet) {
    if (pets.size() > 0) {
      for (int i = pets.size() - 1; i >= 0; i--) {
        if (pets.get(i).getId() == pet.getId()) {
          pets.remove(i);
        }
      }
    }
    pets.add(pet);
  }

  static Pet createPet(long id, Category cat, String name, String[] urls,
      String[] tags, String status) {
    Pet pet = new Pet();
    pet.setId(id);
    pet.setCategory(cat);
    pet.setName(name);
    if (null != urls) {
      List<String> urlObjs = new ArrayList<String>();
      for (String urlString : urls) {
        urlObjs.add(urlString);
      }
      pet.setPhotoUrls(urlObjs);
    }
    List<Tag> tagObjs = new java.util.ArrayList<Tag>();
    int i = 0;
    if (null != tags) {
      for (String tagString : tags) {
        i = i + 1;
        Tag tag = new Tag();
        tag.setId(i);
        tag.setName(tagString);
        tagObjs.add(tag);
      }
    }
    pet.setTags(tagObjs);
    pet.setStatus(status);
    return pet;
  }

  static Category createCategory(long id, String name) {
    Category category = new Category();
    category.setId(id);
    category.setName(name);
    return category;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/data/UserData.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;

import java.util.List;
import java.util.ArrayList;

public class UserData {
  static List<User> users = new ArrayList<User>();

  static {
    users.add(createUser(1, "user1", "first name 1", "last name 1",
        "email1@test.com", "123-456-7890", 1));
    users.add(createUser(2, "user2", "first name 2", "last name 2",
        "email2@test.com", "123-456-7890", 2));
    users.add(createUser(3, "user3", "first name 3", "last name 3",
        "email3@test.com", "123-456-7890", 3));
    users.add(createUser(4, "user4", "first name 4", "last name 4",
        "email4@test.com", "123-456-7890", 1));
    users.add(createUser(5, "user5", "first name 5", "last name 5",
        "email5@test.com", "123-456-7890", 2));
    users.add(createUser(6, "user6", "first name 6", "last name 6",
        "email6@test.com", "123-456-7890", 3));
    users.add(createUser(7, "user7", "first name 7", "last name 7",
        "email7@test.com", "123-456-7890", 1));
    users.add(createUser(8, "user8", "first name 8", "last name 8",
        "email8@test.com", "123-456-7890", 2));
    users.add(createUser(9, "user9", "first name 9", "last name 9",
        "email9@test.com", "123-456-7890", 3));
    users.add(createUser(10, "user10", "first name 10", "last name 10",
        "email10@test.com", "123-456-7890", 1));
    users.add(createUser(11, "user?10", "first name ?10", "last name ?10",
        "email101@test.com", "123-456-7890", 1));

  }

  public User findUserByName(String username) {
    for (User user : users) {
      if (user.getUsername().equals(username)) {
        return user;
      }
    }
    return null;
  }

  public void addUser(User user) {
    if (users.size() > 0) {
      for (int i = users.size() - 1; i >= 0; i--) {
        if (users.get(i).getUsername().equals(user.getUsername())) {
          users.remove(i);
        }
      }
    }
    users.add(user);
  }

  public void removeUser(String username) {
    if (users.size() > 0) {
      for (int i = users.size() - 1; i >= 0; i--) {
        if (users.get(i).getUsername().equals(username)) {
          users.remove(i);
        }
      }
    }
  }

  private static User createUser(long id, String username, String firstName,
      String lastName, String email, String phone, int userStatus) {
    User user = new User();
    user.setId(id);
    user.setUsername(username);
    user.setFirstName(firstName);
    user.setLastName(lastName);
    user.setEmail(email);
    user.setPassword("XXXXXXXXXXX");
    user.setPhone(phone);
    user.setUserStatus(userStatus);
    return user;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_279a695_e9ac84a/rev_279a695-e9ac84a/samples/java-jaxrs-no-annotations/src/main/java/com/wordnik/swagger/sample/data/StoreData.java;<<<<<<< MINE
=======
/**
 *  Copyright 2014 Reverb Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;
import java.util.Date;
import java.util.List;
import java.util.ArrayList;

public class StoreData {
  static List<Order> orders = new ArrayList<Order>();

  static {
    orders.add(createOrder(1, 1, 2, new Date(), "placed"));
    orders.add(createOrder(2, 1, 2, new Date(), "delivered"));
    orders.add(createOrder(3, 2, 2, new Date(), "placed"));
    orders.add(createOrder(4, 2, 2, new Date(), "delivered"));
    orders.add(createOrder(5, 3, 2, new Date(), "placed"));
    orders.add(createOrder(11, 3, 2, new Date(), "placed"));
    orders.add(createOrder(12, 3, 2, new Date(), "placed"));
    orders.add(createOrder(13, 3, 2, new Date(), "placed"));
    orders.add(createOrder(14, 3, 2, new Date(), "placed"));
    orders.add(createOrder(15, 3, 2, new Date(), "placed"));
  }

  public Order findOrderById(long orderId) {
    for (Order order : orders) {
      if (order.getId() == orderId) {
        return order;
      }
    }
    return null;
  }

  public void placeOrder(Order order) {
    if (orders.size() > 0) {
      for (int i = orders.size() - 1; i >= 0; i--) {
        if (orders.get(i).getId() == order.getId()) {
          orders.remove(i);
        }
      }
    }
    orders.add(order);
  }

  public void deleteOrder(long orderId) {
    if (orders.size() > 0) {
      for (int i = orders.size() - 1; i >= 0; i--) {
        if (orders.get(i).getId() == orderId) {
          orders.remove(i);
        }
      }
    }
  }

  private static Order createOrder(long id, long petId, int quantity,
      Date shipDate, String status) {
    Order order = new Order();
    order.setId(id);
    order.setPetId(petId);
    order.setQuantity(quantity);
    order.setShipDate(shipDate);
    order.setStatus(status);
    return order;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_f3b170d_2dcdd25/rev_f3b170d-2dcdd25/modules/swagger-annotations/src/main/java/com/wordnik/swagger/annotations/ApiResponse.java;<<<<<<< MINE
 * An ApiResponse represents a type of response from a server.  This can be used to
 * describe both success codes as well as errors.
 * If your Api has different response classes, you can describe them here by associating
 * a response class with a response code.  Note, Swagger does not allow multiple response
 * types for a single response code.
=======
 * Describes a possible response of an operation.
 * <p/>
 * This can be used to describe possible success and error codes from your REST API call.
 * You may or may not use this to describe the return type of the operation (normally a
 * successful code), but the successful response should be described as well using the
 * {@link ApiOperation}.
 * <p/>
 * If your API has uses a different response class for these responses, you can describe them
 * here by associating a response class with a response code.
 * Note, Swagger does not allow multiple response types for a single response code.
 * <p/>
 * This annotation is not used directly and will not be parsed by Swagger. It should be used
 * within the {@link ApiResponses}.
 *
 * @see ApiOperation
 * @see ApiResponses
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_f3b170d_2dcdd25/rev_f3b170d-2dcdd25/modules/swagger-annotations/src/main/java/com/wordnik/swagger/annotations/ApiModelProperty.java;<<<<<<< MINE
   * The dataType. See the documentation for the supported datatypes. If the data type is a custom object, set
   * it's name, or nothing. In case of an enum use 'string' and allowableValues for the enum constants.
=======
   * The data type of the parameter.
   * <p/>
   * This can be the class name or a primitive. The value will override the data type as read from the class
   * property.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/Bootstrap.java;<<<<<<< MINE
package com.wordnik.swagger.sample;

import com.wordnik.swagger.models.Contact;
import com.wordnik.swagger.models.ExternalDocs;
import com.wordnik.swagger.models.Info;
import com.wordnik.swagger.models.License;
import com.wordnik.swagger.models.Swagger;
import com.wordnik.swagger.models.Tag;
import com.wordnik.swagger.models.auth.OAuth2Definition;

import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;

public class Bootstrap extends HttpServlet {

  @Override
  public void init(ServletConfig config) throws ServletException {
    Info info = new Info()
            .title("Swagger Sample App")
            .description("This is a sample server Petstore server.  You can find out more about Swagger " +
                    "at <a href=\"http://swagger.io\">http://swagger.io</a> or on irc.freenode.net, #swagger.  For this sample, " +
                    "you can use the api key \"special-key\" to test the authorization filters")
            .termsOfService("http://helloreverb.com/terms/")
            .contact(new Contact()
                    .email("apiteam@swagger.io"))
            .license(new License()
                    .name("Apache 2.0")
                    .url("http://www.apache.org/licenses/LICENSE-2.0.html"));

    ServletContext context = config.getServletContext();
    Swagger swagger = new Swagger().info(info);
    swagger.securityDefinition("petstore_auth",
            new OAuth2Definition()
                    .implicit("http://localhost:8002/oauth/dialog")
                    .scope("email", "Access to your email address")
                    .scope("pets", "Access to your pets"));
    swagger.tag(new Tag()
            .name("pet")
            .description("Everything about your Pets")
            .externalDocs(new ExternalDocs("Find out more", "http://swagger.io")));
    swagger.tag(new Tag()
            .name("store")
            .description("Access to Petstore orders"));
    swagger.tag(new Tag()
            .name("user")
            .description("Operations about user")
            .externalDocs(new ExternalDocs("Find out more about our store", "http://swagger.io")));
    context.setAttribute("swagger", swagger);
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/resource/SampleExceptionMapper.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resource;

import com.wordnik.swagger.sample.exception.ApiException;
import com.wordnik.swagger.sample.exception.BadRequestException;
import com.wordnik.swagger.sample.exception.NotFoundException;
import com.wordnik.swagger.sample.model.ApiResponse;

import javax.ws.rs.ext.*;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

@Provider
public class SampleExceptionMapper implements ExceptionMapper<Exception> {
  public Response toResponse(Exception exception) {
    if (exception instanceof javax.ws.rs.WebApplicationException) {
      javax.ws.rs.WebApplicationException e = (javax.ws.rs.WebApplicationException) exception;
      return Response
          .status(e.getResponse().getStatus())
          .entity(new ApiResponse(e.getResponse().getStatus(),
              exception.getMessage())).build();
    } else if (exception instanceof com.fasterxml.jackson.core.JsonParseException) {
      return Response.status(400)
          .entity(new ApiResponse(400, "bad input")).build();
    } else if (exception instanceof NotFoundException) {
      return Response
          .status(Status.NOT_FOUND)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof BadRequestException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof ApiException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else {
      return Response.status(500)
          .entity(new ApiResponse(500, "something bad happened"))
          .build();
    }
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/resource/JavaRestResourceUtil.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resource;

import java.text.SimpleDateFormat;

import java.util.Date;

public class JavaRestResourceUtil {
  public int getInt(int minVal, int maxVal, int defaultValue, String inputString) {
    int output = defaultValue;
    try {
      output = Integer.parseInt(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) {
      if (output < minVal) output = minVal;
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public long getLong(long minVal, long maxVal, long defaultValue, String inputString) {
    long output = defaultValue;
    try {
      output = Long.parseLong(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { if (output < minVal) output = minVal; }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public double getDouble(double minVal, double maxVal, double defaultValue, String inputString) {
    double output = defaultValue;
    try {
      output = Double.parseDouble(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { 
      if (output < minVal) output = minVal; 
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public boolean getBoolean(boolean defaultValue, String booleanString) {
    boolean output = defaultValue;
    if (booleanString == null) output = defaultValue;

    //  treat "", "YES" as "true"
    if ("".equals(booleanString)) output = true;
    else if ("YES".equalsIgnoreCase(booleanString)) output = true;
    else if ("NO".equalsIgnoreCase(booleanString)) output = false;
    else {
      try {
        output = Boolean.parseBoolean(booleanString);
      }
      catch (Exception e){
        output = defaultValue;
      }
    }
    return output;
  }
  
  public Date getDate(Date defaultValue, String dateString){
    try {
      return new SimpleDateFormat("yyyy-MM-dd").parse(dateString);
    }
    catch(Exception e) {
      return defaultValue;
    }
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/exception/ApiException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class ApiException extends Exception{
  private int code;
  public ApiException (int code, String msg) {
    super(msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/exception/NotFoundException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class NotFoundException extends ApiException {
  private int code;
  public NotFoundException (int code, String msg) {
    super(code, msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/exception/BadRequestException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class BadRequestException extends ApiException{
  private int code;
  public BadRequestException (int code, String msg) {
    super(code, msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/PetStoreApplication.java;<<<<<<< MINE
package com.wordnik.swagger.sample;

import com.wordnik.swagger.sample.resource.PetResource;
import com.wordnik.swagger.sample.resource.PetStoreResource;
import com.wordnik.swagger.sample.resource.UserResource;

import javax.ws.rs.core.Application;
import java.util.HashSet;
import java.util.Set;

public class PetStoreApplication extends Application {
    HashSet<Object> singletons = new HashSet<Object>();

    public PetStoreApplication() {
    }

    @Override
    public Set<Class<?>> getClasses() {
        HashSet<Class<?>> set = new HashSet<Class<?>>();

        set.add(PetResource.class);
        set.add(UserResource.class);
        set.add(PetStoreResource.class);

        set.add(com.wordnik.swagger.jaxrs.listing.ApiListingResource.class);
        set.add(com.wordnik.swagger.jaxrs.listing.SwaggerSerializers.class);

        return set;
    }

    @Override
    public Set<Object> getSingletons() {
        return singletons;
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/model/ApiResponse.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.XmlTransient;

@javax.xml.bind.annotation.XmlRootElement
public class ApiResponse {
  public static final int ERROR = 1;
  public static final int WARNING = 2;
  public static final int INFO = 3;
  public static final int OK = 4;
  public static final int TOO_BUSY = 5;

  int code;
  String type;
  String message;
  
  public ApiResponse(){}
  
  public ApiResponse(int code, String message){
    this.code = code;
    switch(code){
    case ERROR:
      setType("error");
      break;
    case WARNING:
      setType("warning");
      break;
    case INFO:
      setType("info");
      break;
    case OK:
      setType("ok");
      break;
    case TOO_BUSY:
      setType("too busy");
      break;
    default:
      setType("unknown");
      break;
    }
    this.message = message;
  }

  @XmlTransient
  public int getCode() {
    return code;
  }

  public void setCode(int code) {
    this.code = code;
  }

  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/model/Pet.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import java.util.List;
import java.util.ArrayList;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Pet")
public class Pet {
  private long id;
  private Category category;
  private String name;
  private List<String> photoUrls = new ArrayList<String>();
  private List<Tag> tags = new ArrayList<Tag>();
  private String status;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "category")
  public Category getCategory() {
    return category;
  }

  public void setCategory(Category category) {
    this.category = category;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  @XmlElementWrapper(name = "photoUrls")
  @XmlElement(name = "photoUrl")
  public List<String> getPhotoUrls() {
    return photoUrls;
  }

  public void setPhotoUrls(List<String> photoUrls) {
    this.photoUrls = photoUrls;
  }

  @XmlElementWrapper(name = "tags")
  @XmlElement(name = "tag")
  public List<Tag> getTags() {
    return tags;
  }

  public void setTags(List<Tag> tags) {
    this.tags = tags;
  }

  @XmlElement(name = "status")
  @ApiModelProperty(value = "pet status in the store", allowableValues = "available,pending,sold")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/model/Order.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import java.util.Date;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Order")
public class Order {
  private long id;
  private long petId;
  private int quantity;
  private Date shipDate;
  private String status;
    private boolean complete;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

    public boolean isComplete() {
        return complete;
    }

    public void setComplete(boolean complete) {
        this.complete = complete;
    }


  @XmlElement(name = "petId")
  public long getPetId() {
    return petId;
  }

  public void setPetId(long petId) {
    this.petId = petId;
  }

  @XmlElement(name = "quantity")
  public int getQuantity() {
    return quantity;
  }

  public void setQuantity(int quantity) {
    this.quantity = quantity;
  }

  @XmlElement(name = "status")
  @ApiModelProperty(value = "Order Status", allowableValues = "placed, approved, delivered")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }

  @XmlElement(name = "shipDate")
  public Date getShipDate() {
    return shipDate;
  }

  public void setShipDate(Date shipDate) {
    this.shipDate = shipDate;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/model/User.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "User")
public class User {
  private long id;
  private String username;
  private String firstName;
  private String lastName;
  private String email;
  private String password;
  private String phone;
  private int userStatus;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "firstName")
  public String getFirstName() {
    return firstName;
  }

  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }

  @XmlElement(name = "username")
  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  @XmlElement(name = "lastName")
  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }

  @XmlElement(name = "email")
  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  @XmlElement(name = "password")
  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  @XmlElement(name = "phone")
  public String getPhone() {
    return phone;
  }

  public void setPhone(String phone) {
    this.phone = phone;
  }

  @XmlElement(name = "userStatus")
  @ApiModelProperty(value = "User Status", allowableValues = "1-registered,2-active,3-closed")
  public int getUserStatus() {
    return userStatus;
  }

  public void setUserStatus(int userStatus) {
    this.userStatus = userStatus;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/model/Tag.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Tag")
public class Tag {
  private long id;
  private String name;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/model/Category.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Category")
public class Category {
  private long id;
  private String name;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/util/ApiAuthorizationFilterImpl.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import com.wordnik.swagger.model.*;
import com.wordnik.swagger.core.filter.SwaggerSpecFilter;

import com.wordnik.swagger.models.Model;
import com.wordnik.swagger.models.Operation;
import com.wordnik.swagger.models.parameters.Parameter;
import com.wordnik.swagger.models.properties.Property;
import org.slf4j.*;

import java.util.Map;
import java.util.List;

import javax.servlet.ServletConfig;
import javax.servlet.http.HttpServlet;
/**
 * 
 * The rules are maintained in simple map with key as path and a boolean value
 * indicating given path is secure or not. For method level security the key is
 * combination of http method and path .
 * 
 * If the resource or method is secure then it can only be viewed using a
 * secured api key
 * 
 * Note: Objective of this class is not to provide fully functional
 * implementation of authorization filter. This is only a sample demonstration
 * how API authorization filter works.
 * 
 */

public class ApiAuthorizationFilterImpl implements SwaggerSpecFilter {
  static Logger logger = LoggerFactory.getLogger(ApiAuthorizationFilterImpl.class);

  public boolean isOperationAllowed(Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if(isAuthorized) {
      return true;
    }
    else {
      if(!"GET".equalsIgnoreCase(api.getMethod()) || api.getPath().indexOf("/store") != -1) {
        return false;
      }
      else return true;
    }
  }

  public boolean isParamAllowed(Parameter parameter, Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if("internal".equals(parameter.getAccess()) && !isAuthorized)
      return false;
    else
      return true;
  }

  @Override
  public boolean isPropertyAllowed(Model model, Property property, String propertyName, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    return true;
  }

  public boolean checkKey(Map<String, List<String>> params, Map<String, List<String>> headers) {
    String keyValue = null;
    if(params.containsKey("api_key"))
      keyValue = params.get("api_key").get(0);
    else {
      if(headers.containsKey("api_key"))
        keyValue = headers.get("api_key").get(0);
    }
    if("special-key".equals(keyValue))
      return true;
    else
      return false;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/util/ApiOriginFilter.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import java.io.IOException;

import javax.servlet.*;
import javax.servlet.http.HttpServletResponse;

public class ApiOriginFilter implements javax.servlet.Filter {
  @Override
  public void doFilter(ServletRequest request, ServletResponse response,
      FilterChain chain) throws IOException, ServletException {
    HttpServletResponse res = (HttpServletResponse) response;
    res.addHeader("Access-Control-Allow-Origin", "*");
    res.addHeader("Access-Control-Allow-Methods", "GET, POST, DELETE, PUT");
    res.addHeader("Access-Control-Allow-Headers", "Content-Type");
    chain.doFilter(request, response);
  }

  @Override
  public void destroy() {
  }

  @Override
  public void init(FilterConfig filterConfig) throws ServletException {
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/data/PetData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;

import java.util.List;
import java.util.ArrayList;

public class PetData {
  static List<Pet> pets = new ArrayList<Pet>();
  static List<Category> categories = new ArrayList<Category>();

  static {
    categories.add(createCategory(1, "Dogs"));
    categories.add(createCategory(2, "Cats"));
    categories.add(createCategory(3, "Rabbits"));
    categories.add(createCategory(4, "Lions"));

    pets.add(createPet(1, categories.get(1), "Cat 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(2, categories.get(1), "Cat 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
    pets.add(createPet(3, categories.get(1), "Cat 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

    pets.add(createPet(4, categories.get(0), "Dog 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(5, categories.get(0), "Dog 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "sold"));
    pets.add(createPet(6, categories.get(0), "Dog 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

    pets.add(createPet(7, categories.get(3), "Lion 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(8, categories.get(3), "Lion 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
    pets.add(createPet(9, categories.get(3), "Lion 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));

    pets.add(createPet(10, categories.get(2), "Rabbit 1", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));
  }

  public Pet getPetbyId(long petId) {
    for (Pet pet : pets) {
      if (pet.getId() == petId) {
        return pet;
      }
    }
    return null;
  }

  public List<Pet> findPetByStatus(String status) {
    String[] statues = status.split(",");
    List<Pet> result = new java.util.ArrayList<Pet>();
    for (Pet pet : pets) {
      for (String s : statues) {
        if (s.equals(pet.getStatus())) {
          result.add(pet);
        }
      }
    }
    return result;
  }

  public List<Pet> findPetByTags(String tags) {
    String[] tagList = tags.split(",");
    List<Pet> result = new java.util.ArrayList<Pet>();
    for (Pet pet : pets) {
      if (null != pet.getTags()) {
        for (Tag tag : pet.getTags()) {
          for (String tagListString : tagList) {
            if (tagListString.equals(tag.getName()))
              result.add(pet);
          }
        }
      }
    }
    return result;
  }

  public void addPet(Pet pet) {
    if (pets.size() > 0) {
      for (int i = pets.size() - 1; i >= 0; i--) {
        if (pets.get(i).getId() == pet.getId()) {
          pets.remove(i);
        }
      }
    }
    pets.add(pet);
  }

  static Pet createPet(long id, Category cat, String name, String[] urls,
      String[] tags, String status) {
    Pet pet = new Pet();
    pet.setId(id);
    pet.setCategory(cat);
    pet.setName(name);
    if (null != urls) {
      List<String> urlObjs = new ArrayList<String>();
      for (String urlString : urls) {
        urlObjs.add(urlString);
      }
      pet.setPhotoUrls(urlObjs);
    }
    List<Tag> tagObjs = new java.util.ArrayList<Tag>();
    int i = 0;
    if (null != tags) {
      for (String tagString : tags) {
        i = i + 1;
        Tag tag = new Tag();
        tag.setId(i);
        tag.setName(tagString);
        tagObjs.add(tag);
      }
    }
    pet.setTags(tagObjs);
    pet.setStatus(status);
    return pet;
  }

  static Category createCategory(long id, String name) {
    Category category = new Category();
    category.setId(id);
    category.setName(name);
    return category;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/data/UserData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;

import java.util.List;
import java.util.ArrayList;

public class UserData {
  static List<User> users = new ArrayList<User>();

  static {
    users.add(createUser(1, "user1", "first name 1", "last name 1",
        "email1@test.com", "123-456-7890", 1));
    users.add(createUser(2, "user2", "first name 2", "last name 2",
        "email2@test.com", "123-456-7890", 2));
    users.add(createUser(3, "user3", "first name 3", "last name 3",
        "email3@test.com", "123-456-7890", 3));
    users.add(createUser(4, "user4", "first name 4", "last name 4",
        "email4@test.com", "123-456-7890", 1));
    users.add(createUser(5, "user5", "first name 5", "last name 5",
        "email5@test.com", "123-456-7890", 2));
    users.add(createUser(6, "user6", "first name 6", "last name 6",
        "email6@test.com", "123-456-7890", 3));
    users.add(createUser(7, "user7", "first name 7", "last name 7",
        "email7@test.com", "123-456-7890", 1));
    users.add(createUser(8, "user8", "first name 8", "last name 8",
        "email8@test.com", "123-456-7890", 2));
    users.add(createUser(9, "user9", "first name 9", "last name 9",
        "email9@test.com", "123-456-7890", 3));
    users.add(createUser(10, "user10", "first name 10", "last name 10",
        "email10@test.com", "123-456-7890", 1));
    users.add(createUser(11, "user?10", "first name ?10", "last name ?10",
        "email101@test.com", "123-456-7890", 1));

  }

  public User findUserByName(String username) {
    for (User user : users) {
      if (user.getUsername().equals(username)) {
        return user;
      }
    }
    return null;
  }

  public void addUser(User user) {
    if (users.size() > 0) {
      for (int i = users.size() - 1; i >= 0; i--) {
        if (users.get(i).getUsername().equals(user.getUsername())) {
          users.remove(i);
        }
      }
    }
    users.add(user);
  }

  public void removeUser(String username) {
    if (users.size() > 0) {
      for (int i = users.size() - 1; i >= 0; i--) {
        if (users.get(i).getUsername().equals(username)) {
          users.remove(i);
        }
      }
    }
  }

  private static User createUser(long id, String username, String firstName,
      String lastName, String email, String phone, int userStatus) {
    User user = new User();
    user.setId(id);
    user.setUsername(username);
    user.setFirstName(firstName);
    user.setLastName(lastName);
    user.setEmail(email);
    user.setPassword("XXXXXXXXXXX");
    user.setPhone(phone);
    user.setUserStatus(userStatus);
    return user;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy/src/main/java/com/wordnik/swagger/sample/data/StoreData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;
import java.util.Date;
import java.util.List;
import java.util.ArrayList;

public class StoreData {
  static List<Order> orders = new ArrayList<Order>();

  static {
    orders.add(createOrder(1, 1, 2, new Date(), "placed"));
    orders.add(createOrder(2, 1, 2, new Date(), "delivered"));
    orders.add(createOrder(3, 2, 2, new Date(), "placed"));
    orders.add(createOrder(4, 2, 2, new Date(), "delivered"));
    orders.add(createOrder(5, 3, 2, new Date(), "placed"));
    orders.add(createOrder(11, 3, 2, new Date(), "placed"));
    orders.add(createOrder(12, 3, 2, new Date(), "placed"));
    orders.add(createOrder(13, 3, 2, new Date(), "placed"));
    orders.add(createOrder(14, 3, 2, new Date(), "placed"));
    orders.add(createOrder(15, 3, 2, new Date(), "placed"));
  }

  public Order findOrderById(long orderId) {
    for (Order order : orders) {
      if (order.getId() == orderId) {
        return order;
      }
    }
    return null;
  }

  public void placeOrder(Order order) {
    if (orders.size() > 0) {
      for (int i = orders.size() - 1; i >= 0; i--) {
        if (orders.get(i).getId() == order.getId()) {
          orders.remove(i);
        }
      }
    }
    orders.add(order);
  }

  public void deleteOrder(long orderId) {
    if (orders.size() > 0) {
      for (int i = orders.size() - 1; i >= 0; i--) {
        if (orders.get(i).getId() == orderId) {
          orders.remove(i);
        }
      }
    }
  }

  private static Order createOrder(long id, long petId, int quantity,
      Date shipDate, String status) {
    Order order = new Order();
    order.setId(id);
    order.setPetId(petId);
    order.setQuantity(quantity);
    order.setShipDate(shipDate);
    order.setStatus(status);
    return order;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/Bootstrap.java;<<<<<<< MINE
package com.wordnik.swagger.sample;

import com.wordnik.swagger.models.*;

import com.wordnik.swagger.models.auth.*;

import javax.servlet.http.HttpServlet;
import javax.servlet.ServletContext;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;

public class Bootstrap extends HttpServlet {

  @Override
  public void init(ServletConfig config) throws ServletException {
    Info info = new Info()
      .title("Swagger Sample App")
      .description("This is a sample server Petstore server.  You can find out more about Swagger " +
        "at <a href=\"http://swagger.io\">http://swagger.io</a> or on irc.freenode.net, #swagger.  For this sample, " +
        "you can use the api key \"special-key\" to test the authorization filters")
      .termsOfService("http://helloreverb.com/terms/")
      .contact(new Contact()
        .email("apiteam@swagger.io"))
      .license(new License()
        .name("Apache 2.0")
        .url("http://www.apache.org/licenses/LICENSE-2.0.html"));

    ServletContext context = config.getServletContext();
    Swagger swagger = new Swagger().info(info);
    swagger.securityDefinition("api_key", new ApiKeyAuthDefinition("api_key", In.HEADER));
    swagger.securityDefinition("petstore_auth",
      new OAuth2Definition()
        .implicit("http://localhost:8002/oauth/dialog")
        .scope("email", "Access to your email address")
        .scope("pets", "Access to your pets"));
    swagger.tag(new Tag()
            .name("pet")
            .description("Everything about your Pets")
            .externalDocs(new ExternalDocs("Find out more", "http://swagger.io")));
    swagger.tag(new Tag()
            .name("store")
            .description("Access to Petstore orders"));
    swagger.tag(new Tag()
            .name("user")
            .description("Operations about user")
            .externalDocs(new ExternalDocs("Find out more about our store", "http://swagger.io")));
    context.setAttribute("swagger", swagger);
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/exception/ApiException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class ApiException extends Exception{
  private int code;
  public ApiException (int code, String msg) {
    super(msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/exception/NotFoundException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class NotFoundException extends ApiException {
  private int code;
  public NotFoundException (int code, String msg) {
    super(code, msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/exception/BadRequestException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class BadRequestException extends ApiException{
  private int code;
  public BadRequestException (int code, String msg) {
    super(code, msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/model/ApiResponse.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.XmlTransient;

@javax.xml.bind.annotation.XmlRootElement
public class ApiResponse {
  public static final int ERROR = 1;
  public static final int WARNING = 2;
  public static final int INFO = 3;
  public static final int OK = 4;
  public static final int TOO_BUSY = 5;

  int code;
  String type;
  String message;
  
  public ApiResponse(){}
  
  public ApiResponse(int code, String message){
    this.code = code;
    switch(code){
    case ERROR:
      setType("error");
      break;
    case WARNING:
      setType("warning");
      break;
    case INFO:
      setType("info");
      break;
    case OK:
      setType("ok");
      break;
    case TOO_BUSY:
      setType("too busy");
      break;
    default:
      setType("unknown");
      break;
    }
    this.message = message;
  }

  @XmlTransient
  public int getCode() {
    return code;
  }

  public void setCode(int code) {
    this.code = code;
  }

  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/model/Pet.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import java.util.List;
import java.util.ArrayList;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Pet")
public class Pet {
  private long id;
  private Category category;
  private String name;
  private List<String> photoUrls = new ArrayList<String>();
  private List<Tag> tags = new ArrayList<Tag>();
  private String status;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "category")
  public Category getCategory() {
    return category;
  }

  public void setCategory(Category category) {
    this.category = category;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  @XmlElementWrapper(name = "photoUrls")
  @XmlElement(name = "photoUrl")
  public List<String> getPhotoUrls() {
    return photoUrls;
  }

  public void setPhotoUrls(List<String> photoUrls) {
    this.photoUrls = photoUrls;
  }

  @XmlElementWrapper(name = "tags")
  @XmlElement(name = "tag")
  public List<Tag> getTags() {
    return tags;
  }

  public void setTags(List<Tag> tags) {
    this.tags = tags;
  }

  @XmlElement(name = "status")
  @ApiModelProperty(value = "pet status in the store", allowableValues = "available,pending,sold")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/model/Order.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import java.util.Date;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Order")
public class Order {
  private long id;
  private long petId;
  private int quantity;
  private Date shipDate;
  private String status;
    private boolean complete;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

    public boolean isComplete() {
        return complete;
    }

    public void setComplete(boolean complete) {
        this.complete = complete;
    }


  @XmlElement(name = "petId")
  public long getPetId() {
    return petId;
  }

  public void setPetId(long petId) {
    this.petId = petId;
  }

  @XmlElement(name = "quantity")
  public int getQuantity() {
    return quantity;
  }

  public void setQuantity(int quantity) {
    this.quantity = quantity;
  }

  @XmlElement(name = "status")
  @ApiModelProperty(value = "Order Status", allowableValues = "placed, approved, delivered")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }

  @XmlElement(name = "shipDate")
  public Date getShipDate() {
    return shipDate;
  }

  public void setShipDate(Date shipDate) {
    this.shipDate = shipDate;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/model/User.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "User")
public class User {
  private long id;
  private String username;
  private String firstName;
  private String lastName;
  private String email;
  private String password;
  private String phone;
  private int userStatus;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "firstName")
  public String getFirstName() {
    return firstName;
  }

  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }

  @XmlElement(name = "username")
  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  @XmlElement(name = "lastName")
  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }

  @XmlElement(name = "email")
  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  @XmlElement(name = "password")
  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  @XmlElement(name = "phone")
  public String getPhone() {
    return phone;
  }

  public void setPhone(String phone) {
    this.phone = phone;
  }

  @XmlElement(name = "userStatus")
  @ApiModelProperty(value = "User Status", allowableValues = "1-registered,2-active,3-closed")
  public int getUserStatus() {
    return userStatus;
  }

  public void setUserStatus(int userStatus) {
    this.userStatus = userStatus;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/model/Tag.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Tag")
public class Tag {
  private long id;
  private String name;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/model/Category.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Category")
public class Category {
  private long id;
  private String name;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/bean/UserResourceBean.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.bean;

import com.wordnik.swagger.annotations.*;
import com.wordnik.swagger.sample.data.UserData;
import com.wordnik.swagger.sample.model.User;
import com.wordnik.swagger.sample.exception.ApiException;
import com.wordnik.swagger.sample.exception.NotFoundException;
import com.wordnik.swagger.sample.resource.UserResource;
import org.springframework.stereotype.Component;

import javax.ws.rs.core.Response;
import javax.ws.rs.*;

@Component
public class UserResourceBean implements UserResource {
  static UserData userData = new UserData();

  @Override
  public Response createUser(User user) {
    userData.addUser(user);
    return Response.ok().entity("").build();
  }

  @Override
  public Response createUsersWithArrayInput(User[] users) {
      for (User user : users) {
          userData.addUser(user);
      }
      return Response.ok().entity("").build();
  }

  @Override
  public Response createUsersWithListInput(java.util.List<User> users) {
      for (User user : users) {
          userData.addUser(user);
      }
      return Response.ok().entity("").build();
  }

  @Override
  public Response updateUser(String username, User user) {
    userData.addUser(user);
    return Response.ok().entity("").build();
  }

  @Override
  public Response deleteUser(String username) {
    userData.removeUser(username);
    return Response.ok().entity("").build();
  }

  @Override
  public Response getUserByName(String username)
    throws ApiException {
    User user = userData.findUserByName(username);
    if (null != user) {
      return Response.ok().entity(user).build();
    } else {
      throw new NotFoundException(404, "User not found");
    }
  }

  @Override
  public Response loginUser(String username, String password) {
    return Response.ok()
        .entity("logged in user session:" + System.currentTimeMillis())
        .build();
  }

  @Override
  public Response logoutUser() {
    return Response.ok().entity("").build();
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/bean/SampleExceptionMapper.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.bean;

import com.wordnik.swagger.sample.exception.ApiException;
import com.wordnik.swagger.sample.exception.BadRequestException;
import com.wordnik.swagger.sample.exception.NotFoundException;
import com.wordnik.swagger.sample.model.ApiResponse;

import javax.ws.rs.ext.*;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

@Provider
public class SampleExceptionMapper implements ExceptionMapper<Exception> {
  public Response toResponse(Exception exception) {
    if (exception instanceof javax.ws.rs.WebApplicationException) {
      javax.ws.rs.WebApplicationException e = (javax.ws.rs.WebApplicationException) exception;
      return Response
          .status(e.getResponse().getStatus())
          .entity(new ApiResponse(e.getResponse().getStatus(),
              exception.getMessage())).build();
    } else if (exception instanceof com.fasterxml.jackson.core.JsonParseException) {
      return Response.status(400)
          .entity(new ApiResponse(400, "bad input")).build();
    } else if (exception instanceof NotFoundException) {
      return Response
          .status(Status.NOT_FOUND)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof BadRequestException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof ApiException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else {
      return Response.status(500)
          .entity(new ApiResponse(500, "something bad happened"))
          .build();
    }
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/bean/PetStoreResourceBean.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.bean;

import com.wordnik.swagger.annotations.*;
import com.wordnik.swagger.sample.data.StoreData;
import com.wordnik.swagger.sample.model.Order;
import com.wordnik.swagger.sample.exception.NotFoundException;
import com.wordnik.swagger.sample.resource.PetStoreResource;
import org.springframework.stereotype.Component;

import javax.ws.rs.core.Response;
import javax.ws.rs.*;

@Component
public class PetStoreResourceBean implements PetStoreResource {
  static StoreData storeData = new StoreData();
  static JavaRestResourceUtil ru = new JavaRestResourceUtil();

  @Override
  public Response getOrderById(String orderId) throws NotFoundException {
    Order order = storeData.findOrderById(ru.getLong(0, 10000, 0, orderId));
    if (null != order) {
      return Response.ok().entity(order).build();
    } else {
      throw new NotFoundException(404, "Order not found");
    }
  }

  @Override
  public Response placeOrder(Order order) {
    storeData.placeOrder(order);
    return Response.ok().entity("").build();
  }

  @Override
  public Response deleteOrder(String orderId) {
    storeData.deleteOrder(ru.getLong(0, 10000, 0, orderId));
    return Response.ok().entity("").build();
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/bean/PetResourceBean.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.bean;

import com.wordnik.swagger.sample.data.PetData;
import com.wordnik.swagger.sample.model.Pet;
import com.wordnik.swagger.sample.exception.NotFoundException;
import com.wordnik.swagger.sample.resource.PetResource;
import org.springframework.stereotype.Component;

import javax.ws.rs.core.Response;
import javax.ws.rs.*;

@Component
public class PetResourceBean implements PetResource {
    static PetData petData = new PetData();
    static JavaRestResourceUtil ru = new JavaRestResourceUtil();

    @Override
    public Pet getPetById(String petId) throws NotFoundException {
        Pet pet = petData.getPetbyId(ru.getLong(0, 100000, 0, petId));
        if (null != pet) {
            return pet;
        } else {
            throw new NotFoundException(404, "Pet not found");
        }
    }

    @Override
    public Response addPet(Pet pet) {
        petData.addPet(pet);
        return Response.ok().entity("SUCCESS").build();
    }

    @Override
    public Response updatePet(Pet pet) {
        petData.addPet(pet);
        return Response.ok().entity("SUCCESS").build();
    }

    @Override
    public Response findPetsByStatus(String status) {
        return Response.ok(petData.findPetByStatus(status)).build();
    }

    @Override
    @Deprecated
    public Response findPetsByTags(String tags) {
        return Response.ok(petData.findPetByTags(tags)).build();
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/bean/JavaRestResourceUtil.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.bean;

import java.text.SimpleDateFormat;

import java.util.Date;

public class JavaRestResourceUtil {
  public int getInt(int minVal, int maxVal, int defaultValue, String inputString) {
    int output = defaultValue;
    try {
      output = Integer.parseInt(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) {
      if (output < minVal) output = minVal;
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public long getLong(long minVal, long maxVal, long defaultValue, String inputString) {
    long output = defaultValue;
    try {
      output = Long.parseLong(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { if (output < minVal) output = minVal; }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public double getDouble(double minVal, double maxVal, double defaultValue, String inputString) {
    double output = defaultValue;
    try {
      output = Double.parseDouble(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { 
      if (output < minVal) output = minVal; 
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public boolean getBoolean(boolean defaultValue, String booleanString) {
    boolean output = defaultValue;
    if (booleanString == null) output = defaultValue;

    //  treat "", "YES" as "true"
    if ("".equals(booleanString)) output = true;
    else if ("YES".equalsIgnoreCase(booleanString)) output = true;
    else if ("NO".equalsIgnoreCase(booleanString)) output = false;
    else {
      try {
        output = Boolean.parseBoolean(booleanString);
      }
      catch (Exception e){
        output = defaultValue;
      }
    }
    return output;
  }
  
  public Date getDate(Date defaultValue, String dateString){
    try {
      return new SimpleDateFormat("yyyy-MM-dd").parse(dateString);
    }
    catch(Exception e) {
      return defaultValue;
    }
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/util/ApiAuthorizationFilterImpl.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import com.wordnik.swagger.model.*;
import com.wordnik.swagger.core.filter.SwaggerSpecFilter;

import com.wordnik.swagger.models.Model;
import com.wordnik.swagger.models.Operation;
import com.wordnik.swagger.models.parameters.Parameter;
import com.wordnik.swagger.models.properties.Property;
import org.slf4j.*;

import java.util.Map;
import java.util.List;

import javax.servlet.ServletConfig;
import javax.servlet.http.HttpServlet;
/**
 * 
 * The rules are maintained in simple map with key as path and a boolean value
 * indicating given path is secure or not. For method level security the key is
 * combination of http method and path .
 * 
 * If the resource or method is secure then it can only be viewed using a
 * secured api key
 * 
 * Note: Objective of this class is not to provide fully functional
 * implementation of authorization filter. This is only a sample demonstration
 * how API authorization filter works.
 * 
 */

public class ApiAuthorizationFilterImpl implements SwaggerSpecFilter {
  static Logger logger = LoggerFactory.getLogger(ApiAuthorizationFilterImpl.class);

  public boolean isOperationAllowed(Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if(isAuthorized) {
      return true;
    }
    else {
      if(!"GET".equalsIgnoreCase(api.getMethod()) || api.getPath().indexOf("/store") != -1) {
        return false;
      }
      else return true;
    }
  }

  public boolean isParamAllowed(Parameter parameter, Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if("internal".equals(parameter.getAccess()) && !isAuthorized)
      return false;
    else 
      return true;
  }

  @Override
  public boolean isPropertyAllowed(Model model, Property property, String propertyName, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    return true;
  }

  public boolean checkKey(Map<String, List<String>> params, Map<String, List<String>> headers) {
    String keyValue = null;
    if(params.containsKey("api_key"))
      keyValue = params.get("api_key").get(0);
    else {
      if(headers.containsKey("api_key"))
        keyValue = headers.get("api_key").get(0);
    }
    if("special-key".equals(keyValue))
      return true;
    else
      return false;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/data/PetData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;

import java.util.List;
import java.util.ArrayList;

public class PetData {
  static List<Pet> pets = new ArrayList<Pet>();
  static List<Category> categories = new ArrayList<Category>();

  static {
    categories.add(createCategory(1, "Dogs"));
    categories.add(createCategory(2, "Cats"));
    categories.add(createCategory(3, "Rabbits"));
    categories.add(createCategory(4, "Lions"));

    pets.add(createPet(1, categories.get(1), "Cat 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(2, categories.get(1), "Cat 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
    pets.add(createPet(3, categories.get(1), "Cat 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

    pets.add(createPet(4, categories.get(0), "Dog 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(5, categories.get(0), "Dog 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "sold"));
    pets.add(createPet(6, categories.get(0), "Dog 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

    pets.add(createPet(7, categories.get(3), "Lion 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(8, categories.get(3), "Lion 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
    pets.add(createPet(9, categories.get(3), "Lion 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));

    pets.add(createPet(10, categories.get(2), "Rabbit 1", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));
  }

  public Pet getPetbyId(long petId) {
    for (Pet pet : pets) {
      if (pet.getId() == petId) {
        return pet;
      }
    }
    return null;
  }

  public List<Pet> findPetByStatus(String status) {
    String[] statues = status.split(",");
    List<Pet> result = new java.util.ArrayList<Pet>();
    for (Pet pet : pets) {
      for (String s : statues) {
        if (s.equals(pet.getStatus())) {
          result.add(pet);
        }
      }
    }
    return result;
  }

  public List<Pet> findPetByTags(String tags) {
    String[] tagList = tags.split(",");
    List<Pet> result = new java.util.ArrayList<Pet>();
    for (Pet pet : pets) {
      if (null != pet.getTags()) {
        for (Tag tag : pet.getTags()) {
          for (String tagListString : tagList) {
            if (tagListString.equals(tag.getName()))
              result.add(pet);
          }
        }
      }
    }
    return result;
  }

  public void addPet(Pet pet) {
    if (pets.size() > 0) {
      for (int i = pets.size() - 1; i >= 0; i--) {
        if (pets.get(i).getId() == pet.getId()) {
          pets.remove(i);
        }
      }
    }
    pets.add(pet);
  }

  static Pet createPet(long id, Category cat, String name, String[] urls,
      String[] tags, String status) {
    Pet pet = new Pet();
    pet.setId(id);
    pet.setCategory(cat);
    pet.setName(name);
    if (null != urls) {
      List<String> urlObjs = new ArrayList<String>();
      for (String urlString : urls) {
        urlObjs.add(urlString);
      }
      pet.setPhotoUrls(urlObjs);
    }
    List<Tag> tagObjs = new java.util.ArrayList<Tag>();
    int i = 0;
    if (null != tags) {
      for (String tagString : tags) {
        i = i + 1;
        Tag tag = new Tag();
        tag.setId(i);
        tag.setName(tagString);
        tagObjs.add(tag);
      }
    }
    pet.setTags(tagObjs);
    pet.setStatus(status);
    return pet;
  }

  static Category createCategory(long id, String name) {
    Category category = new Category();
    category.setId(id);
    category.setName(name);
    return category;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/data/UserData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;

import java.util.List;
import java.util.ArrayList;

public class UserData {
  static List<User> users = new ArrayList<User>();

  static {
    users.add(createUser(1, "user1", "first name 1", "last name 1",
        "email1@test.com", "123-456-7890", 1));
    users.add(createUser(2, "user2", "first name 2", "last name 2",
        "email2@test.com", "123-456-7890", 2));
    users.add(createUser(3, "user3", "first name 3", "last name 3",
        "email3@test.com", "123-456-7890", 3));
    users.add(createUser(4, "user4", "first name 4", "last name 4",
        "email4@test.com", "123-456-7890", 1));
    users.add(createUser(5, "user5", "first name 5", "last name 5",
        "email5@test.com", "123-456-7890", 2));
    users.add(createUser(6, "user6", "first name 6", "last name 6",
        "email6@test.com", "123-456-7890", 3));
    users.add(createUser(7, "user7", "first name 7", "last name 7",
        "email7@test.com", "123-456-7890", 1));
    users.add(createUser(8, "user8", "first name 8", "last name 8",
        "email8@test.com", "123-456-7890", 2));
    users.add(createUser(9, "user9", "first name 9", "last name 9",
        "email9@test.com", "123-456-7890", 3));
    users.add(createUser(10, "user10", "first name 10", "last name 10",
        "email10@test.com", "123-456-7890", 1));
    users.add(createUser(11, "user?10", "first name ?10", "last name ?10",
        "email101@test.com", "123-456-7890", 1));

  }

  public User findUserByName(String username) {
    for (User user : users) {
      if (user.getUsername().equals(username)) {
        return user;
      }
    }
    return null;
  }

  public void addUser(User user) {
    if (users.size() > 0) {
      for (int i = users.size() - 1; i >= 0; i--) {
        if (users.get(i).getUsername().equals(user.getUsername())) {
          users.remove(i);
        }
      }
    }
    users.add(user);
  }

  public void removeUser(String username) {
    if (users.size() > 0) {
      for (int i = users.size() - 1; i >= 0; i--) {
        if (users.get(i).getUsername().equals(username)) {
          users.remove(i);
        }
      }
    }
  }

  private static User createUser(long id, String username, String firstName,
      String lastName, String email, String phone, int userStatus) {
    User user = new User();
    user.setId(id);
    user.setUsername(username);
    user.setFirstName(firstName);
    user.setLastName(lastName);
    user.setEmail(email);
    user.setPassword("XXXXXXXXXXX");
    user.setPhone(phone);
    user.setUserStatus(userStatus);
    return user;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jersey-spring/src/main/java/com/wordnik/swagger/sample/data/StoreData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;
import java.util.Date;
import java.util.List;
import java.util.ArrayList;

public class StoreData {
  static List<Order> orders = new ArrayList<Order>();

  static {
    orders.add(createOrder(1, 1, 2, new Date(), "placed"));
    orders.add(createOrder(2, 1, 2, new Date(), "delivered"));
    orders.add(createOrder(3, 2, 2, new Date(), "placed"));
    orders.add(createOrder(4, 2, 2, new Date(), "delivered"));
    orders.add(createOrder(5, 3, 2, new Date(), "placed"));
    orders.add(createOrder(11, 3, 2, new Date(), "placed"));
    orders.add(createOrder(12, 3, 2, new Date(), "placed"));
    orders.add(createOrder(13, 3, 2, new Date(), "placed"));
    orders.add(createOrder(14, 3, 2, new Date(), "placed"));
    orders.add(createOrder(15, 3, 2, new Date(), "placed"));
  }

  public Order findOrderById(long orderId) {
    for (Order order : orders) {
      if (order.getId() == orderId) {
        return order;
      }
    }
    return null;
  }

  public void placeOrder(Order order) {
    if (orders.size() > 0) {
      for (int i = orders.size() - 1; i >= 0; i--) {
        if (orders.get(i).getId() == order.getId()) {
          orders.remove(i);
        }
      }
    }
    orders.add(order);
  }

  public void deleteOrder(long orderId) {
    if (orders.size() > 0) {
      for (int i = orders.size() - 1; i >= 0; i--) {
        if (orders.get(i).getId() == orderId) {
          orders.remove(i);
        }
      }
    }
  }

  private static Order createOrder(long id, long petId, int quantity,
      Date shipDate, String status) {
    Order order = new Order();
    order.setId(id);
    order.setPetId(petId);
    order.setQuantity(quantity);
    order.setShipDate(shipDate);
    order.setStatus(status);
    return order;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/Bootstrap.java;<<<<<<< MINE
package com.wordnik.swagger.sample;


import com.wordnik.swagger.models.Contact;
import com.wordnik.swagger.models.ExternalDocs;
import com.wordnik.swagger.models.Info;
import com.wordnik.swagger.models.License;
import com.wordnik.swagger.models.Swagger;
import com.wordnik.swagger.models.Tag;
import com.wordnik.swagger.models.auth.OAuth2Definition;

import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;

public class Bootstrap extends HttpServlet {

  @Override
  public void init(ServletConfig config) throws ServletException {
    Info info = new Info()
            .title("Swagger Sample App")
            .description("This is a sample server Petstore server.  You can find out more about Swagger " +
                    "at <a href=\"http://swagger.io\">http://swagger.io</a> or on irc.freenode.net, #swagger.  For this sample, " +
                    "you can use the api key \"special-key\" to test the authorization filters")
            .termsOfService("http://helloreverb.com/terms/")
            .contact(new Contact()
                    .email("apiteam@swagger.io"))
            .license(new License()
                    .name("Apache 2.0")
                    .url("http://www.apache.org/licenses/LICENSE-2.0.html"));

    ServletContext context = config.getServletContext();
    Swagger swagger = new Swagger().info(info);
    swagger.securityDefinition("petstore_auth",
            new OAuth2Definition()
                    .implicit("http://localhost:8002/oauth/dialog")
                    .scope("email", "Access to your email address")
                    .scope("pets", "Access to your pets"));
    swagger.tag(new Tag()
            .name("pet")
            .description("Everything about your Pets")
            .externalDocs(new ExternalDocs("Find out more", "http://swagger.io")));
    swagger.tag(new Tag()
            .name("store")
            .description("Access to Petstore orders"));
    swagger.tag(new Tag()
            .name("user")
            .description("Operations about user")
            .externalDocs(new ExternalDocs("Find out more about our store", "http://swagger.io")));
    context.setAttribute("swagger", swagger);
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/exception/ApiException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class ApiException extends Exception{
  private int code;
  public ApiException (int code, String msg) {
    super(msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/exception/NotFoundException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class NotFoundException extends ApiException {
  private final int code;
  public NotFoundException (int code, String msg) {
    super(code, msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/exception/BadRequestException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class BadRequestException extends ApiException{
  private int code;
  public BadRequestException (int code, String msg) {
    super(code, msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/model/ApiResponse.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.XmlTransient;

@javax.xml.bind.annotation.XmlRootElement
public class ApiResponse {
  public static final int ERROR = 1;
  public static final int WARNING = 2;
  public static final int INFO = 3;
  public static final int OK = 4;
  public static final int TOO_BUSY = 5;

  int code;
  String type;
  String message;
  
  public ApiResponse(){}
  
  public ApiResponse(int code, String message){
    this.code = code;
    switch(code){
    case ERROR:
      setType("error");
      break;
    case WARNING:
      setType("warning");
      break;
    case INFO:
      setType("info");
      break;
    case OK:
      setType("ok");
      break;
    case TOO_BUSY:
      setType("too busy");
      break;
    default:
      setType("unknown");
      break;
    }
    this.message = message;
  }

  @XmlTransient
  public int getCode() {
    return code;
  }

  public void setCode(int code) {
    this.code = code;
  }

  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/model/Pet.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import java.util.List;
import java.util.ArrayList;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Pet")
public class Pet {
  private long id;
  private Category category;
  private String name;
  private List<String> photoUrls = new ArrayList<String>();
  private List<Tag> tags = new ArrayList<Tag>();
  private String status;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "category")
  public Category getCategory() {
    return category;
  }

  public void setCategory(Category category) {
    this.category = category;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  @XmlElementWrapper(name = "photoUrls")
  @XmlElement(name = "photoUrl")
  public List<String> getPhotoUrls() {
    return photoUrls;
  }

  public void setPhotoUrls(List<String> photoUrls) {
    this.photoUrls = photoUrls;
  }

  @XmlElementWrapper(name = "tags")
  @XmlElement(name = "tag")
  public List<Tag> getTags() {
    return tags;
  }

  public void setTags(List<Tag> tags) {
    this.tags = tags;
  }

  @XmlElement(name = "status")
  @ApiModelProperty(value = "pet status in the store", allowableValues = "available,pending,sold")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/model/Order.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import java.util.Date;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Order")
public class Order {
  private long id;
  private long petId;
  private int quantity;
  private Date shipDate;
  private String status;
    private boolean complete;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

    public boolean isComplete() {
        return complete;
    }

    public void setComplete(boolean complete) {
        this.complete = complete;
    }


  @XmlElement(name = "petId")
  public long getPetId() {
    return petId;
  }

  public void setPetId(long petId) {
    this.petId = petId;
  }

  @XmlElement(name = "quantity")
  public int getQuantity() {
    return quantity;
  }

  public void setQuantity(int quantity) {
    this.quantity = quantity;
  }

  @XmlElement(name = "status")
  @ApiModelProperty(value = "Order Status", allowableValues = "placed, approved, delivered")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }

  @XmlElement(name = "shipDate")
  public Date getShipDate() {
    return shipDate;
  }

  public void setShipDate(Date shipDate) {
    this.shipDate = shipDate;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/model/User.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.ApiModelProperty;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;


@XmlRootElement(name = "User")
public class User {
  private long id;
  private String username;
  private String firstName;
  private String lastName;
  private String email;
  private String password;
  private String phone;
  private int userStatus;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "firstName")
  public String getFirstName() {
    return firstName;
  }

  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }

  @XmlElement(name = "username")
  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  @XmlElement(name = "lastName")
  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }

  @XmlElement(name = "email")
  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  @XmlElement(name = "password")
  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  @XmlElement(name = "phone")
  public String getPhone() {
    return phone;
  }

  public void setPhone(String phone) {
    this.phone = phone;
  }

  @XmlElement(name = "userStatus")
  @ApiModelProperty(value = "User Status", allowableValues = "1-registered,2-active,3-closed")
  public int getUserStatus() {
    return userStatus;
  }

  public void setUserStatus(int userStatus) {
    this.userStatus = userStatus;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/model/Tag.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Tag")
public class Tag {
  private long id;
  private String name;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/model/Category.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Category")
public class Category {
  private long id;
  private String name;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/util/ApiAuthorizationFilterImpl.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import com.wordnik.swagger.model.*;
import com.wordnik.swagger.core.filter.SwaggerSpecFilter;

import com.wordnik.swagger.models.Model;
import com.wordnik.swagger.models.Operation;
import com.wordnik.swagger.models.parameters.Parameter;
import com.wordnik.swagger.models.properties.Property;
import org.slf4j.*;

import java.util.Map;
import java.util.List;

/**
 * 
 * The rules are maintained in simple map with key as path and a boolean value
 * indicating given path is secure or not. For method level security the key is
 * combination of http method and path .
 * 
 * If the resource or method is secure then it can only be viewed using a
 * secured api key
 * 
 * Note: Objective of this class is not to provide fully functional
 * implementation of authorization filter. This is only a sample demonstration
 * how API authorization filter works.
 * 
 */

public class ApiAuthorizationFilterImpl implements SwaggerSpecFilter {
  static Logger logger = LoggerFactory.getLogger(ApiAuthorizationFilterImpl.class);

  public boolean isOperationAllowed(Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if(isAuthorized) {
      return true;
    }
    else {
      if(!"GET".equalsIgnoreCase(api.getMethod()) || api.getPath().indexOf("/store") != -1) {
        return false;
      }
      else return true;
    }
  }

  public boolean isParamAllowed(Parameter parameter, Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if("internal".equals(parameter.getAccess()) && !isAuthorized)
      return false;
    else
      return true;
  }

  @Override
  public boolean isPropertyAllowed(Model model, Property property, String propertyName, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    return true;
  }

  public boolean checkKey(Map<String, List<String>> params, Map<String, List<String>> headers) {
    String keyValue = null;
    if(params.containsKey("api_key"))
      keyValue = params.get("api_key").get(0);
    else {
      if(headers.containsKey("api_key"))
        keyValue = headers.get("api_key").get(0);
    }
    if("special-key".equals(keyValue))
      return true;
    else
      return false;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/util/ApiOriginFilter.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import java.io.IOException;

import javax.servlet.*;
import javax.servlet.http.HttpServletResponse;

public class ApiOriginFilter implements javax.servlet.Filter {
  @Override
  public void doFilter(ServletRequest request, ServletResponse response,
      FilterChain chain) throws IOException, ServletException {
    HttpServletResponse res = (HttpServletResponse) response;
    res.addHeader("Access-Control-Allow-Origin", "*");
    res.addHeader("Access-Control-Allow-Methods", "GET, POST, DELETE, PUT");
    res.addHeader("Access-Control-Allow-Headers", "Content-Type");
    chain.doFilter(request, response);
  }

  @Override
  public void destroy() {
  }

  @Override
  public void init(FilterConfig filterConfig) throws ServletException {
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/data/PetData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.Category;
import com.wordnik.swagger.sample.model.Pet;
import com.wordnik.swagger.sample.model.Tag;

import java.util.List;
import java.util.ArrayList;

public class PetData {
  static List<Pet> pets = new ArrayList<Pet>();
  static List<Category> categories = new ArrayList<Category>();

  static {
    categories.add(createCategory(1, "Dogs"));
    categories.add(createCategory(2, "Cats"));
    categories.add(createCategory(3, "Rabbits"));
    categories.add(createCategory(4, "Lions"));

    pets.add(createPet(1, categories.get(1), "Cat 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(2, categories.get(1), "Cat 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
    pets.add(createPet(3, categories.get(1), "Cat 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

    pets.add(createPet(4, categories.get(0), "Dog 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(5, categories.get(0), "Dog 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "sold"));
    pets.add(createPet(6, categories.get(0), "Dog 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

    pets.add(createPet(7, categories.get(3), "Lion 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(8, categories.get(3), "Lion 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
    pets.add(createPet(9, categories.get(3), "Lion 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));

    pets.add(createPet(10, categories.get(2), "Rabbit 1", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));
  }

  public Pet getPetbyId(long petId) {
    for (Pet pet : pets) {
      if (pet.getId() == petId) {
        return pet;
      }
    }
    return null;
  }

  public List<Pet> findPetByStatus(String status) {
    String[] statues = status.split(",");
    List<Pet> result = new java.util.ArrayList<Pet>();
    for (Pet pet : pets) {
      for (String s : statues) {
        if (s.equals(pet.getStatus())) {
          result.add(pet);
        }
      }
    }
    return result;
  }

  public List<Pet> findPetByTags(String tags) {
    String[] tagList = tags.split(",");
    List<Pet> result = new java.util.ArrayList<Pet>();
    for (Pet pet : pets) {
      if (null != pet.getTags()) {
        for (Tag tag : pet.getTags()) {
          for (String tagListString : tagList) {
            if (tagListString.equals(tag.getName()))
              result.add(pet);
          }
        }
      }
    }
    return result;
  }

  public void addPet(Pet pet) {
    if (pets.size() > 0) {
      for (int i = pets.size() - 1; i >= 0; i--) {
        if (pets.get(i).getId() == pet.getId()) {
          pets.remove(i);
        }
      }
    }
    pets.add(pet);
  }

  static Pet createPet(long id, Category cat, String name, String[] urls,
      String[] tags, String status) {
    Pet pet = new Pet();
    pet.setId(id);
    pet.setCategory(cat);
    pet.setName(name);
    if (null != urls) {
      List<String> urlObjs = new ArrayList<String>();
      for (String urlString : urls) {
        urlObjs.add(urlString);
      }
      pet.setPhotoUrls(urlObjs);
    }
    List<Tag> tagObjs = new java.util.ArrayList<Tag>();
    int i = 0;
    if (null != tags) {
      for (String tagString : tags) {
        i = i + 1;
        Tag tag = new Tag();
        tag.setId(i);
        tag.setName(tagString);
        tagObjs.add(tag);
      }
    }
    pet.setTags(tagObjs);
    pet.setStatus(status);
    return pet;
  }

  static Category createCategory(long id, String name) {
    Category category = new Category();
    category.setId(id);
    category.setName(name);
    return category;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/data/UserData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.User;

import java.util.List;
import java.util.ArrayList;

public class UserData {
  static List<User> users = new ArrayList<User>();

  static {
    users.add(createUser(1, "user1", "first name 1", "last name 1",
        "email1@test.com", "123-456-7890", 1));
    users.add(createUser(2, "user2", "first name 2", "last name 2",
        "email2@test.com", "123-456-7890", 2));
    users.add(createUser(3, "user3", "first name 3", "last name 3",
        "email3@test.com", "123-456-7890", 3));
    users.add(createUser(4, "user4", "first name 4", "last name 4",
        "email4@test.com", "123-456-7890", 1));
    users.add(createUser(5, "user5", "first name 5", "last name 5",
        "email5@test.com", "123-456-7890", 2));
    users.add(createUser(6, "user6", "first name 6", "last name 6",
        "email6@test.com", "123-456-7890", 3));
    users.add(createUser(7, "user7", "first name 7", "last name 7",
        "email7@test.com", "123-456-7890", 1));
    users.add(createUser(8, "user8", "first name 8", "last name 8",
        "email8@test.com", "123-456-7890", 2));
    users.add(createUser(9, "user9", "first name 9", "last name 9",
        "email9@test.com", "123-456-7890", 3));
    users.add(createUser(10, "user10", "first name 10", "last name 10",
        "email10@test.com", "123-456-7890", 1));
    users.add(createUser(11, "user?10", "first name ?10", "last name ?10",
        "email101@test.com", "123-456-7890", 1));

  }

  public User findUserByName(String username) {
    for (User user : users) {
      if (user.getUsername().equals(username)) {
        return user;
      }
    }
    return null;
  }

  public void addUser(User user) {
    if (users.size() > 0) {
      for (int i = users.size() - 1; i >= 0; i--) {
        if (users.get(i).getUsername().equals(user.getUsername())) {
          users.remove(i);
        }
      }
    }
    users.add(user);
  }

  public void removeUser(String username) {
    if (users.size() > 0) {
      for (int i = users.size() - 1; i >= 0; i--) {
        if (users.get(i).getUsername().equals(username)) {
          users.remove(i);
        }
      }
    }
  }

  private static User createUser(long id, String username, String firstName,
      String lastName, String email, String phone, int userStatus) {
    User user = new User();
    user.setId(id);
    user.setUsername(username);
    user.setFirstName(firstName);
    user.setLastName(lastName);
    user.setEmail(email);
    user.setPassword("XXXXXXXXXXX");
    user.setPhone(phone);
    user.setUserStatus(userStatus);
    return user;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/data/StoreData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.Order;

import java.util.Date;
import java.util.List;
import java.util.ArrayList;

public class StoreData {
  static List<Order> orders = new ArrayList<Order>();

  static {
    orders.add(createOrder(1, 1, 2, new Date(), "placed"));
    orders.add(createOrder(2, 1, 2, new Date(), "delivered"));
    orders.add(createOrder(3, 2, 2, new Date(), "placed"));
    orders.add(createOrder(4, 2, 2, new Date(), "delivered"));
    orders.add(createOrder(5, 3, 2, new Date(), "placed"));
    orders.add(createOrder(11, 3, 2, new Date(), "placed"));
    orders.add(createOrder(12, 3, 2, new Date(), "placed"));
    orders.add(createOrder(13, 3, 2, new Date(), "placed"));
    orders.add(createOrder(14, 3, 2, new Date(), "placed"));
    orders.add(createOrder(15, 3, 2, new Date(), "placed"));
  }

  public Order findOrderById(long orderId) {
    for (Order order : orders) {
      if (order.getId() == orderId) {
        return order;
      }
    }
    return null;
  }

  public void placeOrder(Order order) {
    if (orders.size() > 0) {
      for (int i = orders.size() - 1; i >= 0; i--) {
        if (orders.get(i).getId() == order.getId()) {
          orders.remove(i);
        }
      }
    }
    orders.add(order);
  }

  public void deleteOrder(long orderId) {
    if (orders.size() > 0) {
      for (int i = orders.size() - 1; i >= 0; i--) {
        if (orders.get(i).getId() == orderId) {
          orders.remove(i);
        }
      }
    }
  }

  private static Order createOrder(long id, long petId, int quantity,
      Date shipDate, String status) {
    Order order = new Order();
    order.setId(id);
    order.setPetId(petId);
    order.setQuantity(quantity);
    order.setShipDate(shipDate);
    order.setStatus(status);
    return order;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/resources/SampleExceptionMapper.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resources;

import com.wordnik.swagger.sample.exception.ApiException;
import com.wordnik.swagger.sample.exception.BadRequestException;
import com.wordnik.swagger.sample.model.ApiResponse;

import javax.ws.rs.NotFoundException;
import javax.ws.rs.ext.*;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

@Provider
public class SampleExceptionMapper implements ExceptionMapper<Exception> {
  public Response toResponse(Exception exception) {
    if (exception instanceof javax.ws.rs.WebApplicationException) {
      javax.ws.rs.WebApplicationException e = (javax.ws.rs.WebApplicationException) exception;
      return Response
          .status(e.getResponse().getStatus())
          .entity(new ApiResponse(e.getResponse().getStatus(),
              exception.getMessage())).build();
    } else if (exception instanceof com.fasterxml.jackson.core.JsonParseException) {
      return Response.status(400)
          .entity(new ApiResponse(400, "bad input")).build();
    } else if (exception instanceof NotFoundException) {
      return Response
          .status(Status.NOT_FOUND)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof BadRequestException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof ApiException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else {
      return Response.status(500)
          .entity(new ApiResponse(500, "something bad happened"))
          .build();
    }
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/resources/ResourceConfiguration.java;<<<<<<< MINE
package com.wordnik.swagger.sample.resources;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.jaxrs.json.JacksonJaxbJsonProvider;
import com.fasterxml.jackson.module.jaxb.JaxbAnnotationModule;

import java.util.HashSet;
import java.util.Set;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/rest")
public class ResourceConfiguration extends Application {

    @Override
    public Set<Class<?>> getClasses() {
        Set<Class<?>> classes = new HashSet<Class<?>>();

        classes.add(com.wordnik.swagger.jaxrs.listing.ApiListingResource.class);
        classes.add(com.wordnik.swagger.jaxrs.listing.SwaggerSerializers.class);

        addRestResources(classes);

        return classes;
    }

    /**
     * Here you can add your extra resources.
     *
     * @param resources
     */
    private void addRestResources(Set<Class<?>> resources) {
        resources.add(PetResource.class);
        resources.add(PetStoreResource.class);
        resources.add(UserResource.class);

    }

    @Override
    public Set<Object> getSingletons() {
        Set<Object> s = new HashSet<Object>();

        // TODO : Is this the correct configuration???
        // Register the Jackson provider for JSON
        // Make (de)serializer use a subset of JAXB and (afterwards) Jackson annotations
        // See http://wiki.fasterxml.com/JacksonJAXBAnnotations for more information
        ObjectMapper mapper = new ObjectMapper();

        JaxbAnnotationModule module = new JaxbAnnotationModule();
        // configure as necessary
        mapper.registerModule(module);

        // Set up the provider
        JacksonJaxbJsonProvider jaxbProvider = new JacksonJaxbJsonProvider();
        jaxbProvider.setMapper(mapper);

        s.add(jaxbProvider);
        return s;
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-jaxrs-wink/src/main/java/com/wordnik/swagger/sample/resources/JavaRestResourceUtil.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resources;

import java.text.SimpleDateFormat;

import java.util.Date;

public class JavaRestResourceUtil {
  public int getInt(int minVal, int maxVal, int defaultValue, String inputString) {
    int output = defaultValue;
    try {
      output = Integer.parseInt(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) {
      if (output < minVal) output = minVal;
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public long getLong(long minVal, long maxVal, long defaultValue, String inputString) {
    long output = defaultValue;
    try {
      output = Long.parseLong(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { if (output < minVal) output = minVal; }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public double getDouble(double minVal, double maxVal, double defaultValue, String inputString) {
    double output = defaultValue;
    try {
      output = Double.parseDouble(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { 
      if (output < minVal) output = minVal; 
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public boolean getBoolean(boolean defaultValue, String booleanString) {
    boolean output = defaultValue;
    if (booleanString == null) output = defaultValue;

    //  treat "", "YES" as "true"
    if ("".equals(booleanString)) output = true;
    else if ("YES".equalsIgnoreCase(booleanString)) output = true;
    else if ("NO".equalsIgnoreCase(booleanString)) output = false;
    else {
      try {
        output = Boolean.parseBoolean(booleanString);
      }
      catch (Exception e){
        output = defaultValue;
      }
    }
    return output;
  }
  
  public Date getDate(Date defaultValue, String dateString){
    try {
      return new SimpleDateFormat("yyyy-MM-dd").parse(dateString);
    }
    catch(Exception e) {
      return defaultValue;
    }
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-mule/src/main/java/com/wordnik/swagger/sample/resource/SampleExceptionMapper.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resource;

import com.wordnik.swagger.sample.exception.ApiException;
import com.wordnik.swagger.sample.exception.BadRequestException;
import com.wordnik.swagger.sample.exception.NotFoundException;
import com.wordnik.swagger.sample.model.ApiResponse;

import javax.ws.rs.ext.*;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

@Provider
public class SampleExceptionMapper implements ExceptionMapper<Exception> {
  public Response toResponse(Exception exception) {
    if (exception instanceof javax.ws.rs.WebApplicationException) {
      javax.ws.rs.WebApplicationException e = (javax.ws.rs.WebApplicationException) exception;
      return Response
          .status(e.getResponse().getStatus())
          .entity(new ApiResponse(e.getResponse().getStatus(),
              exception.getMessage())).build();
    } else if (exception instanceof com.fasterxml.jackson.core.JsonParseException) {
      return Response.status(400)
          .entity(new ApiResponse(400, "bad input")).build();
    } else if (exception instanceof NotFoundException) {
      return Response
          .status(Status.NOT_FOUND)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof BadRequestException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof ApiException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else {
      return Response.status(500)
          .entity(new ApiResponse(500, "something bad happened"))
          .build();
    }
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-mule/src/main/java/com/wordnik/swagger/sample/resource/JavaRestResourceUtil.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.resource;

import java.text.SimpleDateFormat;

import java.util.Date;

public class JavaRestResourceUtil {
  public int getInt(int minVal, int maxVal, int defaultValue, String inputString) {
    int output = defaultValue;
    try {
      output = Integer.parseInt(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) {
      if (output < minVal) output = minVal;
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public long getLong(long minVal, long maxVal, long defaultValue, String inputString) {
    long output = defaultValue;
    try {
      output = Long.parseLong(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { if (output < minVal) output = minVal; }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public double getDouble(double minVal, double maxVal, double defaultValue, String inputString) {
    double output = defaultValue;
    try {
      output = Double.parseDouble(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { 
      if (output < minVal) output = minVal; 
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public boolean getBoolean(boolean defaultValue, String booleanString) {
    boolean output = defaultValue;
    if (booleanString == null) output = defaultValue;

    //  treat "", "YES" as "true"
    if ("".equals(booleanString)) output = true;
    else if ("YES".equalsIgnoreCase(booleanString)) output = true;
    else if ("NO".equalsIgnoreCase(booleanString)) output = false;
    else {
      try {
        output = Boolean.parseBoolean(booleanString);
      }
      catch (Exception e){
        output = defaultValue;
      }
    }
    return output;
  }
  
  public Date getDate(Date defaultValue, String dateString){
    try {
      return new SimpleDateFormat("yyyy-MM-dd").parse(dateString);
    }
    catch(Exception e) {
      return defaultValue;
    }
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-mule/src/main/java/com/wordnik/swagger/sample/exception/ApiException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class ApiException extends Exception{
  private int code;
  public ApiException (int code, String msg) {
    super(msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-mule/src/main/java/com/wordnik/swagger/sample/exception/NotFoundException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class NotFoundException extends ApiException {
  private int code;
  public NotFoundException (int code, String msg) {
    super(code, msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-mule/src/main/java/com/wordnik/swagger/sample/exception/BadRequestException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class BadRequestException extends ApiException{
  private int code;
  public BadRequestException (int code, String msg) {
    super(code, msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-mule/src/main/java/com/wordnik/swagger/sample/model/ApiResponse.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.XmlTransient;

@javax.xml.bind.annotation.XmlRootElement
public class ApiResponse {
  public static final int ERROR = 1;
  public static final int WARNING = 2;
  public static final int INFO = 3;
  public static final int OK = 4;
  public static final int TOO_BUSY = 5;

  int code;
  String type;
  String message;
  
  public ApiResponse(){}
  
  public ApiResponse(int code, String message){
    this.code = code;
    switch(code){
    case ERROR:
      setType("error");
      break;
    case WARNING:
      setType("warning");
      break;
    case INFO:
      setType("info");
      break;
    case OK:
      setType("ok");
      break;
    case TOO_BUSY:
      setType("too busy");
      break;
    default:
      setType("unknown");
      break;
    }
    this.message = message;
  }

  @XmlTransient
  public int getCode() {
    return code;
  }

  public void setCode(int code) {
    this.code = code;
  }

  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-mule/src/main/java/com/wordnik/swagger/sample/model/Pet.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import java.util.List;
import java.util.ArrayList;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Pet")
public class Pet {
  private long id;
  private Category category;
  private String name;
  private List<String> photoUrls = new ArrayList<String>();
  private List<Tag> tags = new ArrayList<Tag>();
  private String status;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "category")
  public Category getCategory() {
    return category;
  }

  public void setCategory(Category category) {
    this.category = category;
  }

  @XmlElement(name = "name")
  @ApiModelProperty(example = "doggie", required = true)
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  @XmlElementWrapper(name = "photoUrls")
  @XmlElement(name = "photoUrl", required = true)
  public List<String> getPhotoUrls() {
    return photoUrls;
  }

  public void setPhotoUrls(List<String> photoUrls) {
    this.photoUrls = photoUrls;
  }

  @XmlElementWrapper(name = "tags")
  @XmlElement(name = "tag")
  public List<Tag> getTags() {
    return tags;
  }

  public void setTags(List<Tag> tags) {
    this.tags = tags;
  }

  @XmlElement(name = "status")
  @ApiModelProperty(value = "pet status in the store", allowableValues = "available,pending,sold")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-mule/src/main/java/com/wordnik/swagger/sample/model/Order.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import java.util.Date;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Order")
public class Order {
  private long id;
  private long petId;
  private int quantity;
  private Date shipDate;
  private String status;
  private boolean complete;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  public boolean isComplete() {
    return complete;
  }

  public void setComplete(boolean complete) {
    this.complete = complete;
  }

  @XmlElement(name = "petId")
  public long getPetId() {
    return petId;
  }

  public void setPetId(long petId) {
    this.petId = petId;
  }

  @XmlElement(name = "quantity")
  public int getQuantity() {
    return quantity;
  }

  public void setQuantity(int quantity) {
    this.quantity = quantity;
  }

  @XmlElement(name = "status")
  @ApiModelProperty(value = "Order Status", allowableValues = "placed, approved, delivered")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }

  @XmlElement(name = "shipDate")
  public Date getShipDate() {
    return shipDate;
  }

  public void setShipDate(Date shipDate) {
    this.shipDate = shipDate;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-mule/src/main/java/com/wordnik/swagger/sample/model/User.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "User")
public class User {
  private long id;
  private String username;
  private String firstName;
  private String lastName;
  private String email;
  private String password;
  private String phone;
  private int userStatus;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "firstName")
  public String getFirstName() {
    return firstName;
  }

  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }

  @XmlElement(name = "username")
  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  @XmlElement(name = "lastName")
  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }

  @XmlElement(name = "email")
  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  @XmlElement(name = "password")
  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  @XmlElement(name = "phone")
  public String getPhone() {
    return phone;
  }

  public void setPhone(String phone) {
    this.phone = phone;
  }

  @XmlElement(name = "userStatus")
  @ApiModelProperty(value = "User Status", allowableValues = "1-registered,2-active,3-closed")
  public int getUserStatus() {
    return userStatus;
  }

  public void setUserStatus(int userStatus) {
    this.userStatus = userStatus;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-mule/src/main/java/com/wordnik/swagger/sample/model/Tag.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Tag")
public class Tag {
  private long id;
  private String name;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-mule/src/main/java/com/wordnik/swagger/sample/model/Category.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Category")
public class Category {
  private long id;
  private String name;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-mule/src/main/java/com/wordnik/swagger/sample/data/PetData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;

import java.util.*;

public class PetData {
  static List<Pet> pets = new ArrayList<Pet>();
  static List<Category> categories = new ArrayList<Category>();

  static {
    categories.add(createCategory(1, "Dogs"));
    categories.add(createCategory(2, "Cats"));
    categories.add(createCategory(3, "Rabbits"));
    categories.add(createCategory(4, "Lions"));

    pets.add(createPet(1, categories.get(1), "Cat 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(2, categories.get(1), "Cat 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
    pets.add(createPet(3, categories.get(1), "Cat 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

    pets.add(createPet(4, categories.get(0), "Dog 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(5, categories.get(0), "Dog 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "sold"));
    pets.add(createPet(6, categories.get(0), "Dog 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

    pets.add(createPet(7, categories.get(3), "Lion 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(8, categories.get(3), "Lion 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
    pets.add(createPet(9, categories.get(3), "Lion 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));

    pets.add(createPet(10, categories.get(2), "Rabbit 1", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));
  }

  public Pet getPetbyId(long petId) {
    for (Pet pet : pets) {
      if (pet.getId() == petId) {
        return pet;
      }
    }
    return null;
  }

  public void deletePet(long petId) {
    if(pets.size() > 0) {
      for (int i = pets.size(); i >= 0; i++) {
        Pet pet = pets.get(i);
        if(pet.getId() == petId) {
          pets.remove(i);
        }
      }
    }
  }

  public List<Pet> findPetByStatus(String status) {
    String[] statues = status.split(",");
    List<Pet> result = new java.util.ArrayList<Pet>();
    for (Pet pet : pets) {
      for (String s : statues) {
        if (s.equals(pet.getStatus())) {
          result.add(pet);
        }
      }
    }
    return result;
  }

  public List<Pet> findPetByTags(String tags) {
    String[] tagList = tags.split(",");
    List<Pet> result = new java.util.ArrayList<Pet>();
    for (Pet pet : pets) {
      if (null != pet.getTags()) {
        for (Tag tag : pet.getTags()) {
          for (String tagListString : tagList) {
            if (tagListString.equals(tag.getName()))
              result.add(pet);
          }
        }
      }
    }
    return result;
  }

  public Pet addPet(Pet pet) {
    if(pet.getId() == 0) {
      long maxId = 0;
      for (int i = pets.size() - 1; i >= 0; i--) {
        if(pets.get(i).getId() > maxId) {
          maxId = pets.get(i).getId();
        }
      }
      pet.setId(maxId + 1);
    }
    if (pets.size() > 0) {
      for (int i = pets.size() - 1; i >= 0; i--) {
        if (pets.get(i).getId() == pet.getId()) {
          pets.remove(i);
        }
      }
    }
    pets.add(pet);
    return pet;
  }

  public Map<String, Integer> getInventoryByStatus() {
    Map<String, Integer> output = new HashMap<String, Integer>();
    for(Pet pet : pets) {
      String status = pet.getStatus();
      if(status != null && !"".equals(status)) {
        Integer count = output.get(status);
        if(count == null)
          count = new Integer(1);
        else
          count = count.intValue() + 1;
        output.put(status, count);
      }
    }
    return output;
  }

  static Pet createPet(long id, Category cat, String name, String[] urls,
      String[] tags, String status) {
    Pet pet = new Pet();
    pet.setId(id);
    pet.setCategory(cat);
    pet.setName(name);
    if (null != urls) {
      List<String> urlObjs = new ArrayList<String>();
      for (String urlString : urls) {
        urlObjs.add(urlString);
      }
      pet.setPhotoUrls(urlObjs);
    }
    List<Tag> tagObjs = new java.util.ArrayList<Tag>();
    int i = 0;
    if (null != tags) {
      for (String tagString : tags) {
        i = i + 1;
        Tag tag = new Tag();
        tag.setId(i);
        tag.setName(tagString);
        tagObjs.add(tag);
      }
    }
    pet.setTags(tagObjs);
    pet.setStatus(status);
    return pet;
  }

  static Category createCategory(long id, String name) {
    Category category = new Category();
    category.setId(id);
    category.setName(name);
    return category;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-mule/src/main/java/com/wordnik/swagger/sample/data/UserData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;

import java.util.List;
import java.util.ArrayList;

public class UserData {
  static List<User> users = new ArrayList<User>();

  static {
    users.add(createUser(1, "user1", "first name 1", "last name 1",
        "email1@test.com", "123-456-7890", 1));
    users.add(createUser(2, "user2", "first name 2", "last name 2",
        "email2@test.com", "123-456-7890", 2));
    users.add(createUser(3, "user3", "first name 3", "last name 3",
        "email3@test.com", "123-456-7890", 3));
    users.add(createUser(4, "user4", "first name 4", "last name 4",
        "email4@test.com", "123-456-7890", 1));
    users.add(createUser(5, "user5", "first name 5", "last name 5",
        "email5@test.com", "123-456-7890", 2));
    users.add(createUser(6, "user6", "first name 6", "last name 6",
        "email6@test.com", "123-456-7890", 3));
    users.add(createUser(7, "user7", "first name 7", "last name 7",
        "email7@test.com", "123-456-7890", 1));
    users.add(createUser(8, "user8", "first name 8", "last name 8",
        "email8@test.com", "123-456-7890", 2));
    users.add(createUser(9, "user9", "first name 9", "last name 9",
        "email9@test.com", "123-456-7890", 3));
    users.add(createUser(10, "user10", "first name 10", "last name 10",
        "email10@test.com", "123-456-7890", 1));
    users.add(createUser(11, "user?10", "first name ?10", "last name ?10",
        "email101@test.com", "123-456-7890", 1));

  }

  public User findUserByName(String username) {
    for (User user : users) {
      if (user.getUsername().equals(username)) {
        return user;
      }
    }
    return null;
  }

  public void addUser(User user) {
    if (users.size() > 0) {
      for (int i = users.size() - 1; i >= 0; i--) {
        if (users.get(i).getUsername().equals(user.getUsername())) {
          users.remove(i);
        }
      }
    }
    users.add(user);
  }

  public void removeUser(String username) {
    if (users.size() > 0) {
      for (int i = users.size() - 1; i >= 0; i--) {
        if (users.get(i).getUsername().equals(username)) {
          users.remove(i);
        }
      }
    }
  }

  private static User createUser(long id, String username, String firstName,
      String lastName, String email, String phone, int userStatus) {
    User user = new User();
    user.setId(id);
    user.setUsername(username);
    user.setFirstName(firstName);
    user.setLastName(lastName);
    user.setEmail(email);
    user.setPassword("XXXXXXXXXXX");
    user.setPhone(phone);
    user.setUserStatus(userStatus);
    return user;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-mule/src/main/java/com/wordnik/swagger/sample/data/StoreData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;
import java.util.Date;
import java.util.List;
import java.util.ArrayList;

public class StoreData {
  static List<Order> orders = new ArrayList<Order>();

  static {
    orders.add(createOrder(1, 1, 2, new Date(), "placed"));
    orders.add(createOrder(2, 1, 2, new Date(), "delivered"));
    orders.add(createOrder(3, 2, 2, new Date(), "placed"));
    orders.add(createOrder(4, 2, 2, new Date(), "delivered"));
    orders.add(createOrder(5, 3, 2, new Date(), "placed"));
    orders.add(createOrder(11, 3, 2, new Date(), "placed"));
    orders.add(createOrder(12, 3, 2, new Date(), "placed"));
    orders.add(createOrder(13, 3, 2, new Date(), "placed"));
    orders.add(createOrder(14, 3, 2, new Date(), "placed"));
    orders.add(createOrder(15, 3, 2, new Date(), "placed"));
  }

  public Order findOrderById(long orderId) {
    for (Order order : orders) {
      if (order.getId() == orderId) {
        return order;
      }
    }
    return null;
  }

  public Order placeOrder(Order order) {
    if (orders.size() > 0) {
      for (int i = orders.size() - 1; i >= 0; i--) {
        if (orders.get(i).getId() == order.getId()) {
          orders.remove(i);
        }
      }
    }
    orders.add(order);
    return order;
  }

  public void deleteOrder(long orderId) {
    if (orders.size() > 0) {
      for (int i = orders.size() - 1; i >= 0; i--) {
        if (orders.get(i).getId() == orderId) {
          orders.remove(i);
        }
      }
    }
  }

  private static Order createOrder(long id, long petId, int quantity,
      Date shipDate, String status) {
    Order order = new Order();
    order.setId(id);
    order.setPetId(petId);
    order.setQuantity(quantity);
    order.setShipDate(shipDate);
    order.setStatus(status);
    return order;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/Bootstrap.java;<<<<<<< MINE
package com.wordnik.swagger.sample;

import com.wordnik.swagger.models.Contact;
import com.wordnik.swagger.models.ExternalDocs;
import com.wordnik.swagger.models.Info;
import com.wordnik.swagger.models.License;
import com.wordnik.swagger.models.Swagger;
import com.wordnik.swagger.models.Tag;
import com.wordnik.swagger.models.auth.OAuth2Definition;

import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;


public class Bootstrap extends HttpServlet {

  @Override
  public void init(ServletConfig config) throws ServletException {
    Info info = new Info()
            .title("Swagger Sample App")
            .description("This is a sample server Petstore server.  You can find out more about Swagger " +
                    "at <a href=\"http://swagger.io\">http://swagger.io</a> or on irc.freenode.net, #swagger.  For this sample, " +
                    "you can use the api key \"special-key\" to test the authorization filters")
            .termsOfService("http://helloreverb.com/terms/")
            .contact(new Contact()
                    .email("apiteam@swagger.io"))
            .license(new License()
                    .name("Apache 2.0")
                    .url("http://www.apache.org/licenses/LICENSE-2.0.html"));

    ServletContext context = config.getServletContext();
    Swagger swagger = new Swagger().info(info);
    swagger.securityDefinition("petstore_auth",
            new OAuth2Definition()
                    .implicit("http://localhost:8002/oauth/dialog")
                    .scope("email", "Access to your email address")
                    .scope("pets", "Access to your pets"));
    swagger.tag(new Tag()
            .name("pet")
            .description("Everything about your Pets")
            .externalDocs(new ExternalDocs("Find out more", "http://swagger.io")));
    swagger.tag(new Tag()
            .name("store")
            .description("Access to Petstore orders"));
    swagger.tag(new Tag()
            .name("user")
            .description("Operations about user")
            .externalDocs(new ExternalDocs("Find out more about our store", "http://swagger.io")));
    context.setAttribute("swagger", swagger);
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/exception/ApiException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class ApiException extends Exception{
  private int code;
  public ApiException (int code, String msg) {
    super(msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/exception/NotFoundException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class NotFoundException extends ApiException {
  private int code;
  public NotFoundException (int code, String msg) {
    super(code, msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/exception/BadRequestException.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.exception;

public class BadRequestException extends ApiException{
  private int code;
  public BadRequestException (int code, String msg) {
    super(code, msg);
    this.code = code;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/model/ApiResponse.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.XmlTransient;

@javax.xml.bind.annotation.XmlRootElement
public class ApiResponse {
  public static final int ERROR = 1;
  public static final int WARNING = 2;
  public static final int INFO = 3;
  public static final int OK = 4;
  public static final int TOO_BUSY = 5;

  int code;
  String type;
  String message;
  
  public ApiResponse(){}
  
  public ApiResponse(int code, String message){
    this.code = code;
    switch(code){
    case ERROR:
      setType("error");
      break;
    case WARNING:
      setType("warning");
      break;
    case INFO:
      setType("info");
      break;
    case OK:
      setType("ok");
      break;
    case TOO_BUSY:
      setType("too busy");
      break;
    default:
      setType("unknown");
      break;
    }
    this.message = message;
  }

  @XmlTransient
  public int getCode() {
    return code;
  }

  public void setCode(int code) {
    this.code = code;
  }

  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/model/Pet.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import java.util.List;
import java.util.ArrayList;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Pet")
public class Pet {
  private long id;
  private Category category;
  private String name;
  private List<String> photoUrls = new ArrayList<String>();
  private List<Tag> tags = new ArrayList<Tag>();
  private String status;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "category")
  public Category getCategory() {
    return category;
  }

  public void setCategory(Category category) {
    this.category = category;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  @XmlElementWrapper(name = "photoUrls")
  @XmlElement(name = "photoUrl")
  public List<String> getPhotoUrls() {
    return photoUrls;
  }

  public void setPhotoUrls(List<String> photoUrls) {
    this.photoUrls = photoUrls;
  }

  @XmlElementWrapper(name = "tags")
  @XmlElement(name = "tag")
  public List<Tag> getTags() {
    return tags;
  }

  public void setTags(List<Tag> tags) {
    this.tags = tags;
  }

  @XmlElement(name = "status")
  @ApiModelProperty(value = "pet status in the store", allowableValues = "available,pending,sold")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/model/Order.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import java.util.Date;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Order")
public class Order {
  private long id;
  private long petId;
  private int quantity;
  private Date shipDate;
  private String status;
    private boolean complete;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

    public boolean isComplete() {
        return complete;
    }

    public void setComplete(boolean complete) {
        this.complete = complete;
    }


  @XmlElement(name = "petId")
  public long getPetId() {
    return petId;
  }

  public void setPetId(long petId) {
    this.petId = petId;
  }

  @XmlElement(name = "quantity")
  public int getQuantity() {
    return quantity;
  }

  public void setQuantity(int quantity) {
    this.quantity = quantity;
  }

  @XmlElement(name = "status")
  @ApiModelProperty(value = "Order Status", allowableValues = "placed, approved, delivered")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }

  @XmlElement(name = "shipDate")
  public Date getShipDate() {
    return shipDate;
  }

  public void setShipDate(Date shipDate) {
    this.shipDate = shipDate;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/model/User.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import com.wordnik.swagger.annotations.*;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "User")
public class User {
  private long id;
  private String username;
  private String firstName;
  private String lastName;
  private String email;
  private String password;
  private String phone;
  private int userStatus;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "firstName")
  public String getFirstName() {
    return firstName;
  }

  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }

  @XmlElement(name = "username")
  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  @XmlElement(name = "lastName")
  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }

  @XmlElement(name = "email")
  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  @XmlElement(name = "password")
  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  @XmlElement(name = "phone")
  public String getPhone() {
    return phone;
  }

  public void setPhone(String phone) {
    this.phone = phone;
  }

  @XmlElement(name = "userStatus")
  @ApiModelProperty(value = "User Status", allowableValues = "1-registered,2-active,3-closed")
  public int getUserStatus() {
    return userStatus;
  }

  public void setUserStatus(int userStatus) {
    this.userStatus = userStatus;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/model/Tag.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Tag")
public class Tag {
  private long id;
  private String name;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/model/Category.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.model;

import javax.xml.bind.annotation.*;

@XmlRootElement(name = "Category")
public class Category {
  private long id;
  private String name;

  @XmlElement(name = "id")
  public long getId() {
    return id;
  }

  public void setId(long id) {
    this.id = id;
  }

  @XmlElement(name = "name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/bean/UserResourceBean.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.bean;

import com.wordnik.swagger.annotations.*;
import com.wordnik.swagger.sample.data.UserData;
import com.wordnik.swagger.sample.model.User;
import com.wordnik.swagger.sample.exception.ApiException;
import com.wordnik.swagger.sample.exception.NotFoundException;
import com.wordnik.swagger.sample.resource.UserResource;

import javax.ws.rs.core.Response;
import javax.ws.rs.*;

public class UserResourceBean implements UserResource {
  static UserData userData = new UserData();

  @Override
  public Response createUser(User user) {
    userData.addUser(user);
    return Response.ok().entity("").build();
  }

  @Override
  public Response createUsersWithArrayInput(User[] users) {
      for (User user : users) {
          userData.addUser(user);
      }
      return Response.ok().entity("").build();
  }

  @Override
  public Response createUsersWithListInput(java.util.List<User> users) {
      for (User user : users) {
          userData.addUser(user);
      }
      return Response.ok().entity("").build();
  }

  @Override
  public Response updateUser(String username, User user) {
    userData.addUser(user);
    return Response.ok().entity("").build();
  }

  @Override
  public Response deleteUser(String username) {
    userData.removeUser(username);
    return Response.ok().entity("").build();
  }

  @Override
  public Response getUserByName(String username) throws ApiException {
    User user = userData.findUserByName(username);
    if (null != user) {
      return Response.ok().entity(user).build();
    } else {
      throw new NotFoundException(404, "User not found");
    }
  }

  @Override
  public Response loginUser(String username, String password) {
    return Response.ok()
        .entity("logged in user session:" + System.currentTimeMillis())
        .build();
  }

  @Override
  public Response logoutUser() {
    return Response.ok().entity("").build();
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/bean/SampleExceptionMapper.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.bean;

import com.wordnik.swagger.sample.exception.ApiException;
import com.wordnik.swagger.sample.exception.BadRequestException;
import com.wordnik.swagger.sample.exception.NotFoundException;
import com.wordnik.swagger.sample.model.ApiResponse;

import javax.ws.rs.ext.*;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

@Provider
public class SampleExceptionMapper implements ExceptionMapper<Exception> {
  public Response toResponse(Exception exception) {
    if (exception instanceof javax.ws.rs.WebApplicationException) {
      javax.ws.rs.WebApplicationException e = (javax.ws.rs.WebApplicationException) exception;
      return Response
          .status(e.getResponse().getStatus())
          .entity(new ApiResponse(e.getResponse().getStatus(),
              exception.getMessage())).build();
    } else if (exception instanceof com.fasterxml.jackson.core.JsonParseException) {
      return Response.status(400)
          .entity(new ApiResponse(400, "bad input")).build();
    } else if (exception instanceof NotFoundException) {
      return Response
          .status(Status.NOT_FOUND)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof BadRequestException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else if (exception instanceof ApiException) {
      return Response
          .status(Status.BAD_REQUEST)
          .entity(new ApiResponse(ApiResponse.ERROR, exception
              .getMessage())).build();
    } else {
      return Response.status(500)
          .entity(new ApiResponse(500, "something bad happened"))
          .build();
    }
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/bean/PetStoreResourceBean.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.bean;

import com.wordnik.swagger.annotations.*;
import com.wordnik.swagger.sample.data.StoreData;
import com.wordnik.swagger.sample.model.Order;
import com.wordnik.swagger.sample.exception.NotFoundException;
import com.wordnik.swagger.sample.resource.PetStoreResource;

import javax.ws.rs.core.Response;
import javax.ws.rs.*;

public class PetStoreResourceBean implements PetStoreResource {
  static StoreData storeData = new StoreData();
  static JavaRestResourceUtil ru = new JavaRestResourceUtil();

  @Override
  public Response getOrderById(String orderId) throws NotFoundException {
    Order order = storeData.findOrderById(ru.getLong(0, 10000, 0, orderId));
    if (null != order) {
      return Response.ok().entity(order).build();
    } else {
      throw new NotFoundException(404, "Order not found");
    }
  }

  @Override
  public Response placeOrder(Order order) {
    storeData.placeOrder(order);
    return Response.ok().entity("").build();
  }

  @Override
  public Response deleteOrder(String orderId) {
    storeData.deleteOrder(ru.getLong(0, 10000, 0, orderId));
    return Response.ok().entity("").build();
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/bean/PetResourceBean.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.bean;

import com.wordnik.swagger.sample.data.PetData;
import com.wordnik.swagger.sample.model.Pet;
import com.wordnik.swagger.sample.exception.NotFoundException;
import com.wordnik.swagger.sample.resource.PetResource;

import javax.ws.rs.core.Response;
import javax.ws.rs.*;

public class PetResourceBean implements PetResource {
    static PetData petData = new PetData();
    static JavaRestResourceUtil ru = new JavaRestResourceUtil();

    @Override
    public Pet getPetById(String petId) throws NotFoundException {
        Pet pet = petData.getPetbyId(ru.getLong(0, 100000, 0, petId));
        if (null != pet) {
            return pet;
        } else {
            throw new NotFoundException(404, "Pet not found");
        }
    }

    @Override
    public Response addPet(Pet pet) {
        petData.addPet(pet);
        return Response.ok().entity("SUCCESS").build();
    }

    @Override
    public Response updatePet(Pet pet) {
        petData.addPet(pet);
        return Response.ok().entity("SUCCESS").build();
    }

    @Override
    public Response findPetsByStatus(String status) {
        return Response.ok(petData.findPetByStatus(status)).build();
    }

    @Override
    @Deprecated
    public Response findPetsByTags(String tags) {
        return Response.ok(petData.findPetByTags(tags)).build();
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/bean/JavaRestResourceUtil.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.bean;

import java.text.SimpleDateFormat;

import java.util.Date;

public class JavaRestResourceUtil {
  public int getInt(int minVal, int maxVal, int defaultValue, String inputString) {
    int output = defaultValue;
    try {
      output = Integer.parseInt(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) {
      if (output < minVal) output = minVal;
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public long getLong(long minVal, long maxVal, long defaultValue, String inputString) {
    long output = defaultValue;
    try {
      output = Long.parseLong(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { if (output < minVal) output = minVal; }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public double getDouble(double minVal, double maxVal, double defaultValue, String inputString) {
    double output = defaultValue;
    try {
      output = Double.parseDouble(inputString);
    }
    catch (Exception e){
      output = defaultValue;
    }

    if (output < minVal) output = minVal;
    if (maxVal == -1) { 
      if (output < minVal) output = minVal; 
    }
    else if (output > maxVal) output = maxVal;
    return output;
  }

  public boolean getBoolean(boolean defaultValue, String booleanString) {
    boolean output = defaultValue;
    if (booleanString == null) output = defaultValue;

    //  treat "", "YES" as "true"
    if ("".equals(booleanString)) output = true;
    else if ("YES".equalsIgnoreCase(booleanString)) output = true;
    else if ("NO".equalsIgnoreCase(booleanString)) output = false;
    else {
      try {
        output = Boolean.parseBoolean(booleanString);
      }
      catch (Exception e){
        output = defaultValue;
      }
    }
    return output;
  }
  
  public Date getDate(Date defaultValue, String dateString){
    try {
      return new SimpleDateFormat("yyyy-MM-dd").parse(dateString);
    }
    catch(Exception e) {
      return defaultValue;
    }
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/util/ApiAuthorizationFilterImpl.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import com.wordnik.swagger.model.*;
import com.wordnik.swagger.core.filter.SwaggerSpecFilter;

import com.wordnik.swagger.models.Model;
import com.wordnik.swagger.models.Operation;
import com.wordnik.swagger.models.parameters.Parameter;
import com.wordnik.swagger.models.properties.Property;
import org.slf4j.*;

import java.util.Map;
import java.util.List;

import javax.servlet.ServletConfig;
import javax.servlet.http.HttpServlet;
/**
 * 
 * The rules are maintained in simple map with key as path and a boolean value
 * indicating given path is secure or not. For method level security the key is
 * combination of http method and path .
 * 
 * If the resource or method is secure then it can only be viewed using a
 * secured api key
 * 
 * Note: Objective of this class is not to provide fully functional
 * implementation of authorization filter. This is only a sample demonstration
 * how API authorization filter works.
 * 
 */

public class ApiAuthorizationFilterImpl implements SwaggerSpecFilter {
  static Logger logger = LoggerFactory.getLogger(ApiAuthorizationFilterImpl.class);

  public boolean isOperationAllowed(Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if(isAuthorized) {
      return true;
    }
    else {
      if(!"GET".equalsIgnoreCase(api.getMethod()) || api.getPath().indexOf("/store") != -1) {
        return false;
      }
      else return true;
    }
  }

  public boolean isParamAllowed(Parameter parameter, Operation operation, ApiDescription api, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    boolean isAuthorized = checkKey(params, headers);
    if("internal".equals(parameter.getAccess()) && !isAuthorized)
      return false;
    else
      return true;
  }

  @Override
  public boolean isPropertyAllowed(Model model, Property property, String propertyName, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
    return true;
  }

  public boolean checkKey(Map<String, List<String>> params, Map<String, List<String>> headers) {
    String keyValue = null;
    if(params.containsKey("api_key"))
      keyValue = params.get("api_key").get(0);
    else {
      if(headers.containsKey("api_key"))
        keyValue = headers.get("api_key").get(0);
    }
    if("special-key".equals(keyValue))
      return true;
    else
      return false;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/util/ApiOriginFilter.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.util;

import java.io.IOException;

import javax.servlet.*;
import javax.servlet.http.HttpServletResponse;

public class ApiOriginFilter implements javax.servlet.Filter {
  @Override
  public void doFilter(ServletRequest request, ServletResponse response,
      FilterChain chain) throws IOException, ServletException {
    HttpServletResponse res = (HttpServletResponse) response;
    res.addHeader("Access-Control-Allow-Origin", "*");
    res.addHeader("Access-Control-Allow-Methods", "GET, POST, DELETE, PUT");
    res.addHeader("Access-Control-Allow-Headers", "Content-Type");
    chain.doFilter(request, response);
  }

  @Override
  public void destroy() {
  }

  @Override
  public void init(FilterConfig filterConfig) throws ServletException {
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/data/PetData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;

import java.util.List;
import java.util.ArrayList;

public class PetData {
  static List<Pet> pets = new ArrayList<Pet>();
  static List<Category> categories = new ArrayList<Category>();

  static {
    categories.add(createCategory(1, "Dogs"));
    categories.add(createCategory(2, "Cats"));
    categories.add(createCategory(3, "Rabbits"));
    categories.add(createCategory(4, "Lions"));

    pets.add(createPet(1, categories.get(1), "Cat 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(2, categories.get(1), "Cat 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
    pets.add(createPet(3, categories.get(1), "Cat 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

    pets.add(createPet(4, categories.get(0), "Dog 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(5, categories.get(0), "Dog 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "sold"));
    pets.add(createPet(6, categories.get(0), "Dog 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "pending"));

    pets.add(createPet(7, categories.get(3), "Lion 1", new String[] {
        "url1", "url2" }, new String[] { "tag1", "tag2" }, "available"));
    pets.add(createPet(8, categories.get(3), "Lion 2", new String[] {
        "url1", "url2" }, new String[] { "tag2", "tag3" }, "available"));
    pets.add(createPet(9, categories.get(3), "Lion 3", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));

    pets.add(createPet(10, categories.get(2), "Rabbit 1", new String[] {
        "url1", "url2" }, new String[] { "tag3", "tag4" }, "available"));
  }

  public Pet getPetbyId(long petId) {
    for (Pet pet : pets) {
      if (pet.getId() == petId) {
        return pet;
      }
    }
    return null;
  }

  public List<Pet> findPetByStatus(String status) {
    String[] statues = status.split(",");
    List<Pet> result = new java.util.ArrayList<Pet>();
    for (Pet pet : pets) {
      for (String s : statues) {
        if (s.equals(pet.getStatus())) {
          result.add(pet);
        }
      }
    }
    return result;
  }

  public List<Pet> findPetByTags(String tags) {
    String[] tagList = tags.split(",");
    List<Pet> result = new java.util.ArrayList<Pet>();
    for (Pet pet : pets) {
      if (null != pet.getTags()) {
        for (Tag tag : pet.getTags()) {
          for (String tagListString : tagList) {
            if (tagListString.equals(tag.getName()))
              result.add(pet);
          }
        }
      }
    }
    return result;
  }

  public void addPet(Pet pet) {
    if (pets.size() > 0) {
      for (int i = pets.size() - 1; i >= 0; i--) {
        if (pets.get(i).getId() == pet.getId()) {
          pets.remove(i);
        }
      }
    }
    pets.add(pet);
  }

  static Pet createPet(long id, Category cat, String name, String[] urls,
      String[] tags, String status) {
    Pet pet = new Pet();
    pet.setId(id);
    pet.setCategory(cat);
    pet.setName(name);
    if (null != urls) {
      List<String> urlObjs = new ArrayList<String>();
      for (String urlString : urls) {
        urlObjs.add(urlString);
      }
      pet.setPhotoUrls(urlObjs);
    }
    List<Tag> tagObjs = new java.util.ArrayList<Tag>();
    int i = 0;
    if (null != tags) {
      for (String tagString : tags) {
        i = i + 1;
        Tag tag = new Tag();
        tag.setId(i);
        tag.setName(tagString);
        tagObjs.add(tag);
      }
    }
    pet.setTags(tagObjs);
    pet.setStatus(status);
    return pet;
  }

  static Category createCategory(long id, String name) {
    Category category = new Category();
    category.setId(id);
    category.setName(name);
    return category;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/data/UserData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;

import java.util.List;
import java.util.ArrayList;

public class UserData {
  static List<User> users = new ArrayList<User>();

  static {
    users.add(createUser(1, "user1", "first name 1", "last name 1",
        "email1@test.com", "123-456-7890", 1));
    users.add(createUser(2, "user2", "first name 2", "last name 2",
        "email2@test.com", "123-456-7890", 2));
    users.add(createUser(3, "user3", "first name 3", "last name 3",
        "email3@test.com", "123-456-7890", 3));
    users.add(createUser(4, "user4", "first name 4", "last name 4",
        "email4@test.com", "123-456-7890", 1));
    users.add(createUser(5, "user5", "first name 5", "last name 5",
        "email5@test.com", "123-456-7890", 2));
    users.add(createUser(6, "user6", "first name 6", "last name 6",
        "email6@test.com", "123-456-7890", 3));
    users.add(createUser(7, "user7", "first name 7", "last name 7",
        "email7@test.com", "123-456-7890", 1));
    users.add(createUser(8, "user8", "first name 8", "last name 8",
        "email8@test.com", "123-456-7890", 2));
    users.add(createUser(9, "user9", "first name 9", "last name 9",
        "email9@test.com", "123-456-7890", 3));
    users.add(createUser(10, "user10", "first name 10", "last name 10",
        "email10@test.com", "123-456-7890", 1));
    users.add(createUser(11, "user?10", "first name ?10", "last name ?10",
        "email101@test.com", "123-456-7890", 1));

  }

  public User findUserByName(String username) {
    for (User user : users) {
      if (user.getUsername().equals(username)) {
        return user;
      }
    }
    return null;
  }

  public void addUser(User user) {
    if (users.size() > 0) {
      for (int i = users.size() - 1; i >= 0; i--) {
        if (users.get(i).getUsername().equals(user.getUsername())) {
          users.remove(i);
        }
      }
    }
    users.add(user);
  }

  public void removeUser(String username) {
    if (users.size() > 0) {
      for (int i = users.size() - 1; i >= 0; i--) {
        if (users.get(i).getUsername().equals(username)) {
          users.remove(i);
        }
      }
    }
  }

  private static User createUser(long id, String username, String firstName,
      String lastName, String email, String phone, int userStatus) {
    User user = new User();
    user.setId(id);
    user.setUsername(username);
    user.setFirstName(firstName);
    user.setLastName(lastName);
    user.setEmail(email);
    user.setPassword("XXXXXXXXXXX");
    user.setPhone(phone);
    user.setUserStatus(userStatus);
    return user;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_7222e10_ee0b639/rev_7222e10-ee0b639/samples/java-resteasy-spring/src/main/java/com/wordnik/swagger/sample/data/StoreData.java;<<<<<<< MINE
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.wordnik.swagger.sample.data;

import com.wordnik.swagger.sample.model.*;
import java.util.Date;
import java.util.List;
import java.util.ArrayList;

public class StoreData {
  static List<Order> orders = new ArrayList<Order>();

  static {
    orders.add(createOrder(1, 1, 2, new Date(), "placed"));
    orders.add(createOrder(2, 1, 2, new Date(), "delivered"));
    orders.add(createOrder(3, 2, 2, new Date(), "placed"));
    orders.add(createOrder(4, 2, 2, new Date(), "delivered"));
    orders.add(createOrder(5, 3, 2, new Date(), "placed"));
    orders.add(createOrder(11, 3, 2, new Date(), "placed"));
    orders.add(createOrder(12, 3, 2, new Date(), "placed"));
    orders.add(createOrder(13, 3, 2, new Date(), "placed"));
    orders.add(createOrder(14, 3, 2, new Date(), "placed"));
    orders.add(createOrder(15, 3, 2, new Date(), "placed"));
  }

  public Order findOrderById(long orderId) {
    for (Order order : orders) {
      if (order.getId() == orderId) {
        return order;
      }
    }
    return null;
  }

  public void placeOrder(Order order) {
    if (orders.size() > 0) {
      for (int i = orders.size() - 1; i >= 0; i--) {
        if (orders.get(i).getId() == order.getId()) {
          orders.remove(i);
        }
      }
    }
    orders.add(order);
  }

  public void deleteOrder(long orderId) {
    if (orders.size() > 0) {
      for (int i = orders.size() - 1; i >= 0; i--) {
        if (orders.get(i).getId() == orderId) {
          orders.remove(i);
        }
      }
    }
  }

  private static Order createOrder(long id, long petId, int quantity,
      Date shipDate, String status) {
    Order order = new Order();
    order.setId(id);
    order.setPetId(petId);
    order.setQuantity(quantity);
    order.setShipDate(shipDate);
    order.setStatus(status);
    return order;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_71a04d0_06cfbe1/rev_71a04d0-06cfbe1/modules/swagger-models/src/main/java/com/wordnik/swagger/models/properties/PropertyBuilder.java;<<<<<<< MINE
package com.wordnik.swagger.models.properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collections;
import java.util.List;
import java.util.Map;

public class PropertyBuilder {
  static Logger LOGGER = LoggerFactory.getLogger(PropertyBuilder.class);

  public static Property build(String type, String format, Map<PropertyId, Object> args) {
    if(args == null) {
      args = Collections.emptyMap();
    }

    List<String> _enum = PropertyId.ENUM.findValue(args);
    String title = PropertyId.TITLE.findValue(args);
    String description = PropertyId.DESCRIPTION.findValue(args);
    String _default = PropertyId.DEFAULT.findValue(args);
    String pattern = PropertyId.PATTERN.findValue(args);
    Integer minLength = PropertyId.MIN_LENGTH.findValue(args);
    Integer maxLength = PropertyId.MAX_LENGTH.findValue(args);
    Double minimum = PropertyId.MINIMUM.findValue(args);
    Double maximum = PropertyId.MAXIMUM.findValue(args);
    Boolean exclusiveMinimum = PropertyId.EXCLUSIVE_MINIMUM.findValue(args);
    Boolean exclusiveMaximum = PropertyId.EXCLUSIVE_MAXIMUM.findValue(args);

    AbstractProperty property = null;
    if(BooleanProperty.isType(type, format)) {
      property = new BooleanProperty()
        ._default(_default);
    }
    if(DateProperty.isType(type, format))
      property = new DateProperty();
    if(DateTimeProperty.isType(type, format))
      property = new DateTimeProperty();
    if(DoubleProperty.isType(type, format)) {
      property = new DoubleProperty()
        ._default(_default)
        .minimum(minimum)
        .maximum(maximum)
        .exclusiveMinimum(exclusiveMinimum)
        .exclusiveMaximum(exclusiveMaximum);
    }
    if(FloatProperty.isType(type, format)) {
      property = new FloatProperty()
        ._default(_default)
        .minimum(minimum)
        .maximum(maximum)
        .exclusiveMinimum(exclusiveMinimum)
        .exclusiveMaximum(exclusiveMaximum);
    }
    if(FileProperty.isType(type, format)) {
      property = new FileProperty();
    }
    if(DecimalProperty.isType(type, format))
      property = new DecimalProperty()
        .minimum(minimum)
        .maximum(maximum)
        .exclusiveMinimum(exclusiveMinimum)
        .exclusiveMaximum(exclusiveMaximum);
    if(IntegerProperty.isType(type, format)) {
      property = new IntegerProperty()
        ._default(_default)
        .minimum(minimum)
        .maximum(maximum)
        .exclusiveMinimum(exclusiveMinimum)
        .exclusiveMaximum(exclusiveMaximum);
    }
    if(LongProperty.isType(type, format)) {
      property = new LongProperty()
        ._default(_default)
        .minimum(minimum)
        .maximum(maximum)
        .exclusiveMinimum(exclusiveMinimum)
        .exclusiveMaximum(exclusiveMaximum);
    }
    if(RefProperty.isType(type, format))
      property = new RefProperty();
    if(EmailProperty.isType(type, format))
      property = new EmailProperty()
        .minLength(minLength)
        .maxLength(maxLength)
        .pattern(pattern)
        ._enum(_enum);
    if(StringProperty.isType(type, format)) {
      property = new StringProperty()
        ._default(_default)
        .minLength(minLength)
        .maxLength(maxLength)
        .pattern(pattern)
        ._enum(_enum);
    }
    if(UUIDProperty.isType(type, format)) {
      property = new UUIDProperty()
        ._default(_default)
        .minLength(minLength)
        .maxLength(maxLength)
        .pattern(pattern);
    }
    if(ByteArrayProperty.isType(type, format)){
        property = new ByteArrayProperty();
    }
    // general properties
    if(property != null) {
      property
        .title(title)
        .description(description);
      String example = PropertyId.EXAMPLE.findValue (args);
      if (example != null) {
        property.setExample(example);
      }
    }
    // fallbacks
    if("integer".equals(type) && format == null) {
        // fall back to Integer if type is integer and format is missing
      LOGGER.debug("no format specified for integer type, falling back to int32");
      property = new IntegerProperty()
        ._default(_default)
        .minimum(minimum)
        .maximum(maximum)
        .exclusiveMinimum(exclusiveMinimum)
        .exclusiveMaximum(exclusiveMaximum);
    }
    if(ObjectProperty.isType(type) && format == null) {
        // fall back to Map if type is object and format is missing
      LOGGER.debug("no format specified for object type, falling back to object");
      property = new ObjectProperty();
    }    
    if(property == null)
      LOGGER.debug("no property for " + type + ", " + format);
    return property;
  }

  public enum PropertyId {
    ENUM("enum"),
    TITLE("title"),
    DESCRIPTION("description"),
    DEFAULT("default"),
    PATTERN("pattern"),
    DESCRIMINATOR("discriminator"),
    MIN_ITEMS("minItems"),
    MAX_ITEMS("maxItems"),
    MIN_PROPERTIES("minProperties"),
    MAX_PROPERTIES("maxProperties"),
    MIN_LENGTH("minLength"),
    MAX_LENGTH("maxLength"),
    MINIMUM("minimum"),
    MAXIMUM("maximum"),
    EXCLUSIVE_MINIMUM("exclusiveMinimum"),
    EXCLUSIVE_MAXIMUM("exclusiveMaximum"),
    UNIQUE_ITEMS("uniqueItems"),
    EXAMPLE("example"),
    TYPE("type"),
    FORMAT("format");

    private String propertyName;

    private PropertyId(String propertyName) {
      this.propertyName = propertyName;
    }

    public String getPropertyName() {
      return propertyName;
    }

    public <T> T findValue(Map<PropertyId, Object> args) {
      return (T) args.get(this);
    }
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_71a04d0_06cfbe1/rev_71a04d0-06cfbe1/modules/swagger-models/src/main/java/com/wordnik/swagger/models/properties/StringProperty.java;<<<<<<< MINE
package com.wordnik.swagger.models.properties;

import com.wordnik.swagger.models.Xml;
import java.util.*;

public class StringProperty extends AbstractProperty implements Property {
  protected List<String> _enum;
  protected Integer minLength = null, maxLength = null;
  protected String pattern = null;
  protected String _default;

  public StringProperty() {
    super.type = "string";
  }
  public StringProperty xml(Xml xml) {
    this.setXml(xml);
    return this;
  }
  public StringProperty example(String example) {
    this.setExample(example);
    return this;
  }
  public StringProperty minLength(Integer minLength) {
    this.setMinLength(minLength);
    return this;
  }
  public StringProperty maxLength(Integer maxLength) {
    this.setMaxLength(maxLength);
    return this;
  }
  public StringProperty pattern(String pattern) {
    this.setPattern(pattern);
    return this;
  }
  public StringProperty _enum(String value) {
    if(this._enum == null)
      this._enum = new ArrayList<String>();
    if(!_enum.contains(value))
      _enum.add(value);
    return this;
  }
  public StringProperty _enum(List<String> value) {
    this._enum = value;
    return this;
  }
  public StringProperty _default(String _default) {
    this._default = _default;
    return this;
  }

  public List<String> getEnum() {
    return _enum;
  }
  public void setEnum(List<String> _enum) {
    this._enum = _enum;
  }

  public Integer getMinLength() {
    return minLength;
  }
  public void setMinLength(Integer minLength) {
    this.minLength = minLength;
  }

  public Integer getMaxLength() {
    return maxLength;
  }
  public void setMaxLength(Integer maxLength) {
    this.maxLength = maxLength;
  }

  public String getPattern() {
    return pattern;
  }
  public void setPattern(String pattern) {
    this.pattern = pattern;
  }

  public String getDefault() {
    return _default;
  }
  public void setDefault(String _default) {
    this._default = _default;
  }

  //TODO: implement additional formats
  public static boolean isType(String type, String format) {
    boolean formatMatchStringType = "uri".equals(format) || "url".equals(format);
    if("string".equals(type) && (format == null || formatMatchStringType))
      return true;
    else return false;
  }

  @Override
  public int hashCode() {
  	final int prime = 31;
  	int result = 1;
  	result = prime * result + ((_default == null) ? 0 : _default.hashCode());
  	result = prime * result + ((_enum == null) ? 0 : _enum.hashCode());
  	result = prime * result + ((maxLength == null) ? 0 : maxLength.hashCode());
  	result = prime * result + ((minLength == null) ? 0 : minLength.hashCode());
  	result = prime * result + ((pattern == null) ? 0 : pattern.hashCode());
  	return result;
  }

  @Override
  public boolean equals(Object obj) {
  	if (this == obj)
  		return true;
  	if (obj == null)
  		return false;
  	if (getClass() != obj.getClass())
  		return false;
  	StringProperty other = (StringProperty) obj;
  	if (_default == null) {
  		if (other._default != null)
  			return false;
  	} else if (!_default.equals(other._default))
  		return false;
  	if (_enum == null) {
  		if (other._enum != null)
  			return false;
  	} else if (!_enum.equals(other._enum))
  		return false;
  	if (maxLength == null) {
  		if (other.maxLength != null)
  			return false;
  	} else if (!maxLength.equals(other.maxLength))
  		return false;
  	if (minLength == null) {
  		if (other.minLength != null)
  			return false;
  	} else if (!minLength.equals(other.minLength))
  		return false;
  	if (pattern == null) {
  		if (other.pattern != null)
  			return false;
  	} else if (!pattern.equals(other.pattern))
  		return false;
  	return true;
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_47535a5_5a3f677/rev_47535a5-5a3f677/modules/swagger-jaxrs/src/test/scala/resources/ResourceWithConfigAndExtensions.java;<<<<<<< MINE
package resources;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import io.swagger.annotations.Contact;
import io.swagger.annotations.Extension;
import io.swagger.annotations.ExtensionProperty;
import io.swagger.annotations.ExternalDocs;
import io.swagger.annotations.Info;
import io.swagger.annotations.License;
import io.swagger.annotations.SwaggerDefinition;
import io.swagger.annotations.Tag;
import io.swagger.jaxrs.Reader;
import io.swagger.jaxrs.config.ReaderListener;
import io.swagger.models.Swagger;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import java.util.ArrayList;

@SwaggerDefinition(
        info = @Info(
                description = "Custom description",
                version = "V1.2.3",
                title = "TheAwesomeApi",
                termsOfService = "do-what-you-want",
                contact = @Contact(name = "Sponge-Bob", email = "sponge-bob@swagger.io", url = "http://swagger.io"),
                license = @License(name = "Apache 2.0", url = "http://www.apache.org"),
                extensions = {
                        @Extension(properties = {
                                @ExtensionProperty(name = "test1", value = "value1"),
                                @ExtensionProperty(name = "test2", value = "value2")
                        }),
                        @Extension(name = "test", properties = {
                                @ExtensionProperty(name = "test1", value = "value1"),
                                @ExtensionProperty(name = "test2", value = "value2")
                        })
                }
        ),
        consumes = {"application/json", "application/xml"},
        produces = {"application/json", "application/xml"},
        schemes = {SwaggerDefinition.Scheme.HTTP, SwaggerDefinition.Scheme.HTTPS},
        tags = {
                @Tag(name = "mytag", description = "my tag"),
                @Tag(name = "anothertag", description = "another tag",
                        externalDocs = @ExternalDocs(value = "test", url = "http://swagger.io")),
                @Tag(name = "tagwithextensions", description = "my tag",
                        extensions = @Extension(properties = {@ExtensionProperty(name = "test", value = "value")}))
        }, externalDocs = @ExternalDocs(value = "test", url = "http://swagger.io")
)
@Api(value = "/external/info/")
@Path("who/cares")
public class ResourceWithConfigAndExtensions implements ReaderListener {
    @ApiOperation(value = "test.", tags = {"tagwithextensions", "mytag", "testingtag"}, extensions = {
            @Extension(properties = @ExtensionProperty(name = "test", value = "value"))
    })
    @GET
    public void getTest(@ApiParam(value = "test") ArrayList<String> tenantId) {
        return;
    }

    @Override
    public void beforeScan(Reader reader, Swagger swagger) {
        swagger.addTag(new io.swagger.models.Tag().name("Tag-added-before-read"));
    }

    @Override
    public void afterScan(Reader reader, Swagger swagger) {
        swagger.addTag(new io.swagger.models.Tag().name("Tag-added-after-read"));
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_fe71f6d_cea99b5/rev_fe71f6d-cea99b5/modules/swagger-jaxrs/src/test/scala/resources/ResourceWithKnownInjections.java;<<<<<<< MINE
package resources;

import io.swagger.annotations.Api;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.Request;

@Path("/resource/{id}")
@Api(value = "/resource", description = "Summary of injections resource")
@Produces({"application/json", "application/xml"})
public class ResourceWithKnownInjections {

    private Integer constructorParam;
    @QueryParam("fieldParam")
    private String fieldParam; // injection into a class field

    // injection into a constructor parameter
    public ResourceWithKnownInjections(@PathParam("id") Integer constructorParam) {
        this.constructorParam = constructorParam;
    }

    private ResourceWithKnownInjections(@PathParam("id") Integer constructorParam, @QueryParam("fakeParam") String
            fakeParam) {
        this.constructorParam = constructorParam;
    }

    @GET
    public String get(@QueryParam("methodParam") String methodParam) {
        // injection into a resource method parameter
        final StringBuilder sb = new StringBuilder();
        sb.append("Constructor param: ").append(constructorParam).append("\n");
        sb.append("Field param: ").append(fieldParam).append("\n");
        sb.append("Method param: ").append(methodParam).append("\n");
        return sb.toString();
    }

    @Path("/subresource1")
    public SubResource1 subResourceLocator1(@QueryParam("subResourceParam") String subResourceParam) {
        // injection into a sub resource locator parameter
        return new SubResource1(subResourceParam);
    }

    @Path("/subresource2")
    public Class<SubResource2> subResourceLocator2(@QueryParam("subResourceParam") String subResourceParam) {
        // injection into a sub resource locator parameter
        return SubResource2.class;
    }

    @Path("/subresource3")
    public Class<SubResource3> subResourceLocator3(@QueryParam("subResourceParam") String subResourceParam) {
        // injection into a sub resource locator parameter
        return SubResource3.class;
    }

    @Context
    public void setRequest(Request request) {
        // injection into a setter method
    }

    @Api(description = "Sub resource 1")
    public static class SubResource1 {

        private String subResourceParam;

        public SubResource1(String subResourceParam) {
            this.subResourceParam = subResourceParam;
        }

        @GET
        public String get() {
            final StringBuilder sb = new StringBuilder();
            sb.append("Sub Resource: ").append(subResourceParam);
            return sb.toString();
        }
    }

    @Api(description = "Sub resource 2")
    public static class SubResource2 {

        private String subResourceParam;

        public SubResource2(@QueryParam("subConstructorParam") String subResourceParam) {
            this.subResourceParam = subResourceParam;
        }

        @GET
        public String get() {
            final StringBuilder sb = new StringBuilder();
            sb.append("Sub Resource: ").append(subResourceParam);
            return sb.toString();
        }
    }

    @Api(description = "Sub resource 3")
    public class SubResource3 {

        private String subResourceParam;

        public SubResource3(@QueryParam("subConstructorParam") String subResourceParam) {
            this.subResourceParam = subResourceParam;
        }

        @GET
        public String get() {
            final StringBuilder sb = new StringBuilder();
            sb.append("Sub Resource: ").append(subResourceParam);
            return sb.toString();
        }
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_2338ebe_a2a9a04/rev_2338ebe-a2a9a04/modules/swagger-jaxrs/src/test/java/io/swagger/models/Sample.java;<<<<<<< MINE
=======
package io.swagger.models;

public class Sample {
    String name;
    String value;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_2338ebe_a2a9a04/rev_2338ebe-a2a9a04/modules/swagger-jaxrs/src/test/java/io/swagger/models/duplicated/Tag.java;<<<<<<< MINE
=======
package io.swagger.models.duplicated;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement(name = "Tag")
public class Tag {
    private long id;
    private String name;

    @XmlElement(name = "id")
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    @XmlElement(name = "name")
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_36a5d31_0553cfb/rev_36a5d31-0553cfb/modules/swagger-jersey2-jaxrs/src/test/java/io/swagger/models/Pagination.java;<<<<<<< MINE
=======
package io.swagger.models;

import io.swagger.annotations.ApiParam;

import javax.ws.rs.QueryParam;

public class Pagination {
    @QueryParam("skip")
    @ApiParam("number of records to skip")
    protected Integer skip;

    @QueryParam("limit")
    @ApiParam("maximum number of records to return")
    protected Integer limit;

    public Integer getSkip() {
        return skip;
    }

    public void setSkip(Integer skip) {
        this.skip = skip;
    }

    public Integer getLimit() {
        return limit;
    }

    public void setLimit(Integer limit) {
        this.limit = limit;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_72b588a_0567e01/rev_72b588a-0567e01/modules/swagger-jaxrs/src/test/java/io/swagger/resources/BaseResource.java;<<<<<<< MINE
=======
package io.swagger.resources;

import io.swagger.annotations.ApiParam;

import javax.ws.rs.PathParam;
import javax.ws.rs.QueryParam;

public class BaseResource {
    @ApiParam("The Identifier of entity")
    @PathParam("id")
    private String id;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    @ApiParam("Base description")
    @PathParam("description")
    private String description = "base";

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    @ApiParam(value = "Test Query Param")
    @QueryParam("test")
    protected boolean test;
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_72b588a_0567e01/rev_72b588a-0567e01/modules/swagger-jaxrs/src/test/java/io/swagger/resources/generics/UserEntity.java;<<<<<<< MINE
=======
package io.swagger.resources.generics;

import io.swagger.annotations.ApiModel;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement
@ApiModel(value = "UserEntity")
@XmlAccessorType(XmlAccessType.FIELD)
public class UserEntity extends AbstractEntity {
    public String name;
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_72b588a_0567e01/rev_72b588a-0567e01/modules/swagger-jaxrs/src/test/java/io/swagger/resources/generics/UserApiRoute.java;<<<<<<< MINE
=======
package io.swagger.resources.generics;

import io.swagger.annotations.Api;

import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/api/users")
@Api(value = "/users")
@Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
public class UserApiRoute extends ApiCrudRoute<UserEntity> {

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_72b588a_0567e01/rev_72b588a-0567e01/modules/swagger-jaxrs/src/test/java/io/swagger/resources/generics/AbstractEntity.java;<<<<<<< MINE
=======
package io.swagger.resources.generics;

import java.io.Serializable;

public abstract class AbstractEntity implements Serializable {
    public String id;
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_72b588a_0567e01/rev_72b588a-0567e01/modules/swagger-jaxrs/src/test/java/io/swagger/resources/generics/ApiCrudRoute.java;<<<<<<< MINE
=======
package io.swagger.resources.generics;

import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import io.swagger.models.Response;

import java.util.List;

import javax.ws.rs.POST;

public abstract class ApiCrudRoute<T extends AbstractEntity> {
    protected List<T> service;

    @POST
    @ApiOperation(value = "Create")
    public Response doCreate(
            @ApiParam(value = "Create object", required = true) T entity) throws Exception {
        service.add(entity);
        return new Response();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_72b588a_0567e01/rev_72b588a-0567e01/modules/swagger-jersey2-jaxrs/src/test/java/io/swagger/resources/ResourceWithFormData.java;<<<<<<< MINE
=======
package io.swagger.resources;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;

import org.glassfish.jersey.media.multipart.FormDataContentDisposition;
import org.glassfish.jersey.media.multipart.FormDataBodyPart;
import org.glassfish.jersey.media.multipart.FormDataParam;

import java.io.InputStream;

import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

@Path("test")
@Api(value = "test", description = "test routes", produces = "application/json")
public class ResourceWithFormData {

    @POST
    @Path("/document/{documentName}.json")
    @ApiOperation(value = "uploadAttachAndParseUserDocument", notes = "Uploads, parses, and attaches the document to the user's job application.", position = 509)
    public String uploadAttachAndParseUserDocument(@PathParam("documentName") final String documentName,
                                                   @FormDataParam("document") final FormDataContentDisposition detail,
                                                   @FormDataParam("document2") final FormDataBodyPart bodyPart,
                                                   @FormDataParam("input") final InputStream input,
                                                   @FormDataParam("id") final Integer id) throws Exception {
        return "";
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/Swagger-core/revisions/rev_e661e1a_9a6cf32/rev_e661e1a-9a6cf32/modules/swagger-core/src/test/java/io/swagger/reflection/IParent.java;<<<<<<< MINE
public interface IParent<T extends Number> extends IGrandparent<T> {
=======
@IndirectAnnotation
public interface IParent<T extends Number> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c/tests/com/google/bitcoin/core/AlertMessageTest.java;<<<<<<< MINE
=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import org.bouncycastle.util.encoders.Hex;
import org.junit.Before;
import org.junit.Test;

import java.math.BigInteger;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertTrue;

public class AlertMessageTest {
    private static final byte[] TEST_KEY_PRIV = Hex.decode("6421e091445ade4b24658e96aa60959ce800d8ea9e7bd8613335aa65ba8d840b");
    private NetworkParameters params;

    @Before
    public void setUp() throws Exception {
        ECKey key = new ECKey(new BigInteger(1, TEST_KEY_PRIV));
        params = NetworkParameters.unitTests();
        params.alertSigningKey = key.getPubKey();
    }

    @Test
    public void deserialize() throws Exception {
        // A CAlert taken from the reference implementation.
        // TODO: This does not check the subVer or set fields. Support proper version matching.
        final byte[] payload = Hex.decode("5c010000004544eb4e000000004192ec4e00000000eb030000e9030000000000000048ee00000088130000002f43416c6572742073797374656d20746573743a2020202020202020207665722e302e352e3120617661696c61626c6500473045022100ec799908c008b272d5e5cd5a824abaaac53d210cc1fa517d8e22a701ecdb9e7002206fa1e7e7c251d5ba0d7c1fe428fc1870662f2927531d1cad8d4581b45bc4f8a7");
        AlertMessage alert = new AlertMessage(params, payload);
        assertEquals(1324041285, alert.getRelayUntil().getTime() / 1000);
        assertEquals(1324126785, alert.getExpiration().getTime() / 1000);
        assertEquals(1003, alert.getId());
        assertEquals(1001, alert.getCancel());
        assertEquals(0, alert.getMinVer());
        assertEquals(61000, alert.getMaxVer());
        assertEquals(5000, alert.getPriority());
        assertEquals("CAlert system test:         ver.0.5.1 available", alert.getStatusBar());
        assertTrue(alert.isSignatureValid());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/bitcoinj/revisions/rev_464b528_10c936c/rev_464b528-10c936c/src/com/google/bitcoin/core/AlertMessage.java;<<<<<<< MINE
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();

        length = cursor - offset;
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}=======
/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.bitcoin.core;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

/**
 * Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 * The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 * an available upgrade or a serious network problem. Alerts have an expiration time, data that specifies what
 * set of software versions it matches and the ability to cancel them by broadcasting another type of alert.<p>
 *
 * The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 * log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 * For example, you could treat it as an upgrade notification specific to your app. Satoshi designed alerts to ensure
 * that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 * be purely peer-to-peer. You don't have to use this of course, and indeed it often makes more sense not to.<p>
 *     
 * Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.
 */
public class AlertMessage extends Message {
    private byte[] content;
    private byte[] signature;

    // See the getters for documentation of what each field means.
    private long version = 1;
    private Date relayUntil;
    private Date expiration;
    private long id;
    private long cancel;
    private Set<Long> cancelSet;
    private long minVer, maxVer;
    private Set<String> matchingSubVers;
    private long priority;
    private String comment, statusBar, reserved;

    // Chosen arbitrarily to avoid memory blowups.
    private static final long MAX_SET_SIZE = 100;

    public AlertMessage(NetworkParameters params, byte[] payloadBytes) throws ProtocolException {
        super(params, payloadBytes, 0);
    }

    @Override
    void parse() throws ProtocolException {
        // Alerts are formatted in two levels. The top level contains two byte arrays: a signature, and a serialized
        // data structure containing the actual alert data.
        int startPos = cursor;
        content = readByteArray();
        signature = readByteArray();
        // Now we need to parse out the contents of the embedded structure. Rewind back to the start of the message.
        cursor = startPos;
        readVarInt();  // Skip the length field on the content array.
        // We're inside the embedded structure.
        version = readUint32();
        // Read the timestamps. Bitcoin uses seconds since the epoch.
        relayUntil = new Date(readUint64().longValue() * 1000);
        expiration = new Date(readUint64().longValue() * 1000);
        id = readUint32();
        cancel = readUint32();
        // Sets are serialized as <len><item><item><item>....
        long cancelSetSize = readVarInt();
        if (cancelSetSize < 0 || cancelSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad cancel set size: " + cancelSetSize);
        }
        // Using a hashset here is very inefficient given that this will normally be only one item. But Java doesn't
        // make it easy to do better. What we really want is just an array-backed set.
        cancelSet = new HashSet<Long>((int)cancelSetSize);
        for (long i = 0; i < cancelSetSize; i++) {
            cancelSet.add(readUint32());
        }
        minVer = readUint32();
        maxVer = readUint32();
        // Read the subver matching set.
        long subverSetSize = readVarInt();
        if (subverSetSize < 0 || subverSetSize > MAX_SET_SIZE) {
            throw new ProtocolException("Bad subver set size: " + subverSetSize);
        }
        matchingSubVers = new HashSet<String>((int)subverSetSize);
        for (long i = 0; i < subverSetSize; i++) {
            matchingSubVers.add(readStr());
        }
        priority = readUint32();
        comment = readStr();
        statusBar = readStr();
        reserved = readStr();
    }

    /**
     * Returns true if the digital signature attached to the message verifies. Don't do anything with the alert if it
     * doesn't verify, because that would allow arbitrary attackers to spam your users.
     */
    public boolean isSignatureValid() {
        return ECKey.verify(Utils.doubleDigest(content), signature, params.alertSigningKey);
    }

    @Override
    protected void parseLite() throws ProtocolException {
        // Do nothing, lazy parsing isn't useful for alerts.
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  Field accessors.

    /**
     * The time at which the alert should stop being broadcast across the network. Note that you can still receive
     * the alert after this time from other nodes if the alert still applies to them or to you.
     */
    public Date getRelayUntil() {
        return relayUntil;
    }

    public void setRelayUntil(Date relayUntil) {
        this.relayUntil = relayUntil;
    }

    /**
     * The time at which the alert ceases to be relevant. It should not be presented to the user or app administrator
     * after this time.
     */
    public Date getExpiration() {
        return expiration;
    }

    public void setExpiration(Date expiration) {
        this.expiration = expiration;
    }

    /**
     * The numeric identifier of this alert. Each alert should have a unique ID, but the signer can choose any number.
     * If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     * @return uint32
     */
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    /**
     * A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     * @return uint32
     */
    public long getCancel() {
        return cancel;
    }

    public void setCancel(long cancel) {
        this.cancel = cancel;
    }

    /**
     * The inclusive lower bound on software versions that are considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return uint32
     */
    public long getMinVer() {
        return minVer;
    }

    public void setMinVer(long minVer) {
        this.minVer = minVer;
    }

    /**
     * The inclusive upper bound on software versions considered for the purposes of this alert. The Satoshi
     * client compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     * alerts could use any version numbers.
     * @return
     */
    public long getMaxVer() {
        return maxVer;
    }

    public void setMaxVer(long maxVer) {
        this.maxVer = maxVer;
    }

    /**
     * Provides an integer ordering amongst simultaneously active alerts.
     * @return uint32
     */
    public long getPriority() {
        return priority;
    }

    public void setPriority(long priority) {
        this.priority = priority;
    }

    /**
     * This field is unused. It is presumably intended for the author of the alert to provide a justification for it
     * visible to protocol developers but not users.
     */
    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    /**
     * A string that is intended to display in the status bar of the official GUI client. It contains the user-visible
     * message. English only.
     */
    public String getStatusBar() {
        return statusBar;
    }

    public void setStatusBar(String statusBar) {
        this.statusBar = statusBar;
    }

    /**
     * This field is never used.
     */
    public String getReserved() {
        return reserved;
    }

    public void setReserved(String reserved) {
        this.reserved = reserved;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/truth/revisions/rev_4f20749_ae32b4c/rev_4f20749-ae32b4c/src/main/java/org/junit/contrib/truth/subjects/Subject.java;<<<<<<< MINE

  /**
   * A convenience class to allow for chaining in the fluent API
   * style, such that subjects can make propositions in series.  
   * i.e. ASSERT.that(blah).isNotNull().and().contains(b).and().isNotEmpty();
   */
  public static interface And<C> {
    /**
     * Returns the next object in the chain of anded objects.
     */
    C and();
  }
=======
  
  protected void failWithoutSubject(String verb) {
    String message = "Not true that ";
    message += "the subject " + verb;
    failureStrategy.fail(message);
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_78dc0b2_e299b19/rev_78dc0b2-e299b19/src/main/java/com/netflix/servo/jmx/DefaultMonitorRegistry.java;<<<<<<< MINE
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.jmx;

import java.util.Properties;

public class DefaultMonitorRegistry implements MonitorRegistry {

    private static final String REGISTRY_CLASS_PROP =
        "com.netflix.monitoring.registryClass";

    private static MonitorRegistry INSTANCE = new DefaultMonitorRegistry();

    private final MonitorRegistry mRegistry;

    public static MonitorRegistry getInstance() {
        return INSTANCE;
    }

    DefaultMonitorRegistry() {
        this(System.getProperties());
    }

    DefaultMonitorRegistry(Properties props) {
        String className = props.getProperty(REGISTRY_CLASS_PROP);
        if (className != null) {
            try {
                Class<?> c = Class.forName(className);
                mRegistry = (MonitorRegistry) c.newInstance();
            } catch (Throwable t) {
                throw new IllegalArgumentException(
                    "failed to create instance of class " + className, t);
            }
        } else {
            mRegistry = new JmxMonitorRegistry();
        }
    }

    public void registerObject(Object obj) {
        mRegistry.registerObject(obj);
    }

    public void unRegisterObject(Object obj) {
        mRegistry.unRegisterObject(obj);
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/truth/revisions/rev_d976c7e_8244a00/rev_d976c7e-8244a00/src/main/java/org/junit/contrib/truth/subjects/IntSubject.java;<<<<<<< MINE
/*
 * Copyright (c) 2011 David Saff
 * Copyright (c) 2011 Christian Gruber
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.junit.contrib.truth.subjects;

import org.junit.contrib.truth.FailureStrategy;

public class IntSubject extends Subject<IntSubject, Integer> {

  private static final String RANGE_BOUNDS_OUT_OF_ORDER_MSG = "Range inclusion parameter lower (%d) should not be greater than upper (%d)";

  public IntSubject(FailureStrategy failureStrategy, int i) {
    super(failureStrategy, i);
  }

  /**
   * Attests that a Subject<Integer> is inclusively within the {@code lower} and
   * {@code upper} bounds provided or fails.
   * 
   * @throws IllegalArgumentException
   *           if the lower bound is greater than the upper.
   */
  public And<IntSubject> isInclusivelyInRange(int lower, int upper) {
    if (lower > upper) {
      throw new IllegalArgumentException(String.format(
          RANGE_BOUNDS_OUT_OF_ORDER_MSG, lower, upper));
    }
    if (!(lower <= getSubject() && getSubject() <= upper)) {
      fail("is inclusively in range", lower, upper);
    }
    return nextChain();
  }

  /**
   * Attests that a Subject<Integer> is exclusively within the {@code lower} and
   * {@code upper} bounds provided or fails.
   * 
   * @throws IllegalArgumentException
   *           if the lower bound is greater than the upper.
   */
  public And<IntSubject> isBetween(int lower, int upper) {
    if (lower > upper) {
      throw new IllegalArgumentException(String.format(
          RANGE_BOUNDS_OUT_OF_ORDER_MSG, lower, upper));
    }
    if (!(lower < getSubject() && getSubject() < upper)) {
      fail("is in between", lower, upper);
    }
    return nextChain();
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_7a765fc_e22534f/rev_7a765fc-e22534f/src/sample/java/com/netflix/servo/sample/SimpleSample.java;<<<<<<< MINE
=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.sample;

import com.netflix.servo.DefaultMonitorRegistry;
import com.netflix.servo.InjectableTag;
import com.netflix.servo.MonitorRegistry;
import com.netflix.servo.Tag;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.annotations.Monitor;
import com.netflix.servo.annotations.MonitorTags;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * User: gorzell
 * Date: 1/6/12
 * Time: 12:45 PM
 */
public class SimpleSample {

    @Monitor(name = "SampleCounter", type = DataSourceType.COUNTER,
            description = "Sample counting monitor", tags = {
            "sample=simple"})
    public final AtomicInteger counter = new AtomicInteger(0);

    @Monitor(name = "SampleGauge", type = DataSourceType.GAUGE,
            description = "Sample gauge monitor", tags = {
            "sample=simple"})
    private long sampleGuage = 0;

    @MonitorTags
    public final List<Tag> tagList = new ArrayList<Tag>(10);

    public SimpleSample() {
    }

    public SimpleSample(Collection<Tag> tags) {
        tagList.addAll(tags);
    }
    
    public synchronized void setSampleGauage(long val){
        sampleGuage = val;
    }
    
    public synchronized long getSampleGuage(){
        return sampleGuage;
    }

    public static void main(String[] args) throws InterruptedException {
        List<Tag> tags = new ArrayList<Tag>(2);
        tags.add(InjectableTag.HOSTNAME);
        tags.add(InjectableTag.IP);
        
        SimpleSample sample = new SimpleSample(tags);

        DefaultMonitorRegistry.getInstance().registerObject(sample);
        
        while(true){
            sample.counter.incrementAndGet();
            sample.setSampleGauage(Math.round(Math.random()*1000));
            Thread.sleep(60000);
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_7a765fc_e22534f/rev_7a765fc-e22534f/src/main/java/com/netflix/servo/publish/BaseMetricObserver.java;<<<<<<< MINE
=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.annotations.Monitor;
import com.netflix.servo.annotations.MonitorId;

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * User: gorzell
 * Date: 1/3/12
 * Time: 11:33 AM
 */
public abstract class BaseMetricObserver implements MetricObserver {
    @MonitorId
    protected final String name;
    @Monitor(name="UpdateCount", type= DataSourceType.COUNTER,
             description="Total number of times update has been called on "
                        +"the wrapped observer.")
    protected final AtomicInteger updateCount = new AtomicInteger(0);
    @Monitor(name="UpdateFailureCount", type= DataSourceType.COUNTER,
             description="Number of times the update call on the wrapped "
                        +"observer failed with an exception.")
    protected final AtomicInteger failedUpdateCount = new AtomicInteger(0);

    public BaseMetricObserver(String name) {
        this.name = Preconditions.checkNotNull(name);
    }

    public abstract void update(List<Metric> metrics);
    
    public String getName(){
        return this.name;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_7a765fc_e22534f/rev_7a765fc-e22534f/src/main/java/com/netflix/servo/publish/MemoryMetricObserver.java;<<<<<<< MINE
=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;

import com.google.common.collect.ImmutableList;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Keeps the last N observations in-memory.
 */
public final class MemoryMetricObserver extends BaseMetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(MemoryMetricObserver.class);

    private final List<Metric>[] mObservations;
    private int mNext;

    public MemoryMetricObserver() {
        this("unamed observer", 10);
    }

    @SuppressWarnings("unchecked")
    public MemoryMetricObserver(String name, int num) {
        super(name);
        mObservations = (List<Metric>[]) new List[num];
        mNext = 0;
    }

    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        mObservations[mNext] = metrics;
        mNext = (mNext + 1) % mObservations.length;
    }

    public List<List<Metric>> getObservations() {
        ImmutableList.Builder<List<Metric>> builder = ImmutableList.builder();
        int pos = mNext;
        for (int i = 0; i < mObservations.length; ++i) {
            if (mObservations[pos] != null) {
                builder.add(mObservations[pos]);
            }
            pos = (pos + 1) % mObservations.length;
        }
        return builder.build();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_7a765fc_e22534f/rev_7a765fc-e22534f/src/main/java/com/netflix/servo/publish/AsyncMetricObserver.java;<<<<<<< MINE
=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.annotations.Monitor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Wraps another observer and asynchronously updates it in the background. The
 * update call will always return immediately. If the queue fills up newer
 * updates will overwrite older updates.
 * <p/>
 * If an exception is thrown when calling update on wrapped observer it will
 * be logged, but otherwise ignored.
 */
public class AsyncMetricObserver extends BaseMetricObserver {

    private static final Logger log = LoggerFactory.getLogger(AsyncMetricObserver.class);

    private final MetricObserver wrappedObserver;

    private final int updateQueueSize;
    private final long expireTime;
    private final BlockingQueue<TimestampedUpdate> updateQueue;

    private final Thread updateProcessingThread;

    @Monitor(name = "UpdateExpiredCount", type = DataSourceType.COUNTER,
            description = "Number of times the update call was skipped because the update was expired")
    protected final AtomicInteger expiredUpdateCount = new AtomicInteger(0);

    public AsyncMetricObserver(String name, MetricObserver observer, int queueSize, long expireTime) {
        super(name);
        this.expireTime = expireTime;
        wrappedObserver = Preconditions.checkNotNull(observer);
        updateQueueSize = queueSize;
        Preconditions.checkArgument(queueSize >= 1,
                "invalid queueSize %d, size must be >= 1", updateQueueSize);

        updateQueue = new LinkedBlockingDeque<TimestampedUpdate>(updateQueueSize);

        String threadName = getClass().getSimpleName() + "-" + this.name;
        updateProcessingThread = new Thread(new UpdateProcessor(), threadName);
        updateProcessingThread.setDaemon(true);
        updateProcessingThread.start();
    }

    public AsyncMetricObserver(String name, MetricObserver observer) {
        this(name, observer, Integer.MAX_VALUE, Long.MAX_VALUE);
    }

    public AsyncMetricObserver(String name, MetricObserver observer, int queueSize) {
        this(name, observer, queueSize, Long.MAX_VALUE);
    }

    public AsyncMetricObserver(String name, MetricObserver observer, long expireTime) {
        this(name, observer, Integer.MAX_VALUE, expireTime);
    }

    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        TimestampedUpdate update = new TimestampedUpdate(System.currentTimeMillis(), metrics);
        boolean result = updateQueue.offer(update);
        while (!result) {
            updateQueue.remove();
            result = updateQueue.offer(update);
        }
    }

    private void processUpdate() {
        TimestampedUpdate update;
        try {
            update = updateQueue.take();

            long cutoff = System.currentTimeMillis() - expireTime;
            if (update.getTimestamp() < cutoff) {
                expiredUpdateCount.incrementAndGet();
                return;
            }

            wrappedObserver.update(update.getMetrics());
        } catch (InterruptedException ie){
            log.warn("Interrupted while adding to queue, update dropped");
            failedUpdateCount.incrementAndGet();
        } catch (Throwable t) {
            log.warn("update failed for downstream queue", t);
            failedUpdateCount.incrementAndGet();
        } finally {
            updateCount.incrementAndGet();
        }
    }

    private class UpdateProcessor implements Runnable {
        public void run() {
            while (true) {
                processUpdate();
            }
        }
    }

    private class TimestampedUpdate {
        private final long timestamp;
        private final List<Metric> metrics;

        public TimestampedUpdate(long timestamp, List<Metric> metrics) {
            this.timestamp = timestamp;
            this.metrics = metrics;
        }

        long getTimestamp() {
            return timestamp;
        }

        List<Metric> getMetrics() {
            return metrics;
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_7a765fc_e22534f/rev_7a765fc-e22534f/src/main/java/com/netflix/servo/publish/FileMetricObserver.java;<<<<<<< MINE
=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.io.Closeables;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

import java.text.SimpleDateFormat;

import java.util.Date;
import java.util.List;
import java.util.TimeZone;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Writes observations to a file. The format is a basic text file with tabs
 * separating the fields.
 */
public final class FileMetricObserver extends BaseMetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(FileMetricObserver.class);

    private static final String FILE_DATE_FORMAT = "yyyy_dd_MM_HH_mm_ss_SSS";
    private static final String ISO_DATE_FORMAT = "yyyy-dd-MM'T'HH:mm:ss.SSS";

    private final File dir;

    private final SimpleDateFormat fileFormat;
    private final SimpleDateFormat isoFormat;

    public FileMetricObserver(String name, File dir) {
        this(name, dir, String.format("'%s'_%s'.log'", name, FILE_DATE_FORMAT));
    }

    public FileMetricObserver(String name, File dir, String namePattern) {
        super(name);
        this.dir = dir;
        fileFormat = new SimpleDateFormat(namePattern);
        fileFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
        isoFormat = new SimpleDateFormat(ISO_DATE_FORMAT);
        isoFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
    }

    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        File file = new File(dir, fileFormat.format(new Date()));
        Writer out = null;
        try {
            LOGGER.debug("writing %d metrics to file %s", metrics.size(), file);
            out = new FileWriter(file, true);
            for (Metric m : metrics) {
                String timestamp = isoFormat.format(new Date(m.timestamp()));
                out.append(m.name()).append('\t')
                   .append(m.tags().toString()).append('\t')
                   .append(timestamp).append('\t')
                   .append(m.value().toString()).append('\n');
            }
        } catch (IOException e) {
            LOGGER.error("failed to write update to file " + file, e);
        } finally {
            Closeables.closeQuietly(out);
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_7a765fc_e22534f/rev_7a765fc-e22534f/src/test/java/com/netflix/servo/test/TestMonitor.java;<<<<<<< MINE
=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.test;

import com.netflix.servo.Tag;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.annotations.Monitor;
import com.netflix.servo.annotations.MonitorId;
import com.netflix.servo.annotations.MonitorTags;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * User: gorzell
 * Date: 1/6/12
 * Time: 12:30 PM
 */
public class TestMonitor {
    
    @Monitor(name="TestMonitor", type = DataSourceType.COUNTER,
            description = "Monitor for doing testing", tags = {
            "tag1=foo", "tag2=bar"})
    public final AtomicInteger counter = new AtomicInteger(0);
    
    @MonitorId
    public final String name = "testMonitor";
    
    @MonitorTags
    public final List<Tag> tagList = new ArrayList<Tag>(10);
    
    public TestMonitor(){}
    
    public TestMonitor(Collection<Tag> tags){
        tagList.addAll(tags);
    }

    public void increment(){
        counter.incrementAndGet();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_2319e19_08f3409/rev_2319e19-08f3409/src/main/java/com/netflix/servo/jmx/MetadataMBean.java;<<<<<<< MINE
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.jmx;

import java.util.Map;

import javax.management.Attribute;
import javax.management.AttributeList;
import javax.management.AttributeNotFoundException;
import javax.management.DynamicMBean;
import javax.management.MBeanException;
import javax.management.MBeanInfo;
import javax.management.ObjectName;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

class MetadataMBean implements DynamicMBean {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(MetadataMBean.class);

    private final ObjectName mName;

    private final MBeanInfo mBeanInfo;

    private final Map<String,MonitoredAttribute> mAttrs;

    MetadataMBean(
            ObjectName name,
            MBeanInfo beanInfo,
            Map<String,MonitoredAttribute> attrs) {
        mName = name;
        mBeanInfo = beanInfo;
        mAttrs = attrs;
    }

    public ObjectName getObjectName() {
        return mName;
    }

    public Object getAttribute(String attribute)
            throws AttributeNotFoundException, MBeanException {
        MonitoredAttribute attr = mAttrs.get(attribute);
        if (attr == null) {
            throw new AttributeNotFoundException(attribute);
        }
        try {
            return attr.metadata();
        } catch (Exception e) {
            throw new MBeanException(e);
        }
    }

    public AttributeList getAttributes(String[] attributes) {
        AttributeList list = new AttributeList();
        for (String a : attributes) {
            try {
                list.add(new Attribute(a, getAttribute(a)));
            } catch (Exception e) {
                LOGGER.warn("getAttribute() failed for " + a, e);
            }
        }
        return list;
    }

    public MBeanInfo getMBeanInfo() {
        return mBeanInfo;
    }

    public Object invoke(
            String actionName, Object[] params, String[] signature) {
        throw new UnsupportedOperationException(
            "invoke(...) is not supported on this mbean");
    }

    public void setAttribute(Attribute attribute) {
        throw new UnsupportedOperationException(
            "setAttribute(...) is not supported on this mbean");
    }

    public AttributeList setAttributes(AttributeList attributes) {
        throw new UnsupportedOperationException(
            "setAttributes(...) is not supported on this mbean");
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_2319e19_08f3409/rev_2319e19-08f3409/src/main/java/com/netflix/servo/publish/AsyncMetricObserver.java;<<<<<<< MINE
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.annotations.Monitor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Wraps another observer and asynchronously updates it in the background. The
 * update call will always return immediately. If the queue fills up newer
 * updates will overwrite older updates.
 * <p/>
 * If an exception is thrown when calling update on wrapped observer it will
 * be logged, but otherwise ignored.
 */
public class AsyncMetricObserver extends BaseMetricObserver {

    private static final Logger log = LoggerFactory.getLogger(AsyncMetricObserver.class);

    private final MetricObserver wrappedObserver;

    private final int updateQueueSize;
    private final long expireTime;
    private final BlockingQueue<TimestampedUpdate> updateQueue;

    private final Thread updateProcessingThread;

    @Monitor(name = "UpdateExpiredCount", type = DataSourceType.COUNTER,
            description = "Number of times the update call was skipped because the update was expired")
    protected final AtomicInteger expiredUpdateCount = new AtomicInteger(0);

    public AsyncMetricObserver(String name, MetricObserver observer, int queueSize, long expireTime) {
        super(name);
        this.expireTime = expireTime;
        wrappedObserver = Preconditions.checkNotNull(observer);
        updateQueueSize = queueSize;
        Preconditions.checkArgument(queueSize >= 1,
                "invalid queueSize %d, size must be >= 1", updateQueueSize);

        updateQueue = new LinkedBlockingDeque<TimestampedUpdate>(updateQueueSize);

        String threadName = getClass().getSimpleName() + "-" + this.name;
        updateProcessingThread = new Thread(new UpdateProcessor(), threadName);
        updateProcessingThread.setDaemon(true);
        updateProcessingThread.start();
    }

    public AsyncMetricObserver(String name, MetricObserver observer) {
        this(name, observer, Integer.MAX_VALUE, Long.MAX_VALUE);
    }

    public AsyncMetricObserver(String name, MetricObserver observer, int queueSize) {
        this(name, observer, queueSize, Long.MAX_VALUE);
    }

    public AsyncMetricObserver(String name, MetricObserver observer, long expireTime) {
        this(name, observer, Integer.MAX_VALUE, expireTime);
    }

    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        TimestampedUpdate update = new TimestampedUpdate(System.currentTimeMillis(), metrics);
        boolean result = updateQueue.offer(update);
        while (!result) {
            updateQueue.remove();
            result = updateQueue.offer(update);
        }
    }

    private void processUpdate() {
        TimestampedUpdate update;
        try {
            update = updateQueue.take();

            long cutoff = System.currentTimeMillis() - expireTime;
            if (update.getTimestamp() < cutoff) {
                expiredUpdateCount.incrementAndGet();
                return;
            }

            wrappedObserver.update(update.getMetrics());
        } catch (InterruptedException ie){
            log.warn("Interrupted while adding to queue, update dropped");
            failedUpdateCount.incrementAndGet();
        } catch (Throwable t) {
            log.warn("update failed for downstream queue", t);
            failedUpdateCount.incrementAndGet();
        } finally {
            updateCount.incrementAndGet();
        }
    }

    private class UpdateProcessor implements Runnable {
        public void run() {
            while (true) {
                processUpdate();
            }
        }
    }

    private static class TimestampedUpdate {
        private final long timestamp;
        private final List<Metric> metrics;

        public TimestampedUpdate(long timestamp, List<Metric> metrics) {
            this.timestamp = timestamp;
            this.metrics = metrics;
        }

        long getTimestamp() {
            return timestamp;
        }

        List<Metric> getMetrics() {
            return metrics;
        }
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_2319e19_08f3409/rev_2319e19-08f3409/src/main/java/com/netflix/servo/publish/cloudwatch/CloudWatchMetricObserver.java;<<<<<<< MINE
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish.cloudwatch;

import com.google.common.base.Preconditions;

import com.netflix.servo.publish.BaseMetricObserver;
import com.netflix.servo.publish.Metric;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Writes observations to Amazon's CloudWatch.
 */
public class CloudWatchMetricObserver extends BaseMetricObserver {

    private static final Logger log =
        LoggerFactory.getLogger(CloudWatchMetricObserver.class);

    public CloudWatchMetricObserver(String name) {
        super(name);
    }

    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/truth/revisions/rev_de0a389_b6b98e7/rev_de0a389-b6b98e7/src/main/java/org/junit/contrib/truth/subjects/IntegerSubject.java;<<<<<<< MINE
public class IntegerSubject extends Subject<IntegerSubject, Long> {
=======
/**
 * Propositions for Integral numeric subjects
 * 
 * @author David Saff
 * @author Christian Gruber (cgruber@israfil.net)
 */
public class IntegerSubject extends Subject<Long> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/truth/revisions/rev_de0a389_b6b98e7/rev_de0a389-b6b98e7/src/main/java/org/junit/contrib/truth/subjects/Subject.java;<<<<<<< MINE
public class Subject<S extends Subject<S,T>,T> {
  
=======
/**
 * Propositions for arbitrarily typed subjects and for properties
 * of Object
 * 
 * @author David Saff
 * @author Christian Gruber (cgruber@israfil.net)
 */
public class Subject<T> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/truth/revisions/rev_de0a389_b6b98e7/rev_de0a389-b6b98e7/src/main/java/org/junit/contrib/truth/subjects/StringSubject.java;<<<<<<< MINE
public class StringSubject extends Subject<StringSubject, String> {
=======
/**
 * Propositions for String subjects
 * 
 * @author David Saff
 * @author Christian Gruber (cgruber@israfil.net)
 */
public class StringSubject extends Subject<String> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_697c3bb_64c19d6/rev_697c3bb-64c19d6/servo-core/src/sample/java/com/netflix/servo/sample/SimpleSample.java;<<<<<<< MINE
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.sample;

import com.netflix.servo.*;
import com.netflix.servo.BasicTagList;
import com.netflix.servo.DefaultMonitorRegistry;
import com.netflix.servo.InjectableTag;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.annotations.Monitor;
import com.netflix.servo.annotations.MonitorTags;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Simple Sample Code for getting a monitor into JMX.
 */
public class SimpleSample {

    @Monitor(name = "SampleCounter", type = DataSourceType.COUNTER,
            description = "Sample counting monitor", tags = {
            "sample=simple"})
    public final AtomicInteger counter = new AtomicInteger(0);

    @Monitor(name = "SampleGauge", type = DataSourceType.GAUGE,
            description = "Sample gauge monitor", tags = {
            "sample=simple"})
    private long sampleGuage = 0;

    @MonitorTags
    public TagList tagList = BasicTagList.EMPTY;

    public SimpleSample() {
    }

    public SimpleSample(Collection<Tag> tags) {
        tagList = new BasicTagList(tags);
    }

    public SimpleSample(TagList tags){
        tagList = tags;
    }

    public synchronized void setSampleGauage(long val){
        sampleGuage = val;
    }

    public synchronized long getSampleGuage(){
        return sampleGuage;
    }

    public static void main(String[] args) throws InterruptedException {
        List<Tag> tags = new ArrayList<Tag>(2);
        tags.add(InjectableTag.HOSTNAME);
        tags.add(InjectableTag.IP);

        SimpleSample sample = new SimpleSample(tags);

        DefaultMonitorRegistry.getInstance().registerObject(sample);

        while(true){
            sample.counter.incrementAndGet();
            sample.setSampleGauage(Math.round(Math.random()*1000));
            Thread.sleep(60000);
        }
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/truth/revisions/rev_d7a2ff6_db7ed46/rev_d7a2ff6-db7ed46/src/main/java/org/junit/contrib/truth/subjects/CollectionSubject.java;<<<<<<< MINE
@GwtCompatible
public class CollectionSubject<S extends CollectionSubject<S, T, C>, T, C extends Collection<T>> extends Subject<S, C> {
=======
import org.junit.contrib.truth.FailureStrategy;

public class CollectionSubject<S extends CollectionSubject<S, T, C>, T, C extends Collection<T>> extends IterableSubject<S, T, C> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7/servo-core/src/main/java/com/netflix/servo/publish/CounterToRateMetricTransform.java;<<<<<<< MINE
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.google.common.io.Closeables;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.Tag;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.base.Preconditions;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.Lists;
import com.netflix.servo.Metric;
import com.netflix.servo.MetricConfig;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Converts counter metrics into a rate per second. The rate is calculated by
 * comparing two samples of given metric and looking at the delta. Since two
 * samples are needed to calculate the rate, no value will be sent to the
 * wrapped observer until a second sample arrives. If a given metric is not
 * updated within a given heartbeat interval, the previous cached value for the
 * counter will be dropped such that if a new sample comes in it will be
 * treated as the first sample for that metric.
 *
 * <p>Counters should be monotonically increasing values. If a counter value
 * decreases from one sample to the next, then we will assume the counter value
 * was reset and send a rate of 0. This is similar to the RRD concept of
 * type DERIVE with a min of 0.
 */
public final class CounterToRateMetricTransform implements MetricObserver {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(CounterToRateMetricTransform.class);

    private final MetricObserver observer;
    private final Cache<MetricConfig,CounterValue> cache;

    /**
     * Creates a new instance with the specified heartbeat interval. The
     * heartbeat should be some multiple of the sampling interval used when
     * collecting the metrics.
     */
    public CounterToRateMetricTransform(
            MetricObserver observer, long heartbeat, TimeUnit unit) {
        this.observer = observer;
        this.cache = CacheBuilder.newBuilder()
            .expireAfterWrite(heartbeat, unit)
            .build();
    }

    /** {@inheritDoc} */
    public String getName() {
        return getClass().getSimpleName() + "-" + observer.getName();
    }

    /** {@inheritDoc} */
    public void update(List<Metric> metrics) {
        Preconditions.checkNotNull(metrics);
        List<Metric> newMetrics = Lists.newArrayList();
        for (Metric m : metrics) {
            if (isCounter(m)) {
                CounterValue current = new CounterValue(m);
                CounterValue prev = cache.getIfPresent(m.getConfig());
                if (prev != null) {
                    Metric rate = new Metric(
                        m.getConfig(),
                        m.getTimestamp(),
                        current.computeRate(prev));
                    newMetrics.add(rate);
                }
                cache.put(m.getConfig(), current);
            } else {
                newMetrics.add(m);
            }
        }
        observer.update(newMetrics);
    }

    /**
     * Clear all cached state of previous counter values.
     */
    public void reset() {
        cache.invalidateAll();
    }

    private boolean isCounter(Metric m) {
        TagList tags = m.getConfig().getTags();
        Tag type = tags.getTag(DataSourceType.KEY);
        String counter = DataSourceType.COUNTER.name();
        return (type != null && counter.equals(type.getValue()));
    }

    private static class CounterValue {
        private final long timestamp;
        private final double value;

        public CounterValue(long timestamp, double value) {
            this.timestamp = timestamp;
            this.value = value;
        }

        public CounterValue(Metric m) {
            this(m.getTimestamp(), m.getValue().doubleValue());
        }

        public double computeRate(CounterValue prev) {
            double duration = (timestamp - prev.timestamp) / 1000.0;
            double delta = value - prev.value;
            return (duration <= 0.0 || delta <= 0.0) ? 0.0 : delta / duration;
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_ce59b53_1084df7/rev_ce59b53-1084df7/servo-core/src/test/java/com/netflix/servo/publish/CounterToRateMetricTransformTest.java;<<<<<<< MINE
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.netflix.servo.BasicTagList;
import com.netflix.servo.Metric;
import com.netflix.servo.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.netflix.servo.BasicTagList.*;
import static org.testng.Assert.*;

public class CounterToRateMetricTransformTest {

    private static final TagList GAUGE =
        BasicTagList.copyOf(DataSourceType.GAUGE);

    private static final TagList COUNTER =
        BasicTagList.copyOf(DataSourceType.COUNTER);

    private List<Metric> mkList(long ts, int value) {
        return ImmutableList.of(
            new Metric("m1", EMPTY, ts, value),
            new Metric("m2", GAUGE, ts, value),
            new Metric("m3", COUNTER, ts, value)
        );
    }

    private Map<String,Double> mkMap(List<List<Metric>> updates) {
        Map<String,Double> map = Maps.newHashMap();
        for (Metric m : updates.get(0)) {
            map.put(m.getConfig().getName(), m.getValue().doubleValue());
        }
        return map;
    }

    @Test
    public void testSimpleRate() throws Exception {
        MemoryMetricObserver mmo = new MemoryMetricObserver("m", 1);
        MetricObserver transform =
            new CounterToRateMetricTransform(mmo, 120, TimeUnit.SECONDS);
        Map<String,Double> metrics = null;

        // First sample
        transform.update(mkList(0, 0));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 2);
        assertEquals(metrics.get("m3"), null);

        // Delta of 5 in 5 seconds
        transform.update(mkList(5000, 5));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 1.0, 0.00001);

        // Delta of 15 in 5 seconds
        transform.update(mkList(10000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 3.0, 0.00001);

        // No change from previous sample
        transform.update(mkList(15000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);

        // Decrease from previous sample
        transform.update(mkList(20000, 19));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);
    }
}=======
/*
 * #%L
 * servo
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.publish;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import com.netflix.servo.tag.BasicTagList;
import com.netflix.servo.Metric;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.annotations.DataSourceType;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.netflix.servo.tag.BasicTagList.*;
import static org.testng.Assert.*;

public class CounterToRateMetricTransformTest {

    private static final TagList GAUGE =
        BasicTagList.copyOf(DataSourceType.GAUGE);

    private static final TagList COUNTER =
        BasicTagList.copyOf(DataSourceType.COUNTER);

    private List<Metric> mkList(long ts, int value) {
        return ImmutableList.of(
            new Metric("m1", EMPTY, ts, value),
            new Metric("m2", GAUGE, ts, value),
            new Metric("m3", COUNTER, ts, value)
        );
    }

    private Map<String,Double> mkMap(List<List<Metric>> updates) {
        Map<String,Double> map = Maps.newHashMap();
        for (Metric m : updates.get(0)) {
            map.put(m.getConfig().getName(), m.getValue().doubleValue());
        }
        return map;
    }

    @Test
    public void testSimpleRate() throws Exception {
        MemoryMetricObserver mmo = new MemoryMetricObserver("m", 1);
        MetricObserver transform =
            new CounterToRateMetricTransform(mmo, 120, TimeUnit.SECONDS);
        Map<String,Double> metrics = null;

        // First sample
        transform.update(mkList(0, 0));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 2);
        assertEquals(metrics.get("m3"), null);

        // Delta of 5 in 5 seconds
        transform.update(mkList(5000, 5));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 1.0, 0.00001);

        // Delta of 15 in 5 seconds
        transform.update(mkList(10000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 3.0, 0.00001);

        // No change from previous sample
        transform.update(mkList(15000, 20));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);

        // Decrease from previous sample
        transform.update(mkList(20000, 19));
        metrics = mkMap(mmo.getObservations());
        assertEquals(metrics.size(), 3);
        assertEquals(metrics.get("m3"), 0.0, 0.00001);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_bfaf34a_bab4692/rev_bfaf34a-bab4692/servo-core/src/main/java/com/netflix/servo/examples/JmxClientExample.java;<<<<<<< MINE
=======
/*
 * #%L
 * servo-core
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.examples;

import javax.management.AttributeList;
import javax.management.Attribute;
import javax.management.MBeanAttributeInfo;
import javax.management.MBeanServerConnection;
import javax.management.ObjectName;
import javax.management.openmbean.CompositeData;
import javax.management.remote.JMXConnectorFactory;
import javax.management.remote.JMXServiceURL;
import java.net.MalformedURLException;
import java.util.Set;

/**
 * JMX client that grabs the MonitoredResources.
 */
public class JmxClientExample {

    private static final int INDENT_SPACES = 4;

    private static JMXServiceURL mkJmxUrl(String host, String port)
            throws MalformedURLException {
        String url = String.format(
            "service:jmx:rmi://%1$s:%2$s/jndi/rmi://%1$s:%2$s/jmxrmi",
            host, port);
        return new JMXServiceURL(url);
    }

    private static void println(int indent, String msg) {
        for (int i = 0; i < indent * INDENT_SPACES; ++i) {
            System.out.print(" ");
        }
        System.out.println(msg);
    }

    private static void dumpValue(int indent, String name, Object obj) {
        if (obj instanceof CompositeData) {
            CompositeData cd = (CompositeData) obj;
            println(indent, String.format("%s:", name));
            for (String key : cd.getCompositeType().keySet()) {
                dumpValue(indent + 1, key, cd.get(key));
            }
        } else {
            println(indent, String.format("%s => %s", name, obj));
        }
    }

    private static void dumpObj(MBeanServerConnection con, ObjectName objName)
            throws Exception {
        System.out.println("ObjectName: " + objName.toString());

        MBeanAttributeInfo[] attrs = con.getMBeanInfo(objName).getAttributes();
        if (attrs != null) {
            String attrNames[] = new String[attrs.length];
            for (int i = 0; i < attrNames.length; ++i) {
                attrNames[i] = attrs[i].getName();
            }

            AttributeList list = con.getAttributes(objName, attrNames);
            for (Attribute a : list.asList()) {
                dumpValue(1, a.getName(), a.getValue());
            }
        }
    }

    public static void main(String[] args) throws Exception {
        if (args.length < 2) {
            System.out.println("Usage: JMXClientExample <host> <port>");
            System.exit(1);
        }
        String host = args[0];
        String port = args[1];

        JMXServiceURL url = mkJmxUrl(host, port);

        MBeanServerConnection con = JMXConnectorFactory.connect(
            url, null).getMBeanServerConnection();

        ObjectName pattern = new ObjectName(
            "com.netflix.servo.jmx.MonitoredResource:*");

        Set<ObjectName> objNames = con.queryNames(pattern, null);
        for (ObjectName objName : objNames) {
            dumpObj(con, objName);
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_bfaf34a_bab4692/rev_bfaf34a-bab4692/servo-core/src/main/java/com/netflix/servo/examples/EchoServerExample.java;<<<<<<< MINE
=======
/*
 * #%L
 * servo-core
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.examples;

import com.google.common.collect.Maps;
import com.google.common.io.ByteStreams;
import com.google.common.io.Closeables;
import com.google.common.io.CountingInputStream;
import com.google.common.io.CountingOutputStream;
import com.netflix.servo.publish.BasicMetricFilter;
import com.netflix.servo.publish.CounterToRateMetricTransform;
import com.netflix.servo.publish.FileMetricObserver;
import com.netflix.servo.publish.JmxMetricPoller;
import com.netflix.servo.publish.LocalJmxConnector;
import com.netflix.servo.publish.MetricFilter;
import com.netflix.servo.publish.MetricObserver;
import com.netflix.servo.publish.MetricPoller;
import com.netflix.servo.publish.MonitorRegistryMetricPoller;
import com.netflix.servo.publish.PollRunnable;
import com.netflix.servo.publish.PollScheduler;
import com.netflix.servo.publish.PrefixMetricFilter;
import com.netflix.servo.publish.RegexMetricFilter;
import com.netflix.servo.tag.BasicTag;
import com.netflix.servo.tag.BasicTagList;
import com.netflix.servo.tag.TagList;
import com.netflix.servo.util.Counters;
import com.netflix.servo.util.TaggingContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.management.ObjectName;
import java.io.File;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketAddress;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

/**
 * An really basic echo server that uses the utility methods from
 * {@link com.netflix.servo.util.Counters}.
 */
public class EchoServerExample {

    private static final Logger LOGGER =
        LoggerFactory.getLogger(EchoServerExample.class);

    private final int port;

    public EchoServerExample(int port) {
        this.port = port;
    }

    public void start() throws IOException {
        AcceptTask task = new AcceptTask(port);
        Thread t = new Thread(task, "AcceptTask");
        t.start();
    }

    public void shutdown() {
        // Just an example, a real server should have a way to cleanly
        // shutdown
    }

    public static class AcceptTask implements Runnable {
        private static final String[] COUNTRIES = {"US", "CA", "GB", "IE"};
        private final ServerSocket ss;
        private final Random r = new Random();

        public AcceptTask(int port) throws IOException {
            ss = new ServerSocket(port);
        }

        public TagList getTags(Socket s) {
            String country = COUNTRIES[r.nextInt(COUNTRIES.length)];
            return BasicTagList.copyOf(new BasicTag("Country", country));
        }

        public void run() {
            while (true) {
                try {
                    Socket s = ss.accept();
                    TagList tags = getTags(s);
                    LOGGER.info("received connection from {} with tags {}",
                        s.getRemoteSocketAddress(), tags);

                    Counters.increment("RequestCount", tags);
                    ClientTask task = new ClientTask(tags, s);
                    Thread t = new Thread(task, "ClientTask");
                    t.start();
                } catch (IOException e) {
                    LOGGER.error("failure accepting connection", e);
                }
            }
        }
    }

    public static class ClientTask implements Runnable {
        private final TagList tags;
        private final Socket s;

        public ClientTask(TagList tags, Socket s) {
            this.tags = tags;
            this.s = s;
        }

        private void doWork() throws IOException {
            CountingInputStream input = null;
            CountingOutputStream output = null;
            try {
                input = new CountingInputStream(s.getInputStream());
                output = new CountingOutputStream(s.getOutputStream());
                ByteStreams.copy(input, output);
                Counters.increment("BytesIn", input.getCount());
                Counters.increment("BytesOut", output.getCount());
            } finally {
                Closeables.closeQuietly(input);
                Closeables.closeQuietly(output);
            }
        }

        public void run() {
            // Setup context so all counters increments in this thread will get
            // tagged
            TaggingContext.setTags(tags);

            try {
                doWork();
            } catch (IOException e) {
                SocketAddress a = s.getRemoteSocketAddress();
                LOGGER.error("failure handling connection from " + a, e);
            }
        }
    }

    public static void main(String[] args) throws Exception {
        // Schedule collection of monitor registry metrics every 10 seconds
        PollScheduler scheduler = PollScheduler.getInstance();
        scheduler.start();
        MetricObserver transform = new CounterToRateMetricTransform(
            new FileMetricObserver("serverstat", new File(".")),
            20, TimeUnit.SECONDS);
        PollRunnable task = new PollRunnable(
            new MonitorRegistryMetricPoller(),
            BasicMetricFilter.MATCH_ALL,
            transform);
        scheduler.addPoller(task, 10, TimeUnit.SECONDS);

        // Run server
        int port = 54321;
        if (args.length > 0) {
            port = Integer.valueOf(args[0]);
        }
        EchoServerExample example = new EchoServerExample(port);
        example.start();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_bfaf34a_bab4692/rev_bfaf34a-bab4692/servo-core/src/test/java/com/netflix/servo/annotations/AnnotationUtilsTest.java;<<<<<<< MINE
=======
    public static class StringArrayTagObject {
        @MonitorTags
        private final String[] tags;

        public StringArrayTagObject(String... tags) {
            this.tags = tags;
        }
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_bfaf34a_bab4692/rev_bfaf34a-bab4692/servo-core/src/test/java/com/netflix/servo/annotations/AnnotationUtilsTest.java;<<<<<<< MINE
=======
    public static class StringGaugeObject {

        @Monitor(name="foo", type=DataSourceType.GAUGE)
        String foo = "bar";

        public StringGaugeObject() {
        }
    }

    public static class StringCounterObject {

        @Monitor(name="foo", type=DataSourceType.COUNTER)
        String foo = "bar";

        public StringCounterObject() {
        }
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_bfaf34a_bab4692/rev_bfaf34a-bab4692/servo-cloudwatch/src/main/java/com/netflix/servo/examples/CloudWatchExample.java;<<<<<<< MINE
=======
/*
 * #%L
 * servo-cloudwatch
 * %%
 * Copyright (C) 2011 - 2012 Netflix
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.netflix.servo.examples;

import com.amazonaws.auth.PropertiesCredentials;
import com.netflix.servo.*;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.annotations.Monitor;
import com.netflix.servo.annotations.MonitorTags;
import com.netflix.servo.publish.BasicMetricFilter;
import com.netflix.servo.publish.MonitorRegistryMetricPoller;
import com.netflix.servo.publish.PollCallable;
import com.netflix.servo.publish.cloudwatch.CloudWatchMetricObserver;
import com.netflix.servo.tag.BasicTagList;
import com.netflix.servo.tag.InjectableTag;
import com.netflix.servo.tag.Tag;
import com.netflix.servo.tag.TagList;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Sample of publishing the SimpleSample to CloudWatch
 */
public class CloudWatchExample {
    
    public static void main(String[] args) throws Exception {
        if(args.length != 1){
            System.err.println("Please specify the path to a properties file with your amazon keys.");
            return;
        }

        CloudWatchMetricObserver observer = new CloudWatchMetricObserver("SampleObserver", "SampleDomain",
                new PropertiesCredentials(new File(args[0])));

        List<Tag> tags = new ArrayList<Tag>(2);
        tags.add(InjectableTag.HOSTNAME);
        tags.add(InjectableTag.IP);

        BasicExample example = new BasicExample("test", tags);

        DefaultMonitorRegistry.getInstance().registerObject(example);

        PollCallable poller = new PollCallable(new MonitorRegistryMetricPoller(), BasicMetricFilter.MATCH_ALL);


        while(true){
            example.counter.incrementAndGet();
            example.setSampleGauge(Math.round(Math.random() * 1000));
            observer.update(poller.call());
            Thread.sleep(60000);
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_43abaef_62ab848/rev_43abaef-62ab848/src/main/java/graphql/schema/Coercing.java;<<<<<<< MINE
public interface Coercing<T> {
=======
public interface Coercing<I, O> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_43abaef_62ab848/rev_43abaef-62ab848/src/main/java/graphql/relay/DefaultConnectionCursor.java;<<<<<<< MINE
=======
package graphql.relay;

public class DefaultConnectionCursor implements ConnectionCursor {

    private final String value;

    public DefaultConnectionCursor(String value) {
        if (value == null || value.isEmpty()) {
            throw new IllegalArgumentException("connection value cannot be null or empty");
        }
        this.value = value;
    }

    @Override
    public String getValue() {
        return value;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        DefaultConnectionCursor that = (DefaultConnectionCursor) o;
        if (value != null ? !value.equals(that.value) : that.value != null) {
            return false;
        }
        return true;
    }

    @Override
    public int hashCode() {
        return value != null ? value.hashCode() : 0;
    }

    @Override
    public String toString() {
        return value;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_43abaef_62ab848/rev_43abaef-62ab848/src/main/java/graphql/relay/DefaultEdge.java;<<<<<<< MINE
=======
package graphql.relay;

public class DefaultEdge implements Edge {

    public DefaultEdge(Object node, DefaultConnectionCursor cursor) {
        this.node = node;
        this.cursor = cursor;
    }

    private Object node;
    private ConnectionCursor cursor;

    @Override
    public Object getNode() {
        return node;
    }

    public void setNode(Object node) {
        this.node = node;
    }

    @Override
    public ConnectionCursor getCursor() {
        return cursor;
    }

    public void setCursor(ConnectionCursor cursor) {
        this.cursor = cursor;
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder("DefaultEdge{");
        sb.append("node=").append(node);
        sb.append(", cursor=").append(cursor);
        sb.append('}');
        return sb.toString();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_43abaef_62ab848/rev_43abaef-62ab848/src/main/java/graphql/relay/DefaultPageInfo.java;<<<<<<< MINE
=======
package graphql.relay;

public class DefaultPageInfo implements PageInfo {

    private ConnectionCursor startCursor;
    private ConnectionCursor endCursor;
    private boolean hasPreviousPage;
    private boolean hasNextPage;

    @Override
    public ConnectionCursor getStartCursor() {
        return startCursor;
    }

    public void setStartCursor(ConnectionCursor startCursor) {
        this.startCursor = startCursor;
    }

    @Override
    public ConnectionCursor getEndCursor() {
        return endCursor;
    }

    public void setEndCursor(ConnectionCursor endCursor) {
        this.endCursor = endCursor;
    }

    @Override
    public boolean isHasPreviousPage() {
        return hasPreviousPage;
    }

    public void setHasPreviousPage(boolean hasPreviousPage) {
        this.hasPreviousPage = hasPreviousPage;
    }

    @Override
    public boolean isHasNextPage() {
        return hasNextPage;
    }

    public void setHasNextPage(boolean hasNextPage) {
        this.hasNextPage = hasNextPage;
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder("DefaultPageInfo{");
        sb.append("startCursor=").append(startCursor);
        sb.append(", endCursor=").append(endCursor);
        sb.append(", hasPreviousPage=").append(hasPreviousPage);
        sb.append(", hasNextPage=").append(hasNextPage);
        sb.append('}');
        return sb.toString();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_43abaef_62ab848/rev_43abaef-62ab848/src/main/java/graphql/relay/DefaultConnection.java;<<<<<<< MINE
=======
package graphql.relay;

import java.util.ArrayList;
import java.util.List;

public class DefaultConnection implements Connection {

    private List<Edge> edges = new ArrayList<Edge>();

    private PageInfo pageInfo;

    @Override
    public List<Edge> getEdges() {
        return edges;
    }

    public void setEdges(List<Edge> edges) {
        this.edges = edges;
    }

    @Override
    public PageInfo getPageInfo() {
        return pageInfo;
    }

    public void setPageInfo(PageInfo pageInfo) {
        this.pageInfo = pageInfo;
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder("DefaultConnection{");
        sb.append("edges=").append(edges);
        sb.append(", pageInfo=").append(pageInfo);
        sb.append('}');
        return sb.toString();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_43abaef_62ab848/rev_43abaef-62ab848/src/main/java/graphql/relay/ConnectionCursor.java;<<<<<<< MINE
=======
/**
 * represents a connection cursor in relay.
 */
public interface ConnectionCursor {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_43abaef_62ab848/rev_43abaef-62ab848/src/main/java/graphql/relay/ConnectionCursor.java;<<<<<<< MINE
public class ConnectionCursor {
=======
    String getValue();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_43abaef_62ab848/rev_43abaef-62ab848/src/main/java/graphql/relay/PageInfo.java;<<<<<<< MINE
=======
/**
 * represents a page in relay.
 */
public interface PageInfo {

    ConnectionCursor getStartCursor();

    ConnectionCursor getEndCursor();

    boolean isHasPreviousPage();

    boolean isHasNextPage();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_43abaef_62ab848/rev_43abaef-62ab848/src/main/java/graphql/relay/PageInfo.java;<<<<<<< MINE
public class PageInfo {
    private ConnectionCursor startCursor;
    private ConnectionCursor endCursor;
    private boolean hasPreviousPage;
    private boolean hasNextPage;

    public ConnectionCursor getStartCursor() {
        return startCursor;
    }

    public void setStartCursor(ConnectionCursor startCursor) {
        this.startCursor = startCursor;
    }

    public ConnectionCursor getEndCursor() {
        return endCursor;
    }

    public void setEndCursor(ConnectionCursor endCursor) {
        this.endCursor = endCursor;
    }

    public boolean isHasPreviousPage() {
        return hasPreviousPage;
    }

    public void setHasPreviousPage(boolean hasPreviousPage) {
        this.hasPreviousPage = hasPreviousPage;
    }

    public boolean isHasNextPage() {
        return hasNextPage;
    }

    public void setHasNextPage(boolean hasNextPage) {
        this.hasNextPage = hasNextPage;
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_43abaef_62ab848/rev_43abaef-62ab848/src/main/java/graphql/relay/Connection.java;<<<<<<< MINE
public class Connection {
    private List<Edge> edges = new ArrayList<Edge>();

    private PageInfo pageInfo;

    public List<Edge> getEdges() {
        return edges;
    }
=======
/**
 * represents a connection in relay.
 */
public interface Connection {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_43abaef_62ab848/rev_43abaef-62ab848/src/main/java/graphql/relay/Edge.java;<<<<<<< MINE
=======
/**
 * represents an edge in relay.
 */
public interface Edge {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_43abaef_62ab848/rev_43abaef-62ab848/src/main/java/graphql/relay/Edge.java;<<<<<<< MINE
public class Edge {
=======
    Object getNode();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_0072285_3e63dc1/rev_0072285-3e63dc1/src/main/java/graphql/schema/idl/errors/NotAnOutputTypeError.java;<<<<<<< MINE
package graphql.schema.idl.errors;

import graphql.language.TypeDefinition;

import static java.lang.String.format;

public class NotAnOutputTypeError extends BaseError {

    public NotAnOutputTypeError(TypeDefinition typeDefinition) {
        super(typeDefinition, format("expected OutputType, but found %s type %s", typeDefinition.getName(), lineCol(typeDefinition)));
    }
}=======
package graphql.schema.idl.errors;

import graphql.language.TypeDefinition;

import static java.lang.String.format;

public class NotAnOutputTypeError extends BaseError {

    public NotAnOutputTypeError(TypeDefinition typeDefinition) {
        super(typeDefinition, format("expected OutputType, but found %s type", typeDefinition.getName()));
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_0072285_3e63dc1/rev_0072285-3e63dc1/src/main/java/graphql/schema/idl/errors/NotAnInputTypeError.java;<<<<<<< MINE
package graphql.schema.idl.errors;

import graphql.language.TypeDefinition;

import static java.lang.String.format;

public class NotAnInputTypeError extends BaseError {

    public NotAnInputTypeError(TypeDefinition typeDefinition) {
        super(typeDefinition, format("expected InputType, but found %s type %s", typeDefinition.getName(), lineCol(typeDefinition)));
    }
}=======
package graphql.schema.idl.errors;

import graphql.language.TypeDefinition;

import static java.lang.String.format;

public class NotAnInputTypeError extends BaseError {

    public NotAnInputTypeError(TypeDefinition typeDefinition) {
        super(typeDefinition, format("expected InputType, but found %s type", typeDefinition.getName()));
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/graphql-java/revisions/rev_1636dc9_a4367c6/rev_1636dc9-a4367c6/src/main/java/graphql/execution/ExecutionParameters.java;<<<<<<< MINE
=======
package graphql.execution;

import graphql.Assert;
import graphql.language.Field;

import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

import static graphql.Assert.assertNotNull;

/**
 * The parameters that are passed to execution strategies
 */
public class ExecutionParameters {
    private final TypeInfo typeInfo;
    private final Object source;
    private final Map<String, Object> arguments;
    private final Map<String, List<Field>> fields;
    private final NonNullableFieldValidator nonNullableFieldValidator;

    private ExecutionParameters(TypeInfo typeInfo, Object source, Map<String, List<Field>> fields, Map<String, Object> arguments, NonNullableFieldValidator nonNullableFieldValidator) {
        this.typeInfo = assertNotNull(typeInfo, "typeInfo is null");
        this.fields = assertNotNull(fields, "fields is null");
        this.source = source;
        this.arguments = arguments;
        this.nonNullableFieldValidator = nonNullableFieldValidator;
    }

    public TypeInfo typeInfo() {
        return typeInfo;
    }

    public Object source() {
        return source;
    }

    public Map<String, List<Field>> fields() {
        return fields;
    }

    public Map<String, Object> arguments() {
        return arguments;
    }

    public NonNullableFieldValidator nonNullFieldValidator() {
        return nonNullableFieldValidator;
    }

    public ExecutionParameters transform(Consumer<Builder> builderConsumer) {
        Builder builder = newParameters(this);
        builderConsumer.accept(builder);
        return builder.build();
    }

    public static Builder newParameters() {
        return new Builder();
    }

    public static Builder newParameters(ExecutionParameters oldParameters) {
        return new Builder(oldParameters);
    }

    @Override
    public String toString() {
        return String.format("ExecutionParameters { typeInfo=%s, source=%s, fields=%s }",
                typeInfo, source, fields);
    }

    public static class Builder {
        TypeInfo typeInfo;
        Object source;
        Map<String, List<Field>> fields;
        Map<String, Object> arguments;
        NonNullableFieldValidator nonNullableFieldValidator;

        private Builder() {
        }

        private Builder(ExecutionParameters oldParameters) {
            this.typeInfo = oldParameters.typeInfo;
            this.source = oldParameters.source;
            this.fields = oldParameters.fields;
            this.arguments = oldParameters.arguments;
            this.nonNullableFieldValidator = oldParameters.nonNullableFieldValidator;
        }

        public Builder typeInfo(TypeInfo type) {
            this.typeInfo = type;
            return this;
        }

        public Builder typeInfo(TypeInfo.Builder type) {
            this.typeInfo = type.build();
            return this;
        }

        public Builder fields(Map<String, List<Field>> fields) {
            this.fields = fields;
            return this;
        }

        public Builder source(Object source) {
            this.source = source;
            return this;
        }

        public Builder arguments(Map<String, Object> arguments) {
            this.arguments = arguments;
            return this;
        }
        
        public Builder nonNullFieldValidator(NonNullableFieldValidator nonNullableFieldValidator) {
            this.nonNullableFieldValidator = Assert.assertNotNull(nonNullableFieldValidator,"requires a NonNullValidator");
            return this;
        }

        public ExecutionParameters build() {
            return new ExecutionParameters(typeInfo, source, fields, arguments, nonNullableFieldValidator);
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/servo/revisions/rev_76a9a85_f82768d/rev_76a9a85-f82768d/servo-aws/src/main/java/com/netflix/servo/aws/AwsPropertyKeys.java;<<<<<<< MINE
public class AwsPropertyKeys {
=======
public enum AwsPropertyKeys {
	
	AWS_CREDENTIALS_FILE("com.netflix.servo.aws.credentialsFile"), 
	AWS_AUTO_SCALING_END_POINT("com.netflix.servo.aws.endpoint.autoscaling"), 
	AWS_CLOUD_WATCH_END_POINT("com.netflix.servo.aws.endpoint.cloudwatch");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_c3b97b6_f554e50/rev_c3b97b6-f554e50/src/test/java/com/squareup/injector/InjectionTest.java;<<<<<<< MINE
=======
  static class ExtendsParameterizedType extends AbstractList<Integer> {
    @Inject String string;
    @Override public Integer get(int i) {
      return i;
    }
    @Override public int size() {
      return 5;
    }
  }

  /**
   * We've had bugs where we look for the wrong keys when a class extends a
   * parameterized class. Explicitly test that we can inject such classes.
   */
  @Test public void extendsParameterizedType() {
    class TestEntryPoint {
      @Inject ExtendsParameterizedType extendsParameterizedType;
    }

    @Module(entryPoints = TestEntryPoint.class)
    class TestModule {
      @Provides String provideString() {
        return "injected";
      }
    }

    TestEntryPoint entryPoint = new TestEntryPoint();
    ObjectGraph.get(new TestModule()).inject(entryPoint);
    assertThat(entryPoint.extendsParameterizedType.string).isEqualTo("injected");
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8760480_a77e513/rev_8760480-a77e513/src/main/java/rx/netty/protocol/http/HttpProtocolHandlerAdapter.java;<<<<<<< MINE
/**
 * Copyright 2013 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.netty.protocol.http;

import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelPipeline;

public class HttpProtocolHandlerAdapter<T> implements HttpProtocolHandler<T> {

    @Override
    public void configure(ChannelPipeline pipeline) {
    }

    @Override
    public void onChannelConnectOperationCompleted(ChannelFuture connectFuture) {
    }

    @Override
    public void onChannelWriteOperationCompleted(ChannelFuture requestWrittenFuture) {
    }

    @Override
    public void onChannelCloseOperationCompleted(ChannelFuture channelCloseFuture) {
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8760480_a77e513/rev_8760480-a77e513/src/main/java/rx/netty/protocol/http/RequestWriter.java;<<<<<<< MINE
/**
 * Copyright 2013 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.netty.protocol.http;

import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelPromise;
import io.netty.handler.codec.http.HttpObjectAggregator;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.util.concurrent.DefaultPromise;
import io.netty.util.concurrent.Future;

/**
 * This class is responsible for sending a request object to the server and then setting up
 * proper listeners when sending request is successful
 * 
 * @param <T>
 *            The type of response content
 * @param <R>
 *            The type of the request
 */
class RequestWriter<T, R extends HttpRequest> {
    private final Channel channel;
    private final HttpProtocolHandler<T> handler;

    RequestWriter(Channel channel, HttpProtocolHandler<T> handler) {
        this.channel = channel;
        this.handler = handler;
    }

    Future<T> execute(R request, final RequestCompletionPromise requestCompletionPromise) {
        ChannelPromise promise = channel.newPromise();
        channel.writeAndFlush(request, promise).addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (!future.isSuccess()) {
                    requestCompletionPromise.tryFailure(future.cause());
                }
            }
        }).addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                handler.onChannelWriteOperationCompleted(future);
            }
        });
        return new RequestWrittenPromise(channel, promise);
    }

    Channel getChannel() {
        return channel;
    }

    public boolean isActive() {
        return channel.isActive();
    }

    private class RequestWrittenPromise extends DefaultPromise<T> {

        private final ChannelPromise sendRequestPromise;

        public RequestWrittenPromise(Channel channel, ChannelPromise sendRequestPromise) {
            super(channel.eventLoop());
            this.sendRequestPromise = sendRequestPromise;
        }

        @Override
        public boolean cancel(boolean mayInterruptIfRunning) {
            if (sendRequestPromise.isCancellable()) {
                sendRequestPromise.cancel(mayInterruptIfRunning);
            }
            return super.cancel(mayInterruptIfRunning);
        }
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8760480_a77e513/rev_8760480-a77e513/src/main/java/rx/netty/protocol/http/HttpProtocolHandler.java;<<<<<<< MINE
/**
 * Copyright 2013 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.netty.protocol.http;

import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelPipeline;
import io.netty.handler.codec.http.FullHttpResponse;
import rx.netty.protocol.tcp.ProtocolHandler;


/**
 *
 */
public interface HttpProtocolHandler<T> extends ProtocolHandler<Void, T> {

    public static final HttpProtocolHandler<Message> SSE_HANDLER = new HttpProtocolHandlerAdapter<Message>() {
        @Override
        public void configure(ChannelPipeline pipeline) {
            pipeline.addAfter("http-response-decoder", SSEHandler.NAME, new SSEHandler());
        }        
    };

    public static final HttpProtocolHandler<FullHttpResponse> FULL_HTTP_RESPONSE_HANDLER = new FullHttpResponseHandler();
    
    public void configure(ChannelPipeline pipeline);
    
    public void onChannelConnectOperationCompleted(ChannelFuture connectFuture);
    
    public void onChannelWriteOperationCompleted(ChannelFuture requestWrittenFuture);
    
    public void onChannelCloseOperationCompleted(ChannelFuture channelCloseFuture);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8760480_a77e513/rev_8760480-a77e513/src/main/java/rx/netty/protocol/http/ObservableHttpClient.java;<<<<<<< MINE
/**
 * Copyright 2013 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.netty.protocol.http;

import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpClientCodec;
import io.netty.handler.codec.http.HttpContent;
import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpObject;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpResponse;
import io.netty.handler.codec.http.LastHttpContent;
import io.netty.util.concurrent.EventExecutor;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.GenericFutureListener;

import java.util.HashSet;
import java.util.Set;

import rx.Observable;
import rx.Observer;
import rx.Subscription;
import rx.subjects.PublishSubject;
import rx.subscriptions.Subscriptions;
import rx.util.functions.Action0;
import rx.util.functions.Action1;
import rx.util.functions.Func1;

public class ObservableHttpClient {
    
    private EventLoopGroup eventLoopGroup;

    // Chunk size in bytes
    private final int maxChunkSize;

    // Maximum initial line length in characters
    private final int maxInitialLineLength;

    // Maximum header size in bytes
    private final int maxHeaderSize;

    // Whether use compression when sending request
    private final boolean useCompression;

    // Flag on whether the client should follow HTTP redirects
    private final boolean followRedirects;

    // use agent string
    private final String userAgent;

    private final Set<ChannelSetting> channelSettings;

    private final EventExecutor eventExecutor;

    public ObservableHttpClient(
            EventLoopGroup eventLoopGroup,
            int maxChunkSize,
            int maxInitialLineLength,
            int maxHeaderSize,
            boolean useCompression,
            boolean followRedirects,
            String userAgent,
            Set<ChannelSetting> channelOptions,
            EventExecutor eventExecutor) {
        this.eventLoopGroup = eventLoopGroup;
        this.maxChunkSize = maxChunkSize;
        this.maxInitialLineLength = maxInitialLineLength;
        this.maxHeaderSize = maxHeaderSize;
        this.useCompression = useCompression;
        this.followRedirects = followRedirects;
        this.userAgent = userAgent;
        if (eventExecutor == null) {
            this.eventExecutor = eventLoopGroup.next();
        } else {
            this.eventExecutor = eventExecutor;
        }

        this.channelSettings = new HashSet<ChannelSetting>();
        for (ChannelSetting setting : channelOptions) {
            this.channelSettings.add(setting);
        }
    }

    private <T> ConnectionPromise<T, HttpRequest> makeConnection(Bootstrap bootstrap, UriInfo uriInfo, final HttpProtocolHandler<T> handler, final Observer<? super ObservableHttpResponse<T>> observer) {
        final ConnectionPromise<T, HttpRequest> connectionPromise = new ConnectionPromise<T, HttpRequest>(eventExecutor, handler);
        bootstrap.connect(uriInfo.getHost(), uriInfo.getPort())
        .addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (future.isSuccess()) {
                    connectionPromise.onConnect(future.channel());
                } else {
                    connectionPromise.tryFailure(future.cause());
                    observer.onError(future.cause());
                }
            }
        }).addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                handler.onChannelConnectOperationCompleted(future);
            }
        });
        return connectionPromise;
    }

    public Observable<ObservableHttpResponse<Message>> stream(final ValidatedFullHttpRequest request) {
        return execute(request, HttpProtocolHandlerAdapter.SSE_HANDLER);
    }

    public Observable<ObservableHttpResponse<FullHttpResponse>> request(final ValidatedFullHttpRequest request) {
        return execute(request, HttpProtocolHandlerAdapter.FULL_HTTP_RESPONSE_HANDLER);
    }

    public <T> Observable<ObservableHttpResponse<T>> execute(final ValidatedFullHttpRequest request, final HttpProtocolHandler<T> handler) {
        tryUpdateUserAgent(request);

        final ObservableHttpClient self = this;
        return Observable.create(new Observable.OnSubscribeFunc<ObservableHttpResponse<T>>() {
            @Override
            public Subscription onSubscribe(Observer<? super ObservableHttpResponse<T>> observer) {
                UriInfo uriInfo = request.getUriInfo();
                Bootstrap bootstrap = createBootstrap(handler, observer);
                final ConnectionPromise<T, HttpRequest> connectionPromise = makeConnection(bootstrap, uriInfo, handler, observer);

                RequestCompletionPromise<T, HttpRequest> requestCompletionPromise = new RequestCompletionPromise<T, HttpRequest>(self.eventExecutor, connectionPromise);

                GenericFutureListener<Future<RequestWriter<T, HttpRequest>>> listener = new ConnectionListener<T, HttpRequest>(connectionPromise, request, requestCompletionPromise);
                connectionPromise.addListener(listener);

                return Subscriptions.create(new Action0() {

                    @Override
                    public void call() {
                        try {
                            if (connectionPromise.channel() != null) {
                                connectionPromise.channel().close().sync()
                                        .addListener(new ChannelFutureListener() {                                            
                                            @Override
                                            public void operationComplete(ChannelFuture future) throws Exception {
                                                handler.onChannelCloseOperationCompleted(future);    
                                            }
                                        });
                            }
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            throw new RuntimeException("Failed to unsubscribe");
                        }
                    }
                });
            }
        });
    }

    private void tryUpdateUserAgent(ValidatedFullHttpRequest request) {
        if (userAgent != null && request.headers().get(HttpHeaders.Names.USER_AGENT) == null) {
            request.headers().set(HttpHeaders.Names.USER_AGENT, userAgent);
        }
    }

    private static class HttpObservableTracker<T> extends SimpleChannelInboundHandler<HttpObject> {
        protected Observer<? super ObservableHttpResponse<T>> observer;
        
        protected PublishSubject<T> subject;

        public HttpObservableTracker(HttpProtocolHandler<T> handler, Observer<? super ObservableHttpResponse<T>> observer) {
            this.observer = observer;
        }

        @Override
        protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg)
                throws Exception {
            if (msg instanceof HttpResponse) {
                HttpResponse response = (HttpResponse) msg;
                subject = PublishSubject.<T> create();
                final ObservableHttpResponse<T> httpResponse = new ObservableHttpResponse<T>(response, subject);
                ChannelPipeline pipeLine = ctx.channel().pipeline();
                ChannelHandler observerHandler = pipeLine.get("content-handler");
                if (observerHandler == null) {
                    pipeLine.addLast("content-handler", new HttpMessageObserver<T>(observer, httpResponse));
                } else {
                    pipeLine.replace(observerHandler, "content-handler", new HttpMessageObserver<T>(observer, httpResponse));
                }
                observer.onNext(httpResponse);
            }
            if (msg instanceof HttpContent) {
                ((HttpContent) msg).content().retain();
            }
            ctx.fireChannelRead(msg);
            if (msg instanceof LastHttpContent) {
                subject.onCompleted();
                observer.onCompleted();    
            }
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
                throws Exception {
            if (subject != null) {
                subject.onError(cause);
            }
            observer.onError(cause);
        }
    }

    private <T> Bootstrap createBootstrap(final HttpProtocolHandler<T> handler, final Observer<? super ObservableHttpResponse<T>> observer) {

        Bootstrap bootstrap = new Bootstrap();
        bootstrap
                .group(this.eventLoopGroup)
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel ch) throws Exception {
                        ch.pipeline()
                                //.addLast("log", new LoggingHandler(LogLevel.INFO))
                                .addLast("http-codec", new HttpClientCodec(maxInitialLineLength, maxHeaderSize, maxChunkSize))
                                .addLast("http-response-decoder", new HttpObservableTracker<T>(handler, observer))
                                // we need to add this to catch any exception before channel read happens and 
                                // deliver the exception to the observer
                                .addLast("content-handler", new HttpMessageObserver<T>(observer, null));
                    }
                })
                .option(ChannelOption.TCP_NODELAY, true)
                .channel(NioSocketChannel.class);

        for (ChannelSetting setting : channelSettings) {
            bootstrap.option(setting.getOption(), setting.getValue());
        }

        return bootstrap;
    }

    public static void main(String[] args) throws Exception {
        EventLoopGroup group = new NioEventLoopGroup();
        ObservableHttpClient client = new HttpClientBuilder().build(group);

        ValidatedFullHttpRequest request = ValidatedFullHttpRequest.get("http://ec2-54-202-113-170.us-west-2.compute.amazonaws.com:7001/turbine.stream?cluster=api-prod");

        request.getUriInfo().getUri().getRawPath();
        Observable<ObservableHttpResponse<Message>> response = client.execute(request, HttpProtocolHandlerAdapter.SSE_HANDLER);

        response.flatMap(new Func1<ObservableHttpResponse<Message>, Observable<Message>>() {
            @Override
            public Observable<Message> call(ObservableHttpResponse<Message> observableHttpResponse) {
                return observableHttpResponse.content();
            }
        }).subscribe(new Action1<Message>() {
            @Override
            public void call(Message message
                    ) {
                System.out.println(message);
            }
        });

        //group.shutdownGracefully();
    }

    /**
     * A class that captures a unique channel option value. This is class is necessary
     * because we can't declare a generic variable in a non-parametric class. That is,
     * we can't simply declare {@code Map<ChannelOption<T>, T> channelSettings} without
     * declaring the parameter {@code T}.
     * 
     * Note this is a special class. It is intended to be used in a collection, and its
     * uniqueness is associated only to the option (so to keep the semantics of {@link io.netty.util.UniqueName},
     * which {@link io.netty.channel.ChannelOption} extends).
     */
    private static final class ChannelSetting<T> {
        private final ChannelOption<T> option;
        private final T value;

        public ChannelSetting(ChannelOption<T> option, T value) {
            this.option = option;
            this.value = value;
        }

        public ChannelOption<T> getOption() {
            return option;
        }

        public T getValue() {
            return value;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;

            ChannelSetting that = (ChannelSetting) o;

            if (option != null ? !option.equals(that.option) : that.option != null)
                return false;

            return true;
        }

        @Override
        public int hashCode() {
            return option != null ? option.hashCode() : 0;
        }
    }

    public static HttpClientBuilder newBuilder() {
        return new HttpClientBuilder();
    }

    public static class HttpClientBuilder {
        // Chunk size in bytes
        private int maxChunkSize = 64 * 1024;

        // Maximum initial line length in characters
        private int maxInitialLineLength = 2048;

        // Maximum header size in bytes
        private int maxHeaderSize = 16 * 1024;

        // Whether use compression when sending request
        private boolean useCompression = false;

        // Flag on whether the client should follow HTTP redirects
        private boolean followRedirects = false;

        // Use Agent string sent with each request
        private String userAgent = "RxNetty Client";

        private EventExecutor eventExecutor;

        private Set<ChannelSetting> channelOptions = new HashSet<ChannelSetting>();

        public HttpClientBuilder maxChunkSize(int maxChunkSize) {
            this.maxChunkSize = maxChunkSize;
            return this;
        }

        public HttpClientBuilder maxInitialLineLength(int maxInitialLineLength) {
            this.maxInitialLineLength = maxInitialLineLength;
            return this;
        }

        public HttpClientBuilder maxHeaderSize(int maxHeaderSize) {
            this.maxHeaderSize = maxHeaderSize;
            return this;
        }

        public HttpClientBuilder useCompression(boolean useCompression) {
            this.useCompression = useCompression;
            return this;
        }

        public HttpClientBuilder followRedirects(boolean followRedirects) {
            this.followRedirects = followRedirects;
            return this;
        }

        public HttpClientBuilder setUserAgent(String userAgent) {
            this.userAgent = userAgent;
            return this;
        }

        public <T> HttpClientBuilder withChannelOption(ChannelOption<T> option, T value) {
            this.channelOptions.add(new ChannelSetting<T>(option, value));

            return this;
        }

        public HttpClientBuilder withEventExecutor(EventExecutor executor) {
            this.eventExecutor = executor;

            return this;
        }

        public ObservableHttpClient build(EventLoopGroup group) {
            return new ObservableHttpClient(group, maxChunkSize, maxInitialLineLength, maxHeaderSize, useCompression, followRedirects, userAgent, channelOptions, eventExecutor);
        }
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8760480_a77e513/rev_8760480-a77e513/src/main/java/rx/netty/protocol/http/HttpMessageObserver.java;<<<<<<< MINE
/**
 * Copyright 2013 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.netty.protocol.http;

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import rx.Observer;

/**
 * An inbound handler that observes incoming HTTP messages.
 */
public class HttpMessageObserver<T> extends ChannelInboundHandlerAdapter {

    private final Observer<? super ObservableHttpResponse<T>> observer;
    private volatile ObservableHttpResponse<T> response;

    public HttpMessageObserver(Observer<? super ObservableHttpResponse<T>> observer, ObservableHttpResponse<T> response) {
        if (observer == null) {
            throw new IllegalArgumentException("observer is null");
        }
        this.observer = observer;
        this.response = response;
    }

    // suppressing because Netty uses Object but we have typed HandlerObserver to I and expect only I
    @SuppressWarnings("unchecked")
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        if (response != null) {
            response.contentObserver().onNext((T) msg);
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        if (response != null) {
            response.contentObserver().onError(cause);
        } else {
            observer.onError(cause);
        }
    }

    @Override
    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
        super.channelUnregistered(ctx);
        response.contentObserver().onCompleted();
    }

    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt)
            throws Exception {
        if (evt == ObservableHttpResponse.Events.End) {
            response.contentObserver().onCompleted();    
            observer.onCompleted();
        }
    }
    
    
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8760480_a77e513/rev_8760480-a77e513/src/main/java/rx/netty/protocol/http/ConnectionPromise.java;<<<<<<< MINE
/**
 * Copyright 2013 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.netty.protocol.http;

import io.netty.channel.Channel;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.util.concurrent.DefaultPromise;
import io.netty.util.concurrent.EventExecutor;
import io.netty.util.concurrent.Promise;

/**
 * A {@link Promise} that gets set when a connection is established.
 * 
 * @param <T>
 *            The type of response messages.
 * @param <R>
 *            The request type
 */
class ConnectionPromise<T, R extends HttpRequest> extends DefaultPromise<RequestWriter<T, R>> {
    private EventExecutor executor;
    private Channel channel;
    private HttpProtocolHandler<T> handler;

    ConnectionPromise(EventExecutor executor, HttpProtocolHandler<T> handler) {
        this.executor = executor;
        this.handler = handler;
    }

    @Override
    protected EventExecutor executor() {
        return this.executor;
    }

    public Channel channel() {
        return channel;
    }

    void onConnect(Channel channel) {
        this.executor = channel.eventLoop();
        this.channel = channel;
        handler.configure(channel.pipeline());
        trySuccess(new RequestWriter<T, R>(channel, handler));
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8760480_a77e513/rev_8760480-a77e513/src/test/java/rx/netty/protocol/http/EmbeddedResources.java;<<<<<<< MINE
/**
 *
 * Copyright 2014 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package rx.netty.protocol.http;

import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;

import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.StreamingOutput;

import org.junit.Ignore;

@Ignore
@Path("/test")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public class EmbeddedResources {

    public static final List<String> smallStreamContent = new ArrayList<String>();

    public static final List<String> largeStreamContent = new ArrayList<String>();

    static {
        for (int i = 0; i < 3; i++) {
            smallStreamContent.add("line " + i);
        }
        for (int i = 0; i < 1000; i++) {
            largeStreamContent.add("line " + i);
        }
    }
    
    @GET
    @Path("/singleEntity")
    public Response getSingleEntity() throws IOException {
        return Response.ok("Hello world").build();
    }
    
    @GET
    @Path("/stream")
    @Produces("text/event-stream")
    public StreamingOutput getStream() {
        return new StreamingOutput() {
            @Override
            public void write(OutputStream output) throws IOException,
                    WebApplicationException {
                for (String line: smallStreamContent) {
                    String eventLine = "data:" + line + "\n\n";
                    output.write(eventLine.getBytes("UTF-8"));
                }
            }
        };
    }

    @GET
    @Path("/largeStream")
    @Produces("text/event-stream")
    public StreamingOutput getLargeStream() {
        return new StreamingOutput() {
            @Override
            public void write(OutputStream output) throws IOException,
                    WebApplicationException {
                for (String line: largeStreamContent) {
                    String eventLine = "data:" + line + "\n\n";
                    output.write(eventLine.getBytes("UTF-8"));
                }
            }
        };
    }
    
    @GET
    @Path("/timeout")
    public Response simulateTimeout(@QueryParam("timeout") int timeout) {
        try {
            Thread.sleep(timeout);
        } catch (Exception e) {
        }
        return Response.ok().build();
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8760480_a77e513/rev_8760480-a77e513/src/test/java/rx/netty/protocol/http/HttpClientTest.java;<<<<<<< MINE
/**
 * Copyright 2014 Netflix, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rx.netty.protocol.http;

import static org.junit.Assert.*;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.handler.codec.MessageToMessageDecoder;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpObjectAggregator;

import java.net.URI;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import rx.Observable;
import rx.Observer;
import rx.netty.protocol.http.ObservableHttpClient.HttpClientBuilder;
import rx.util.functions.Action1;
import rx.util.functions.Func1;

import com.google.mockwebserver.MockResponse;
import com.google.mockwebserver.MockWebServer;
import com.sun.jersey.api.container.httpserver.HttpServerFactory;
import com.sun.jersey.api.core.PackagesResourceConfig;
import com.sun.net.httpserver.HttpServer;

public class HttpClientTest {
    private static HttpServer server = null;
    private static String SERVICE_URI;

    private static int port;
    private static ObservableHttpClient client;

    private static class SingleEntityHandler extends HttpProtocolHandlerAdapter<String> {

        @Override
        public void configure(ChannelPipeline pipeline) {
            pipeline.addAfter("http-response-decoder", "http-aggregator", new HttpObjectAggregator(Integer.MAX_VALUE));
            pipeline.addAfter("http-aggregator", "entity-decoder", new StringEntityDecoder());
        }
    }
    
    private static class StringEntityDecoder extends MessageToMessageDecoder<FullHttpResponse> {

        @Override
        protected void decode(ChannelHandlerContext ctx, FullHttpResponse msg,
                List<Object> out) throws Exception {
            ByteBuf buf = msg.content();
            String content = buf.toString(Charset.defaultCharset());
            out.add(content);
        }
        
    }

    @BeforeClass
    public static void init() {
        PackagesResourceConfig resourceConfig = new PackagesResourceConfig("rx.netty.protocol.http");
        port = (new Random()).nextInt(1000) + 4000;
        SERVICE_URI = "http://localhost:" + port + "/";
        try{
            server = HttpServerFactory.create(SERVICE_URI, resourceConfig);
            server.start();
        } catch(Exception e) {
            e.printStackTrace();
            fail("Unable to start server");
        }
        EventLoopGroup group = new NioEventLoopGroup();
        client = new HttpClientBuilder().build(group);
    }

    @AfterClass
    public static void shutDown() {
        server.stop(0);
    }
    
    
    @Test
    public void testChunkedStreaming() throws Exception {
        ValidatedFullHttpRequest request = ValidatedFullHttpRequest.get(SERVICE_URI + "test/stream");

        Observable<ObservableHttpResponse<Message>> response = client.execute(request, HttpProtocolHandlerAdapter.SSE_HANDLER);
        
        final List<String> result = new ArrayList<String>();

        response.flatMap(new Func1<ObservableHttpResponse<Message>, Observable<Message>>() {
            @Override
            public Observable<Message> call(ObservableHttpResponse<Message> observableHttpResponse) {
                return observableHttpResponse.content();
            }
        }).toBlockingObservable().forEach(new Action1<Message>() {
            @Override
            public void call(Message message
                    ) {
                // System.out.println(message);
                result.add(message.getEventData());
            }
        });
        assertEquals(EmbeddedResources.smallStreamContent, result);
    }
    
    @Test
    public void testMultipleChunks() throws Exception {
        ValidatedFullHttpRequest request = ValidatedFullHttpRequest.get(SERVICE_URI + "test/largeStream");

        Observable<ObservableHttpResponse<Message>> response = client.execute(request, HttpProtocolHandlerAdapter.SSE_HANDLER);
        
        final List<String> result = new ArrayList<String>();

        response.flatMap(new Func1<ObservableHttpResponse<Message>, Observable<Message>>() {
            @Override
            public Observable<Message> call(ObservableHttpResponse<Message> observableHttpResponse) {
                return observableHttpResponse.content();
            }
        }).toBlockingObservable().forEach(new Action1<Message>() {
            @Override
            public void call(Message message
                    ) {
                // System.out.println(message);
                result.add(message.getEventData());
            }
        });
        // Thread.sleep(5000);
        assertEquals(EmbeddedResources.largeStreamContent, result);
        
    }

    @Test
    public void testSingleEntity() throws Exception {
        ValidatedFullHttpRequest request = ValidatedFullHttpRequest.get(SERVICE_URI + "test/singleEntity");
        final List<String> result = new ArrayList<String>();

        Observable<ObservableHttpResponse<String>> response = client.execute(request, new SingleEntityHandler());
        response.flatMap(new Func1<ObservableHttpResponse<String>, Observable<String>>() {

            @Override
            public Observable<String> call(ObservableHttpResponse<String> t1) {
                return t1.content();
            }
        }).toBlockingObservable().forEach(new Action1<String>() {

            @Override
            public void call(String t1) {
                result.add(t1);
            }
        });
        assertEquals(1, result.size());
        assertEquals("Hello world", result.get(0));
    }
    
    @Test
    public void testFullHttpResponse() throws Exception {
        ValidatedFullHttpRequest request = ValidatedFullHttpRequest.get(SERVICE_URI + "test/singleEntity");
        final List<String> result = new ArrayList<String>();

        Observable<ObservableHttpResponse<FullHttpResponse>> response = client.request(request);
        
        response.flatMap(new Func1<ObservableHttpResponse<FullHttpResponse>, Observable<FullHttpResponse>>() {
            @Override
            public Observable<FullHttpResponse> call(
                    ObservableHttpResponse<FullHttpResponse> t1) {
                return t1.content();
            }
        }).toBlockingObservable().forEach(new Action1<FullHttpResponse>() {

            @Override
            public void call(FullHttpResponse t1) {
                result.add(t1.content().toString(Charset.defaultCharset()));
            }
            
        });
        assertEquals(1, result.size());
        assertEquals("Hello world", result.get(0));
    }
    
    @Test
    public void testNonChunkingStream() throws Exception {
        MockWebServer server = new MockWebServer();
        String content = "";
        for (String s: EmbeddedResources.largeStreamContent) {
            content += "data:" + s + "\n\n";
        }
        server.enqueue(new MockResponse().setResponseCode(200).setHeader("Content-type", "text/event-stream")
                .setBody(content)
                .removeHeader("Content-Length"));
        server.play();
        
        // TODO: this does not work for UriInfo: https://github.com/Netflix/RxNetty/issues/12
        // URI url = server.getUrl("/").toURI();

        URI url = new URI("http://localhost:" + server.getPort() + "/"); 
        
        System.err.println("Using URI: " + url);
        ValidatedFullHttpRequest request = ValidatedFullHttpRequest.get(url);
        Observable<ObservableHttpResponse<Message>> response = client.execute(request, HttpProtocolHandlerAdapter.SSE_HANDLER);
        
        final List<String> result = new ArrayList<String>();

        response.flatMap(new Func1<ObservableHttpResponse<Message>, Observable<Message>>() {
            @Override
            public Observable<Message> call(ObservableHttpResponse<Message> observableHttpResponse) {
                return observableHttpResponse.content();
            }
        }).subscribe(new Action1<Message>() {
            @Override
            public void call(Message message
                    ) {
                result.add(message.getEventData());
            }
        }, new Action1<Throwable>() {
            @Override
            public void call(Throwable t1) {
                t1.printStackTrace();
            }
        });
        Thread.sleep(2000);
        assertEquals(EmbeddedResources.largeStreamContent, result);
        server.shutdown();
    }
    
    @Test
    public void testConnectException() throws Exception {
        ValidatedFullHttpRequest request = ValidatedFullHttpRequest.get("http://www.google.com:81/");
        ObservableHttpClient timeoutClient = ObservableHttpClient.newBuilder()
        .withChannelOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10)
        .build(new NioEventLoopGroup());
        Observable<ObservableHttpResponse<FullHttpResponse>> response = timeoutClient.request(request);
        final CountDownLatch latch = new CountDownLatch(1);
        final AtomicReference<Throwable> ex = new AtomicReference<Throwable>();
        response.subscribe(new Action1<ObservableHttpResponse<FullHttpResponse>>() {
            @Override
            public void call(ObservableHttpResponse<FullHttpResponse> t1) {
                latch.countDown();
            }
            
        }, new Action1<Throwable>() {
            @Override
            public void call(Throwable t1) {
                ex.set(t1);
                latch.countDown();
            }
        });
        latch.await(2, TimeUnit.SECONDS);
        assertTrue(ex.get() instanceof io.netty.channel.ConnectTimeoutException);
    }
    
    @Test
    public void testConnectException2() throws Exception {
        ValidatedFullHttpRequest request = ValidatedFullHttpRequest.get("http://www.google.com:81/");
        ObservableHttpClient timeoutClient = ObservableHttpClient.newBuilder()
        .withChannelOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10)
        .build(new NioEventLoopGroup());
        Observable<ObservableHttpResponse<FullHttpResponse>> response = timeoutClient.request(request);
        final CountDownLatch latch = new CountDownLatch(1);
        final AtomicReference<Throwable> ex = new AtomicReference<Throwable>();
        response.flatMap(new Func1<ObservableHttpResponse<FullHttpResponse>, Observable<FullHttpResponse>>() {
            @Override
            public Observable<FullHttpResponse> call(
                    ObservableHttpResponse<FullHttpResponse> t1) {
                return t1.content();
            }
        }).subscribe(new Action1<FullHttpResponse>() {
            @Override
            public void call(FullHttpResponse t1) {
                latch.countDown();
            }
            
        }, new Action1<Throwable>() {
            @Override
            public void call(Throwable t1) {
                ex.set(t1);
                latch.countDown();
            }
        });
        latch.await(100000, TimeUnit.SECONDS);
        assertTrue(ex.get() instanceof io.netty.channel.ConnectTimeoutException);
    }

    
    @Test
    public void testTimeout() throws Exception {
        ValidatedFullHttpRequest request = ValidatedFullHttpRequest.get(SERVICE_URI + "test/timeout?timeout=10000");
        Observable<ObservableHttpResponse<FullHttpResponse>> response = client.execute(request, new FullHttpResponseHandler(10));
        final CountDownLatch latch = new CountDownLatch(1);
        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
        response.flatMap(new Func1<ObservableHttpResponse<FullHttpResponse>, Observable<FullHttpResponse>>() {
            @Override
            public Observable<FullHttpResponse> call(
                    ObservableHttpResponse<FullHttpResponse> t1) {
                return t1.content();
            }
        }).subscribe(new Observer<FullHttpResponse>() {
            @Override
            public void onCompleted() {
                latch.countDown();
            }

            @Override
            public void onError(Throwable e) {
                exception.set(e);
                latch.countDown();
            }

            @Override
            public void onNext(FullHttpResponse args) {
                latch.countDown();
            }
        });
        if (!latch.await(2, TimeUnit.SECONDS)) {
            fail("Observer is not called without timeout");
        } else {
            assertTrue(exception.get() instanceof io.netty.handler.timeout.ReadTimeoutException);
        }
    }
    
    @Test
    public void testNoReadTimeout() throws Exception {
        ValidatedFullHttpRequest request = ValidatedFullHttpRequest.get(SERVICE_URI + "test/singleEntity");
        // Set a read timeout of 2 seconds
        Observable<ObservableHttpResponse<FullHttpResponse>> response = client.execute(request, new FullHttpResponseHandler(2000));
        
        final AtomicReference<Throwable> exceptionHolder = new AtomicReference<Throwable>();
        final AtomicReference<FullHttpResponse> responseHolder = new AtomicReference<FullHttpResponse>(); 
        response.flatMap(new Func1<ObservableHttpResponse<FullHttpResponse>, Observable<FullHttpResponse>>() {
            @Override
            public Observable<FullHttpResponse> call(
                    ObservableHttpResponse<FullHttpResponse> t1) {
                return t1.content();
            }
        }).subscribe(new Observer<FullHttpResponse>() {
            @Override
            public void onCompleted() {
            }

            @Override
            public void onError(Throwable e) {
                exceptionHolder.set(e);
            }

            @Override
            public void onNext(FullHttpResponse args) {
                responseHolder.set(args);
            }
        });
        Thread.sleep(3000);
        assertNull(exceptionHolder.get());
        assertEquals(200, responseHolder.get().getStatus().code());
    }

}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/xodus/revisions/rev_b1b59d5_956e4bc/rev_b1b59d5-956e4bc/environment/src/main/java/jetbrains/exodus/log/CompoundByteIteratorBase.java;<<<<<<< MINE
=======
/**
 * Copyright 2010 - 2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.exodus.log;

import jetbrains.exodus.ByteIterable;
import jetbrains.exodus.ByteIterator;
import jetbrains.exodus.ExodusException;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

abstract class CompoundByteIteratorBase implements ByteIterator {

    @Nullable
    private ByteIterator current;

    CompoundByteIteratorBase(@NotNull ByteIterator current) {
        this.current = current;
    }

    CompoundByteIteratorBase() {
        this(ByteIterable.EMPTY_ITERATOR);
    }

    @Override
    public boolean hasNext() {
        if (current == null) {
            return false;
        }
        if (current.hasNext()) {
            return true;
        }
        current = nextIterator();
        return hasNext();
    }

    @Override
    public long skip(final long length) {
        long skipped = 0;
        while (current != null) {
            skipped += current.skip(length - skipped);
            if (skipped >= length || !hasNext()) {
                break;
            }
        }
        return skipped;
    }

    @Override
    public byte next() {
        if (!hasNext()) {
            onFail("CompoundByteIterator: no more bytes available");
        }
        //noinspection ConstantConditions
        return current.next();
    }

    @NotNull
    protected ByteIterator getCurrent() {
        if (current == null) {
            throw new ExodusException("Can't get current ByteIterator, hasNext() == false");
        }
        return current;
    }

    /**
     * @return null to finish.
     */
    protected abstract ByteIterator nextIterator();

    protected void onFail(@NotNull final String message) throws ExodusException {
        throw new ExodusException(message);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/xodus/revisions/rev_e08ae6e_5b08af2/rev_e08ae6e-5b08af2/openAPI/src/main/java/jetbrains/exodus/util/SharedRandomAccessFile.java;<<<<<<< MINE
=======
/**
 * Copyright 2010 - 2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.exodus.util;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.concurrent.atomic.AtomicInteger;

public class SharedRandomAccessFile extends RandomAccessFile {

    private final File file;
    private final AtomicInteger clients;

    public SharedRandomAccessFile(File file, String mode) throws FileNotFoundException {
        super(file, mode);
        this.file = file;
        clients = new AtomicInteger();
    }

    public File getFile() {
        return file;
    }

    /**
     * Employs the file and returns resulting number of its clients.
     *
     * @return number of clients of the file.
     */
    public int employ() {
        return clients.incrementAndGet();
    }

    public void close() throws IOException {
        if (clients.getAndDecrement() == 0) {
            super.close();
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/xodus/revisions/rev_5de5636_3b99a1e/rev_5de5636-3b99a1e/openAPI/src/main/java/jetbrains/exodus/util/DeferredIO.java;<<<<<<< MINE
=======
/**
 * Copyright 2010 - 2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.exodus.util;

import jetbrains.exodus.core.execution.JobProcessorAdapter;
import jetbrains.exodus.core.execution.ThreadJobProcessorPool;

public class DeferredIO {

    private static volatile JobProcessorAdapter deferredIOProcessor = null;

    private DeferredIO() {
    }

    public static JobProcessorAdapter getJobProcessor() {
        if (deferredIOProcessor == null) {
            synchronized (DeferredIO.class) {
                if (deferredIOProcessor == null) {
                    deferredIOProcessor = ThreadJobProcessorPool.getOrCreateJobProcessor("Exodus shared deferred I/O job processor");
                }
            }
        }
        return deferredIOProcessor;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/xodus/revisions/rev_6212f9c_b8030b1/rev_6212f9c-b8030b1/openAPI/src/main/java/jetbrains/exodus/ByteIterator.java;<<<<<<< MINE
/**
 * Iterator of {@link ByteIterable}. Enumerates bytes without boxing.
 */
public interface ByteIterator {
=======
import jetbrains.exodus.bindings.LongBinding;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/xodus/revisions/rev_6212f9c_b8030b1/rev_6212f9c-b8030b1/openAPI/src/main/java/jetbrains/exodus/ByteIterator.java;<<<<<<< MINE
    /**
     * @return {@code true} if the iterator has more bytes
     */
    boolean hasNext();
=======
public abstract class ByteIterator {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/xodus/revisions/rev_6212f9c_b8030b1/rev_6212f9c-b8030b1/environment/src/main/java/jetbrains/exodus/log/CompoundByteIteratorBase.java;<<<<<<< MINE
=======
/**
 * Copyright 2010 - 2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.exodus.log;

import jetbrains.exodus.ByteIterable;
import jetbrains.exodus.ByteIterator;
import jetbrains.exodus.ExodusException;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

abstract class CompoundByteIteratorBase extends ByteIterator {

    @Nullable
    private ByteIterator current;

    CompoundByteIteratorBase(@NotNull ByteIterator current) {
        this.current = current;
    }

    CompoundByteIteratorBase() {
        this(ByteIterable.EMPTY_ITERATOR);
    }

    @Override
    public boolean hasNext() {
        if (current == null) {
            return false;
        }
        if (current.hasNext()) {
            return true;
        }
        current = nextIterator();
        return hasNext();
    }

    @Override
    public long skip(final long length) {
        long skipped = 0;
        while (current != null) {
            skipped += current.skip(length - skipped);
            if (skipped >= length || !hasNext()) {
                break;
            }
        }
        return skipped;
    }

    @Override
    public byte next() {
        if (!hasNext()) {
            onFail("CompoundByteIterator: no more bytes available");
        }
        //noinspection ConstantConditions
        return current.next();
    }

    @NotNull
    protected ByteIterator getCurrent() {
        if (current == null) {
            throw new ExodusException("Can't get current ByteIterator, hasNext() == false");
        }
        return current;
    }

    /**
     * @return null to finish.
     */
    protected abstract ByteIterator nextIterator();

    protected void onFail(@NotNull final String message) throws ExodusException {
        throw new ExodusException(message);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/xodus/revisions/rev_bfa7297_28d83f7/rev_bfa7297-28d83f7/openAPI/src/main/java/jetbrains/exodus/entitystore/EntityIterableHandle.java;<<<<<<< MINE
=======
/**
 * Copyright 2010 - 2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.exodus.entitystore;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public interface EntityIterableHandle {

    @NotNull
    EntityIterableType getType();

    Object getIdentity();

    boolean isMatchedEntityAdded(@NotNull EntityId added);

    boolean isMatchedEntityDeleted(@NotNull EntityId deleted);

    boolean isMatchedLinkAdded(@NotNull EntityId source, @NotNull EntityId target, int linkId);

    boolean isMatchedLinkDeleted(@NotNull EntityId source, @NotNull EntityId target, int linkId);

    boolean isMatchedPropertyChanged(int entityType, int propertyId,
                                     @Nullable Comparable oldValue, @Nullable Comparable newValue);

    @NotNull
    int[] getLinkIds();

    boolean hasLinkId(int id);

    boolean hasEntityTypeId(int entityTypeId);

    boolean isExpired();
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/xodus/revisions/rev_f4c3310_e47d8bc/rev_f4c3310-e47d8bc/openAPI/src/main/java/jetbrains/exodus/entitystore/ComparableGetter.java;<<<<<<< MINE
=======
/**
 * Copyright 2010 - 2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.exodus.entitystore;

public interface ComparableGetter {

    Comparable select(final Entity entity);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/xodus/revisions/rev_41b74a4_68b45ff/rev_41b74a4-68b45ff/openAPI/src/main/java/jetbrains/exodus/entitystore/ComparableGetter.java;<<<<<<< MINE
=======
/**
 * Copyright 2010 - 2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.exodus.entitystore;

public interface ComparableGetter {

    Comparable select(final Entity entity);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_9f9d8ca_91e8564/rev_9f9d8ca-91e8564/core/src/test/java/dagger/InjectionTest.java;<<<<<<< MINE
  @Test public void noConstructorInjectionsForClassesWithTypeParameters() {
    class Parameterized<T> {
=======
  static class Parameterized<T> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_9f9d8ca_91e8564/rev_9f9d8ca-91e8564/core/src/test/java/dagger/ModuleIncludesTest.java;<<<<<<< MINE
    class TestEntryPoint {
      @Inject String s;
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_9f9d8ca_91e8564/rev_9f9d8ca-91e8564/core/src/test/java/dagger/ModuleIncludesTest.java;<<<<<<< MINE
    class TestEntryPoint {
      @Inject String s;
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_9f9d8ca_91e8564/rev_9f9d8ca-91e8564/core/src/test/java/dagger/ModuleIncludesTest.java;<<<<<<< MINE
    class TestEntryPoint {
      @Inject String s;
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_d9d306a_4f8a41d/rev_d9d306a-4f8a41d/rxnetty/src/main/java/io/reactivex/netty/protocol/http/UnicastContentSubject.java;<<<<<<< MINE
    private static final class ByteBufAwareBuffer<T> {

        private final ConcurrentLinkedQueue<Object> actual = new ConcurrentLinkedQueue<Object>();
        private final NotificationLite<T> nl = NotificationLite.instance();

        private void add(Object toAdd) {
            ReferenceCountUtil.retain(toAdd); // Released when the notification is sent.
            actual.add(toAdd);
        }

        public void sendAllNotifications(Observer<? super T> observer) {
            Object notification; // Can be onComplete notification, onError notification or just the actual "T".
            while ((notification = actual.poll()) != null) {
                try {
                    nl.accept(observer, notification);
                } finally {
                    ReferenceCountUtil.release(notification); // If it is the actual T for onNext and is a ByteBuf, it will be released.
                }
            }
        }
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/client/ServerPool.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.client;

import io.reactivex.netty.metrics.MetricEventsListener;
import io.reactivex.netty.metrics.MetricsEvent;
import rx.Observable;
import rx.annotations.Experimental;

import java.net.SocketAddress;
import java.util.NoSuchElementException;

/**
 * A pool of servers that returns a "best-suited" {@link Server} every time {@link #next()} is invoked.
 *
 * Typical use of this pool is to implement a load-balancer for distributing load over a pool of target servers.
 *
 * @author Nitesh Kant
 */
@Experimental
public interface ServerPool<M extends MetricsEvent<?>> {

    /**
     * Returns a {@link Server} instance upon each invocation.
     *
     * @return A server.
     *
     * @throws NoSuchElementException If there is no server available in the pool.
     */
    Server<M> next();

    /**
     * A contract for a server returned by {@link ServerPool}.
     *
     * @param <M>
     */
    interface Server<M extends MetricsEvent<?>> extends MetricEventsListener<M> {

        /**
         * The address for this server.
         *
         * @return The socket address for this server.
         */
        SocketAddress getAddress();

        /**
         * An {@link Observable} representing the lifecycle of this server. A terminal event on this {@link Observable}
         * would indicate removal of the server from the pool. This would be an opportunity for the client using this
         * {@link ServerPool} to cleanup resources associated to this server.
         *
         * @return An {@link Observable} representing the lifecycle of this server.
         */
        Observable<Void> getLifecycle();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/protocol/http/internal/HttpTrailerSubscriberEvent.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.internal;

import io.reactivex.netty.protocol.http.TrailingHeaders;
import rx.Subscriber;

public class HttpTrailerSubscriberEvent {

    private final Subscriber<? super TrailingHeaders> subscriber;

    public HttpTrailerSubscriberEvent(Subscriber<? super TrailingHeaders> subscriber) {
        this.subscriber = subscriber;
    }

    public Subscriber<? super TrailingHeaders> getSubscriber() {
        return subscriber;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/protocol/http/internal/OperatorTrailer.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.internal;

import io.reactivex.netty.protocol.http.TrailingHeaders;
import rx.Observable;
import rx.Observable.Operator;
import rx.Subscriber;
import rx.exceptions.Exceptions;
import rx.exceptions.OnErrorThrowable;
import rx.functions.Func0;
import rx.functions.Func2;

@SuppressWarnings({"rawtypes", "unchecked"})
public class OperatorTrailer<T extends TrailingHeaders> implements Operator {

    private final Func0<T> trailerFactory;
    private final Func2 trailerMutator;

    public OperatorTrailer(Func0<T> trailerFactory, Func2 trailerMutator) {
        this.trailerFactory = trailerFactory;
        this.trailerMutator = trailerMutator;
    }

    @Override
    public Object call(Object child) {
        final Subscriber subscriber = (Subscriber) child;
        return new Subscriber(subscriber) {

            private T trailer = trailerFactory.call();

            @SuppressWarnings("unchecked")
            @Override
            public void onCompleted() {
                subscriber.onNext(trailer);
                subscriber.onCompleted();
            }

            @Override
            public void onError(Throwable e) {
                subscriber.onError(e);
            }

            @SuppressWarnings("unchecked")
            @Override
            public void onNext(Object i) {
                try {
                    trailer = (T) trailerMutator.call(trailer, i);
                    subscriber.onNext(i);
                } catch (Throwable e) {
                    Exceptions.throwIfFatal(e);
                    onError(OnErrorThrowable.addValueAsLastCause(e, i));
                }
            }
        };
    }

    @SuppressWarnings("unchecked")
    public static <T extends TrailingHeaders> Observable liftFrom(Observable source,
                                                                   Func0<T> trailerFactory, Func2 trailerMutator) {
        return source.lift(new OperatorTrailer<T>(trailerFactory, trailerMutator));
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServerResponse.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.handler.codec.http.Cookie;
import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpMessage;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.reactivex.netty.protocol.http.TrailingHeaders;
import rx.Observable;
import rx.functions.Func0;
import rx.functions.Func1;
import rx.functions.Func2;

import java.text.ParseException;
import java.util.Date;
import java.util.List;
import java.util.Set;

/**
 * An HTTP server response.
 *
 * <h2>Thread safety</h2>
 *
 * This object is <b>not</b> thread safe and should not be accessed from multiple threads.
 *
 * @param <C> The type of objects written as the content of the response.
 */
public abstract class HttpServerResponse<C> {

    /**
     * Returns the status of this response. If the status is not explicitly set, the default value is
     * {@link HttpResponseStatus#OK}
     *
     * @return The status of this response.
     */
    public abstract HttpResponseStatus getStatus();

    /**
     * Checks if there is a header with the passed name in this response.
     *
     * @param name Name of the header.
     *
     * @return {@code true} if there is a header with the passed name in this response.
     */
    public abstract boolean containsHeader(CharSequence name);

    /**
     * Checks if there is a header with the passed name and value in this response.
     *
     * @param name Name of the header.
     * @param value Value of the header.
     * @param ignoreCaseValue {@code true} then the value comparision is done ignoring case.
     *
     * @return {@code true} if there is a header with the passed name and value in this response.
     */
    public abstract boolean containsHeader(CharSequence name, CharSequence value, boolean ignoreCaseValue);

    /**
     * Returns the value of a header with the specified name.  If there are more than one values for the specified name,
     * the first value is returned.
     *
     * @param name The name of the header to search
     * @return The first header value or {@code null} if there is no such header
     */
    public abstract String getHeader(CharSequence name);

    /**
     * Returns the value of a header with the specified name.  If there are more than one values for the specified name,
     * the first value is returned.
     *
     * @param name The name of the header to search
     * @param defaultValue Default if the header does not exist.
     *
     * @return The first header value or {@code defaultValue} if there is no such header
     */
    public abstract String getHeader(CharSequence name, String defaultValue);

    /**
     * Returns the values of headers with the specified name
     *
     * @param name The name of the headers to search
     *
     * @return A {@link java.util.List} of header values which will be empty if no values are found
     */
    public abstract List<String> getAllHeaderValues(CharSequence name);

    /**
     * Returns the date header value with the specified header name.  If there are more than one header value for the
     * specified header name, the first value is returned.
     * The value is parsed as per the
     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> using the format:
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name The name of the header to search
     *
     * @return the header value
     *
     * @throws ParseException if there is no such header or the header value is not a formatted date
     */
    public abstract Date getDateHeader(CharSequence name) throws ParseException;

    /**
     * Returns the date header value with the specified header name.  If there are more than one header value for the
     * specified header name, the first value is returned.
     * The value is parsed as per the
     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> using the format:
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name The name of the header to search
     * @param defaultValue Default value if there is no header with this name.
     *
     * @return the header value or {@code defaultValue} if there is no header with this name.
     */
    public abstract Date getDateHeader(CharSequence name, Date defaultValue);

    /**
     * Returns the integer header value with the specified header name.  If there are more than one header value for
     * the specified header name, the first value is returned.
     *
     * @param name The name of the header to search
     *
     * @return the header value
     *
     * @throws NumberFormatException if there is no such header or the header value is not a number
     */
    public abstract int getIntHeader(CharSequence name);

    /**
     * Returns the integer header value with the specified header name.  If there are more than one header value for
     * the specified header name, the first value is returned.
     *
     * @param name The name of the header to search
     * @param defaultValue Default if the header does not exist.
     *
     * @return the header value or the {@code defaultValue} if there is no such header or the header value is not a
     * number
     */
    public abstract int getIntHeader(CharSequence name, int defaultValue);

    /**
     * Returns a new {@link Set} that contains the names of all headers in this response.  Note that modifying the
     * returned {@link Set} will not affect the state of this response.
     */
    public abstract Set<String> getHeaderNames();

    /**
     * Adds an HTTP header with the passed {@code name} and {@code value} to this response.
     *
     * @param name Name of the header.
     * @param value Value for the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerResponse<C> addHeader(CharSequence name, Object value);

    /**
     * Adds the passed {@code cookie} to this response.
     *
     * @param cookie Cookie to add.
     *
     * @return {@code this}
     */
    public abstract HttpServerResponse<C> addCookie(Cookie cookie);

    /**
     * Adds the passed header as a date value to this response. The date is formatted using netty's
     * {@link HttpHeaders#addDateHeader(HttpMessage, CharSequence, Date)} which formats the date as per the
     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> into the format:
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name Name of the header.
     * @param value Value of the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerResponse<C> addDateHeader(CharSequence name, Date value);

    /**
     * Adds multiple date values for the passed header name to this response. The date values are formatted using netty's
     * {@link HttpHeaders#addDateHeader(HttpMessage, CharSequence, Date)} which formats the date as per the
     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> into the format:
     *
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name Name of the header.
     * @param values Values for the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerResponse<C> addDateHeader(CharSequence name, Iterable<Date> values);

    /**
     * Adds an HTTP header with the passed {@code name} and {@code values} to this response.
     *
     * @param name Name of the header.
     * @param values Values for the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerResponse<C> addHeader(CharSequence name, Iterable<Object> values);

    /**
     * Overwrites the current value, if any, of the passed header to the passed date value for this response. The date is
     * formatted using netty's {@link HttpHeaders#addDateHeader(HttpMessage, CharSequence, Date)} which formats the date
     * as per the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> into
     * the format:
     * <p/>
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name Name of the header.
     * @param value Value of the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerResponse<C> setDateHeader(CharSequence name, Date value);

    /**
     * Overwrites the current value, if any, of the passed header to the passed value for this response.
     *
     * @param name Name of the header.
     * @param value Value of the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerResponse<C> setHeader(CharSequence name, Object value);

    /**
     * Overwrites the current value, if any, of the passed header to the passed date values for this response. The date
     * is formatted using netty's {@link HttpHeaders#addDateHeader(HttpMessage, CharSequence, Date)} which formats the
     * date as per the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a>
     * into the format:
     * <p/>
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name Name of the header.
     * @param values Values of the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerResponse<C> setDateHeader(CharSequence name, Iterable<Date> values);

    /**
     * Overwrites the current value, if any, of the passed header to the passed values for this response.
     *
     * @param name Name of the header.
     * @param values Values of the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerResponse<C> setHeader(CharSequence name, Iterable<Object> values);

    /**
     * Removes the passed header from this response.
     *
     * @param name Name of the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerResponse<C> removeHeader(CharSequence name);

    /**
     * Sets the status for the response.
     *
     * @param status Status to set.
     *
     * @return {@code this}
     */
    public abstract HttpServerResponse<C> setStatus(HttpResponseStatus status);

    /**
     * Writes the headers for the response on the underlying channel.
     *
     * Any modification to the headers after this point, will not be written on the channel and any subsequent calls to
     * this method will result in error.
     *
     * @return A {@link ContentWriter} to optionally write content. If this method has already been
     * called, then the returned {@link ContentWriter} will always throw an error when subscribed.
     */
    public abstract ContentWriter<C> sendHeaders();

    /**
     * A facility to optionally write content to the response.
     *
     * <h2>Thread safety</h2>
     *
     * This object is not thread-safe and can not be accessed from multiple threads.
     */
    public static abstract class ContentWriter<C> extends Observable<Void> {

        protected ContentWriter(OnSubscribe<Void> f) {
            super(f);
        }

        /**
         * On subscription of the returned {@link Observable}, writes the passed message stream on the underneath channel.
         *
         * <h2>Flush</h2>
         *
         * The writes are flushed when the passed stream completes.
         *
         * @param msgs Stream of messages to write.
         *
         * @return {@link Observable} representing the result of this write. Every subscription to this {@link Observable}
         * will replay the write on the channel.
         */
        public abstract ContentWriter<C> write(Observable<C> msgs);

        /**
         * Uses the passed {@link Observable} as the source of content for this request. This method provides a way to
         * write trailing headers.
         *
         * A new instance of {@link TrailingHeaders} will be created using the passed {@code trailerFactory} and the passed
         * {@code trailerMutator} will be invoked for every item emitted from the content source, giving a chance to modify
         * the trailing headers instance.
         *
         * <h2>Multiple invocations</h2>
         *
         * This method can <em>not</em> be invoked multiple times for the same response as on completion of the passed
         * source, it writes the trailing headers and trailing headers can only be written once for an HTTP response.
         * So, any subsequent invocation of this method will always emit an error when subscribed.
         *
         * <h2>Flush</h2>
         *
         * The writes are flushed when the passed stream completes.
         *
         * @param contentSource Content source for the response.
         * @param trailerFactory A factory function to create a new {@link TrailingHeaders} per subscription of the content.
         * @param trailerMutator A function to mutate the trailing header on each item emitted from the content source.
         *
         * @return An new instance of {@link Observable} which can be subscribed to execute the request.
         */
        public abstract <T extends TrailingHeaders> Observable<Void> write(Observable<C> contentSource,
                                                                           Func0<T> trailerFactory,
                                                                           Func2<T, C, T> trailerMutator);

        /**
         * Uses the passed {@link Observable} as the source of content for this request. This method provides a way to
         * write trailing headers.
         *
         * A new instance of {@link TrailingHeaders} will be created using the passed {@code trailerFactory} and the passed
         * {@code trailerMutator} will be invoked for every item emitted from the content source, giving a chance to modify
         * the trailing headers instance.
         *
         * <h2>Multiple invocations</h2>
         *
         * This method can <em>not</em> be invoked multiple times for the same response as on completion of the passed
         * source, it writes the trailing headers and trailing headers can only be written once for an HTTP response.
         * So, any subsequent invocation of this method will always emit an error when subscribed.
         *
         * @param contentSource Content source for the response.
         * @param trailerFactory A factory function to create a new {@link TrailingHeaders} per subscription of the content.
         * @param trailerMutator A function to mutate the trailing header on each item emitted from the content source.
         * @param flushSelector A {@link Func1} which is invoked for every item emitted from {@code msgs}. Channel is
         * flushed, iff this function returns, {@code true}.
         *
         * @return An new instance of {@link Observable} which can be subscribed to execute the request.
         */
        public abstract <T extends TrailingHeaders> Observable<Void> write(Observable<C> contentSource,
                                                                           Func0<T> trailerFactory,
                                                                           Func2<T, C, T> trailerMutator,
                                                                           Func1<C, Boolean> flushSelector);

        /**
         * On subscription of the returned {@link Observable}, writes the passed message stream on the underneath channel
         * and flushes the channel, everytime, {@code flushSelector} returns {@code true} . Any writes issued before
         * subscribing, will also be flushed. However, the returned {@link Observable} will not capture the result of those
         * writes, i.e. if the other writes, fail and this write does not, the returned {@link Observable} will not fail.
         *
         * @param msgs Message stream to write.
         * @param flushSelector A {@link Func1} which is invoked for every item emitted from {@code msgs}.
         * Channel is flushed, iff this function returns, {@code true}.
         *
         * @return An {@link Observable} representing the result of this and all writes done prior to the flush. Every
         * subscription to this {@link Observable} will write the passed messages and flush all pending writes, when the
         * {@code flushSelector} returns {@code true}
         */
        public abstract ContentWriter<C> write(Observable<C> msgs, Func1<C, Boolean> flushSelector);

        /**
         * On subscription of the returned {@link Observable}, writes the passed message stream on the underneath channel
         * and flushes the channel, on every write. Any writes issued before subscribing, will also be flushed. However, the
         * returned {@link Observable} will not capture the result of those writes, i.e. if the other writes, fail and this
         * write does not, the returned {@link Observable} will not fail.
         *
         * @param msgs Message stream to write.
         *
         * @return An {@link Observable} representing the result of this and all writes done prior to the flush. Every
         * subscription to this {@link Observable} will write the passed messages and flush all pending writes, on every
         * write.
         */
        public abstract ContentWriter<C> writeAndFlushOnEach(Observable<C> msgs);

        /**
         * On subscription of the returned {@link Observable}, writes the passed message stream on the underneath channel.
         *
         * <h2>Flush</h2>
         *
         * The writes are flushed when the passed stream completes.
         *
         * @param msgs Stream of messages to write.
         *
         * @return {@link Observable} representing the result of this write. Every subscription to this {@link Observable}
         * will replay the write on the channel.
         */
        public abstract ContentWriter<C> writeString(Observable<String> msgs);

        /**
         * Uses the passed {@link Observable} as the source of content for this request. This method provides a way to
         * write trailing headers.
         *
         * A new instance of {@link TrailingHeaders} will be created using the passed {@code trailerFactory} and the passed
         * {@code trailerMutator} will be invoked for every item emitted from the content source, giving a chance to modify
         * the trailing headers instance.
         *
         * <h2>Multiple invocations</h2>
         *
         * This method can <em>not</em> be invoked multiple times for the same response as on completion of the passed
         * source, it writes the trailing headers and trailing headers can only be written once for an HTTP response.
         * So, any subsequent invocation of this method will always emit an error when subscribed.
         *
         * <h2>Flush</h2>
         *
         * The writes are flushed when the passed stream completes.
         *
         * @param contentSource Content source for the response.
         * @param trailerFactory A factory function to create a new {@link TrailingHeaders} per subscription of the content.
         * @param trailerMutator A function to mutate the trailing header on each item emitted from the content source.
         *
         * @return An new instance of {@link Observable} which can be subscribed to execute the request.
         */
        public abstract <T extends TrailingHeaders> Observable<Void> writeString(Observable<String> contentSource,
                                                                                 Func0<T> trailerFactory,
                                                                                 Func2<T, String, T> trailerMutator);

        /**
         * Uses the passed {@link Observable} as the source of content for this request. This method provides a way to
         * write trailing headers.
         *
         * A new instance of {@link TrailingHeaders} will be created using the passed {@code trailerFactory} and the passed
         * {@code trailerMutator} will be invoked for every item emitted from the content source, giving a chance to modify
         * the trailing headers instance.
         *
         * <h2>Multiple invocations</h2>
         *
         * This method can <em>not</em> be invoked multiple times for the same response as on completion of the passed
         * source, it writes the trailing headers and trailing headers can only be written once for an HTTP response.
         * So, any subsequent invocation of this method will always emit an error when subscribed.
         *
         * @param contentSource Content source for the response.
         * @param trailerFactory A factory function to create a new {@link TrailingHeaders} per subscription of the content.
         * @param trailerMutator A function to mutate the trailing header on each item emitted from the content source.
         * @param flushSelector A {@link Func1} which is invoked for every item emitted from {@code msgs}. Channel is
         * flushed, iff this function returns, {@code true}.
         *
         * @return An new instance of {@link Observable} which can be subscribed to execute the request.
         */
        public abstract <T extends TrailingHeaders> Observable<Void> writeString(Observable<String> contentSource,
                                                                                 Func0<T> trailerFactory,
                                                                                 Func2<T, String, T> trailerMutator,
                                                                                 Func1<String, Boolean> flushSelector);

        /**
         * On subscription of the returned {@link Observable}, writes the passed message stream on the underneath channel
         * and flushes the channel, everytime, {@code flushSelector} returns {@code true} . Any writes issued before
         * subscribing, will also be flushed. However, the returned {@link Observable} will not capture the result of those
         * writes, i.e. if the other writes, fail and this write does not, the returned {@link Observable} will not fail.
         *
         * @param msgs Message stream to write.
         * @param flushSelector A {@link Func1} which is invoked for every item emitted from {@code msgs}.
         * Channel is flushed, iff this function returns, {@code true}.
         *
         * @return An {@link Observable} representing the result of this and all writes done prior to the flush. Every
         * subscription to this {@link Observable} will write the passed messages and flush all pending writes, when the
         * {@code flushSelector} returns {@code true}
         */
        public abstract ContentWriter<C> writeString(Observable<String> msgs, Func1<String, Boolean> flushSelector);

        /**
         * On subscription of the returned {@link Observable}, writes the passed message stream on the underneath channel
         * and flushes the channel, on every write. Any writes issued before subscribing, will also be flushed. However, the
         * returned {@link Observable} will not capture the result of those writes, i.e. if the other writes, fail and this
         * write does not, the returned {@link Observable} will not fail.
         *
         * @param msgs Message stream to write.
         *
         * @return An {@link Observable} representing the result of this and all writes done prior to the flush. Every
         * subscription to this {@link Observable} will write the passed messages and flush all pending writes, on every
         * write.
         */
        public abstract ContentWriter<C> writeStringAndFlushOnEach(Observable<String> msgs);

        /**
         * On subscription of the returned {@link Observable}, writes the passed message stream on the underneath channel.
         *
         * <h2>Flush</h2>
         *
         * The writes are flushed when the passed stream completes.
         *
         * @param msgs Stream of messages to write.
         *
         * @return {@link Observable} representing the result of this write. Every subscription to this {@link Observable}
         * will replay the write on the channel.
         */
        public abstract ContentWriter<C> writeBytes(Observable<byte[]> msgs);

        /**
         * Uses the passed {@link Observable} as the source of content for this request. This method provides a way to
         * write trailing headers.
         *
         * A new instance of {@link TrailingHeaders} will be created using the passed {@code trailerFactory} and the passed
         * {@code trailerMutator} will be invoked for every item emitted from the content source, giving a chance to modify
         * the trailing headers instance.
         *
         * <h2>Multiple invocations</h2>
         *
         * This method can <em>not</em> be invoked multiple times for the same response as on completion of the passed
         * source, it writes the trailing headers and trailing headers can only be written once for an HTTP response.
         * So, any subsequent invocation of this method will always emit an error when subscribed.
         *
         * <h2>Flush</h2>
         *
         * The writes are flushed when the passed stream completes.
         *
         * @param contentSource Content source for the response.
         * @param trailerFactory A factory function to create a new {@link TrailingHeaders} per subscription of the content.
         * @param trailerMutator A function to mutate the trailing header on each item emitted from the content source.
         *
         * @return An new instance of {@link Observable} which can be subscribed to execute the request.
         */
        public abstract <T extends TrailingHeaders> Observable<Void> writeBytes(Observable<byte[]> contentSource,
                                                                                Func0<T> trailerFactory,
                                                                                Func2<T, byte[], T> trailerMutator);

        /**
         * Uses the passed {@link Observable} as the source of content for this request. This method provides a way to
         * write trailing headers.
         *
         * A new instance of {@link TrailingHeaders} will be created using the passed {@code trailerFactory} and the passed
         * {@code trailerMutator} will be invoked for every item emitted from the content source, giving a chance to modify
         * the trailing headers instance.
         *
         * <h2>Multiple invocations</h2>
         *
         * This method can <em>not</em> be invoked multiple times for the same response as on completion of the passed
         * source, it writes the trailing headers and trailing headers can only be written once for an HTTP response.
         * So, any subsequent invocation of this method will always emit an error when subscribed.
         *
         * @param contentSource Content source for the response.
         * @param trailerFactory A factory function to create a new {@link TrailingHeaders} per subscription of the content.
         * @param trailerMutator A function to mutate the trailing header on each item emitted from the content source.
         * @param flushSelector A {@link Func1} which is invoked for every item emitted from {@code msgs}. Channel is
         * flushed, iff this function returns, {@code true}.
         *
         * @return An new instance of {@link Observable} which can be subscribed to execute the request.
         */
        public abstract <T extends TrailingHeaders> Observable<Void> writeBytes(Observable<byte[]> contentSource,
                                                                                Func0<T> trailerFactory,
                                                                                Func2<T, byte[], T> trailerMutator,
                                                                                Func1<byte[], Boolean> flushSelector);

        /**
         * On subscription of the returned {@link Observable}, writes the passed message stream on the underneath channel
         * and flushes the channel, everytime, {@code flushSelector} returns {@code true} . Any writes issued before
         * subscribing, will also be flushed. However, the returned {@link Observable} will not capture the result of those
         * writes, i.e. if the other writes, fail and this write does not, the returned {@link Observable} will not fail.
         *
         * @param msgs Message stream to write.
         * @param flushSelector A {@link Func1} which is invoked for every item emitted from {@code msgs}.
         * Channel is flushed, iff this function returns, {@code true}.
         *
         * @return An {@link Observable} representing the result of this and all writes done prior to the flush. Every
         * subscription to this {@link Observable} will write the passed messages and flush all pending writes, when the
         * {@code flushSelector} returns {@code true}
         */
        public abstract ContentWriter<C> writeBytes(Observable<byte[]> msgs, Func1<byte[], Boolean> flushSelector);

        /**
         * On subscription of the returned {@link Observable}, writes the passed message stream on the underneath channel
         * and flushes the channel, on every write. Any writes issued before subscribing, will also be flushed. However, the
         * returned {@link Observable} will not capture the result of those writes, i.e. if the other writes, fail and this
         * write does not, the returned {@link Observable} will not fail.
         *
         * @param msgs Message stream to write.
         *
         * @return An {@link Observable} representing the result of this and all writes done prior to the flush. Every
         * subscription to this {@link Observable} will write the passed messages and flush all pending writes, on every
         * write.
         */
        public abstract ContentWriter<C> writeBytesAndFlushOnEach(Observable<byte[]> msgs);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServerRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.handler.codec.http.Cookie;
import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpMessage;
import io.netty.handler.codec.http.HttpMethod;
import io.netty.handler.codec.http.HttpVersion;
import rx.Observable;
import rx.Subscriber;

import java.text.ParseException;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 * HTTP server request
 *
 * <h2>Thread safety</h2>
 *
 * This object is not thread-safe and must not be used by multiple threads.
 *
 * <h2>Mutability</h2>
 *
 * Headers and trailing headers can be mutated for this response.
 *
 * <h2>Content consumption</h2>
 *
 * Unless the channel is set to auto-read, it is required for a {@link RequestHandler} to either subscribe to
 * {@link #getContent()} or {@link #discardContent()} after receiving this request. Failure to do so would mean
 * that no further data will be read from the connection and hence no futher requests on the same connection would be
 * passed to the {@link RequestHandler}
 */
public abstract class HttpServerRequest<T> {

    /**
     * Returns the HTTP method for this request.
     *
     * @return The HTTP method for this request.
     */
    public abstract HttpMethod getHttpMethod();

    /**
     * Returns the HTTP version for this request.
     *
     * @return The HTTP version for this request.
     */
    public abstract HttpVersion getHttpVersion();

    /**
     * Returns the raw URI for the request, including path and query parameters. The URI is not decoded.
     *
     * @return The raw URI for the request.
     */
    public abstract String getUri();

    /**
     * Returns the decoded URI path for this request.
     *
     * @return The decoded URI path for this request.
     */
    public abstract String getDecodedPath();

    /**
     * Returns an immutable map of cookie names and cookies contained in this request.
     *
     * @return An immutable map of cookie names and cookies contained in this request.
     */
    public abstract Map<String, Set<Cookie>> getCookies();

    /**
     * Returns an immutable map of query parameter names and values contained in this request. The names and values for
     * the query parameters will be decoded.
     *
     * @return An immutable map of query parameter names and values contained in this request.
     */
    public abstract Map<String, List<String>> getQueryParameters();

    /**
     * Checks if there is a header with the passed name in this request.
     *
     * @param name Name of the header.
     *
     * @return {@code true} if there is a header with the passed name in this request.
     */
    public abstract boolean containsHeader(CharSequence name);

    /**
     * Checks if there is a header with the passed name and value in this request.
     *
     * @param name Name of the header.
     * @param value Value of the header.
     * @param ignoreCaseValue {@code true} then the value comparision is done ignoring case.
     *
     * @return {@code true} if there is a header with the passed name and value in this request.
     */
    public abstract boolean containsHeader(CharSequence name, CharSequence value, boolean ignoreCaseValue);

    /**
     * Returns an iterator over the header entries. Multiple values for the same header appear as separate entries in
     * the returned iterator.
     *
     * @return An iterator over the header entries
     */
    public abstract Iterator<Entry<String, String>> headerIterator();

    /**
     * Returns the value of a header with the specified name.  If there are more than one values for the specified name,
     * the first value is returned.
     *
     * @param name The name of the header to search
     * @return The first header value or {@code null} if there is no such header
     */
    public abstract String getHeader(CharSequence name);

    /**
     * Returns the value of a header with the specified name.  If there are more than one values for the specified name,
     * the first value is returned.
     *
     * @param name The name of the header to search
     * @param defaultValue Default if the header does not exist.
     *
     * @return The first header value or {@code defaultValue} if there is no such header
     */
    public abstract String getHeader(CharSequence name, String defaultValue);

    /**
     * Returns the values of headers with the specified name
     *
     * @param name The name of the headers to search
     *
     * @return A {@link java.util.List} of header values which will be empty if no values are found
     */
    public abstract List<String> getAllHeaderValues(CharSequence name);

    /**
     * Returns the length of the content.
     *
     * @return the content length
     *
     * @throws NumberFormatException if the message does not have the {@code "Content-Length"} header or its value is
     * not a number.
     */
    public abstract long getContentLength();

    /**
     * Returns the length of the content.
     *
     * @param defaultValue Default value if the message does not have a {@code "Content-Length"} header or its value is
     * not a number
     *
     * @return the content length or {@code defaultValue} if this message does not have the {@code "Content-Length"}
     * header or its value is not a number
     */
    public abstract long getContentLength(long defaultValue);

    /**
     * Returns the date header value with the specified header name.  If there are more than one header value for the
     * specified header name, the first value is returned.
     * The value is parsed as per the
     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> using the format:
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name The name of the header to search
     *
     * @return the header value
     *
     * @throws java.text.ParseException if there is no such header or the header value is not a formatted date
     */
    public abstract Date getDateHeader(CharSequence name) throws ParseException;

    /**
     * Returns the date header value with the specified header name.  If there are more than one header value for the
     * specified header name, the first value is returned.
     * The value is parsed as per the
     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> using the format:
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name The name of the header to search
     * @param defaultValue Default value if there is no header with this name.
     *
     * @return the header value or {@code defaultValue} if there is no header with this name.
     */
    public abstract Date getDateHeader(CharSequence name, Date defaultValue);

    /**
     * Returns the value of the {@code "Host"} header.
     */
    public abstract String getHostHeader();

    /**
     * Returns the value of the {@code "Host"} header.
     *
     * @param defaultValue Default if the header does not exist.
     *
     * @return The value of the {@code "Host"} header or {@code defaultValue} if there is no such header.
     */
    public abstract String getHostHeader(String defaultValue);

    /**
     * Returns the integer header value with the specified header name.  If there are more than one header value for
     * the specified header name, the first value is returned.
     *
     * @param name The name of the header to search
     *
     * @return the header value
     *
     * @throws NumberFormatException if there is no such header or the header value is not a number
     */
    public abstract int getIntHeader(CharSequence name);

    /**
     * Returns the integer header value with the specified header name.  If there are more than one header value for
     * the specified header name, the first value is returned.
     *
     * @param name The name of the header to search
     * @param defaultValue Default if the header does not exist.
     *
     * @return the header value or the {@code defaultValue} if there is no such header or the header value is not a
     * number
     */
    public abstract int getIntHeader(CharSequence name, int defaultValue);

    /**
     * Returns {@code true} if and only if this request contains the {@code "Expect: 100-continue"} header.
     */
    public abstract boolean is100ContinueExpected();

    /**
     * Returns {@code true} if and only if this request has the content-length header set.
     */
    public abstract boolean isContentLengthSet();

    /**
     * Returns {@code true} if and only if the connection can remain open and thus 'kept alive'.  This methods respects
     * the value of the {@code "Connection"} header first and then the return value of
     * {@link HttpVersion#isKeepAliveDefault()}.
     */
    public abstract boolean isKeepAlive();

    /**
     * Checks to see if the transfer encoding of this request is chunked
     *
     * @return True if transfer encoding is chunked, otherwise false
     */
    public abstract boolean isTransferEncodingChunked();

    /**
     * Returns a new {@link Set} that contains the names of all headers in this request.  Note that modifying the
     * returned {@link Set} will not affect the state of this request.
     */
    public abstract Set<String> getHeaderNames();

    /**
     * Adds an HTTP header with the passed {@code name} and {@code value} to this request.
     *
     * @param name Name of the header.
     * @param value Value for the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerRequest<T> addHeader(CharSequence name, Object value);

    /**
     * Adds the passed {@code cookie} to this request.
     *
     * @param cookie Cookie to add.
     *
     * @return {@code this}
     */
    public abstract HttpServerRequest<T> addCookie(Cookie cookie);

    /**
     * Adds the passed header as a date value to this request. The date is formatted using netty's
     * {@link HttpHeaders#addDateHeader(HttpMessage, CharSequence, Date)} which formats the date as per the
     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> into the format:
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name Name of the header.
     * @param value Value of the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerRequest<T> addDateHeader(CharSequence name, Date value);

    /**
     * Adds multiple date values for the passed header name to this request. The date values are formatted using netty's
     * {@link HttpHeaders#addDateHeader(HttpMessage, CharSequence, Date)} which formats the date as per the
     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> into the format:
     *
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name Name of the header.
     * @param values Values for the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerRequest<T> addDateHeader(CharSequence name, Iterable<Date> values);

    /**
     * Adds an HTTP header with the passed {@code name} and {@code values} to this request.
     *
     * @param name Name of the header.
     * @param values Values for the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerRequest<T> addHeader(CharSequence name, Iterable<Object> values);

    /**
     * Overwrites the current value, if any, of the passed header to the passed date value for this request. The date is
     * formatted using netty's {@link HttpHeaders#addDateHeader(HttpMessage, CharSequence, Date)} which formats the date
     * as per the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> into
     * the format:
     * <p/>
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name Name of the header.
     * @param value Value of the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerRequest<T> setDateHeader(CharSequence name, Date value);

    /**
     * Overwrites the current value, if any, of the passed header to the passed value for this request.
     *
     * @param name Name of the header.
     * @param value Value of the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerRequest<T> setHeader(CharSequence name, Object value);

    /**
     * Overwrites the current value, if any, of the passed header to the passed date values for this request. The date
     * is formatted using netty's {@link HttpHeaders#addDateHeader(HttpMessage, CharSequence, Date)} which formats the
     * date as per the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a>
     * into the format:
     * <p/>
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name Name of the header.
     * @param values Values of the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerRequest<T> setDateHeader(CharSequence name, Iterable<Date> values);

    /**
     * Overwrites the current value, if any, of the passed header to the passed values for this request.
     *
     * @param name Name of the header.
     * @param values Values of the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerRequest<T> setHeader(CharSequence name, Iterable<Object> values);

    /**
     * Removes the passed header from this request.
     *
     * @param name Name of the header.
     *
     * @return {@code this}
     */
    public abstract HttpServerRequest<T> removeHeader(CharSequence name);

    /**
     * Returns the content as a stream. There can only be one {@link Subscriber} to the returned {@link Observable}, any
     * subsequent subscriptions will get an error.
     *
     * Unless the channel is set to auto-read, a {@link RequestHandler} processing a request <em>must</em> make sure
     * that it either discards or subscribes to the content. Failure to do so, will stall the connection and no other
     * requests will arrive on that connection as nothing is read from the connection.
     *
     * @return Stream of content.
     */
    public abstract Observable<T> getContent();

    /**
     * Subscribes to the content and discards.
     *
     * Unless the channel is set to auto-read, aA {@link RequestHandler} processing a request <em>must</em> make sure
     * that it either discards or subscribes to the content. Failure to do so, will stall the connection and no other
     * requests will arrive on that connection as nothing is read from the connection.
     *
     * @return An {@link Observable}, subscription to which will discard the content.
     */
    public abstract Observable<Void> discardContent();

    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append(getHttpMethod())
               .append(' ')
               .append(getUri())
               .append(' ')
               .append(getHttpVersion().text())
               .append('\n');

        Iterator<Entry<String, String>> headers = headerIterator();
        while (headers.hasNext()) {
            Entry<String, String> next = headers.next();
            builder.append(next.getKey())
                   .append(": ")
                   .append(next.getValue())
                   .append('\n');
        }
        builder.append('\n');

        return builder.toString();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServer.java;<<<<<<< MINE
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.ServerChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.util.concurrent.EventExecutorGroup;
import io.reactivex.netty.metrics.MetricEventsPublisher;
import io.reactivex.netty.pipeline.ssl.SSLEngineFactory;
import io.reactivex.netty.protocol.http.server.HttpServerMetricsEvent;
import io.reactivex.netty.protocol.tcp.server.TcpServer;
import rx.functions.Action1;
import rx.functions.Func0;

import java.util.concurrent.TimeUnit;

/**
 * An HTTP server.
 *
 * @param <I> The type of objects received as content from a request in this server.
 * @param <O> The type of objects written as content from a response in this server.
 */
public abstract class HttpServer<I, O> implements MetricEventsPublisher<HttpServerMetricsEvent<?>> {

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the server socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> channelOption(ChannelOption<T> option, T value);

    /**
     * Creates a new server instance, inheriting all configurations from this server and adding a {@link ChannelOption}
     * for the client socket created by the newly created server instance.
     *
     * @param option Option to add.
     * @param value Value for the option.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <T> HttpServer<I, O> clientChannelOption(ChannelOption<T> option, T value);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this
     * server. The specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the first position of the pipeline as specified by {@link
     * ChannelPipeline#addFirst(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group The {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name The name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerFirst(EventExecutorGroup group, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by
     * {@link ChannelPipeline#addLast(String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added at the last position of the pipeline as specified by {@link
     * ChannelPipeline#addLast(EventExecutorGroup, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerLast(EventExecutorGroup group, String name,
                                                                      Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(String baseName, String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added before an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addBefore(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerBefore(EventExecutorGroup group, String baseName,
                                                                        String name,
                                                                        Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param baseName the name of the existing handler
     * @param name Name of the handler.
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(String baseName, String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Adds a {@link ChannelHandler} to {@link ChannelPipeline} for all connections created by this server. The
     * specified handler is added after an existing handler with the passed {@code baseName} in the pipeline as
     * specified by {@link ChannelPipeline#addAfter(EventExecutorGroup, String, String, ChannelHandler)}
     * <p/>
     * <em>For better flexibility of pipeline modification, the method {@link #pipelineConfigurator(Action1)} will be
     * more convenient.</em>
     *
     * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler} methods
     * @param baseName the name of the existing handler
     * @param name the name of the handler to append
     * @param handlerFactory Factory to create handler instance to add.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> addChannelHandlerAfter(EventExecutorGroup group, String baseName,
                                                                       String name,
                                                                       Func0<ChannelHandler> handlerFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed action to
     * configure all the connections created by the newly created client instance.
     *
     * @param pipelineConfigurator Action to configure {@link ChannelPipeline}.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract <II, OO> HttpServer<II, OO> pipelineConfigurator(Action1<ChannelPipeline> pipelineConfigurator);

    /**
     * Creates a new client instances, inheriting all configurations from this client and using the passed {@code
     * sslEngineFactory} for all secured connections created by the newly created client instance.
     *
     * @param sslEngineFactory {@link io.reactivex.netty.pipeline.ssl.SSLEngineFactory} for all secured connections
     * created by the newly created client instance.
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> sslEngineFactory(SSLEngineFactory sslEngineFactory);

    /**
     * Creates a new client instances, inheriting all configurations from this client and enabling wire logging at the
     * passed level for the newly created client instance.
     *
     * @param wireLoggingLevel Logging level at which the wire logs will be logged. The wire logging will only be done
     * if logging is enabled at this level for {@link io.netty.handler.logging.LoggingHandler}
     *
     * @return A new {@link HttpServer} instance.
     */
    public abstract HttpServer<I, O> enableWireLogging(LogLevel wireLoggingLevel);

    /**
     * Returns the port at which this server is running.
     * <p/>
     * For servers using ephemeral ports, this would return the actual port used, only after the server is started.
     *
     * @return The port at which this server is running.
     */
    public abstract int getServerPort();

    /**
     * Starts this server and waits till the server is shutdown. This will block the caller thread till the time the
     * server is shutdown. If blocking the caller is not required, use {@link #start(RequestHandler)}
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     */
    public abstract void startAndWait(RequestHandler<I, O> requestHandler);

    /**
     * Starts this server.
     *
     * @param requestHandler Connection handler that will handle any new client connections to this server.
     *
     * @return This server.
     */
    public abstract HttpServer<I, O> start(RequestHandler<I, O> requestHandler);

    /**
     * Shutdown this server and waits till the server socket is closed.
     */
    public abstract void shutdown();

    /**
     * Waits for the shutdown of this server.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     */
    public abstract void waitTillShutdown();

    /**
     * Waits for the shutdown of this server, waiting a maximum of the passed duration.
     * <p/>
     * <b>This does not actually shutdown the server.</b> It just waits for some other action to shutdown.
     *
     * @param duration Duration to wait for shutdown.
     * @param timeUnit Timeunit for the duration to wait for shutdown.
     */
    public abstract void waitTillShutdown(long duration, TimeUnit timeUnit);

    /**
     * Creates a new server using an ephemeral port. The port used can be found by {@link #getServerPort()}
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer() {
        return _newServer(TcpServer.newServer(0));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port) {
        return _newServer(TcpServer.newServer(port));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param eventLoopGroup Eventloop group to be used for server as well as client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup eventLoopGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, eventLoopGroup, eventLoopGroup, channelClass));
    }

    /**
     * Creates a new server using the passed port.
     *
     * @param port Port for the server. {@code 0} to use ephemeral port.
     * @param serverGroup Eventloop group to be used for server sockets.
     * @param clientGroup Eventloop group to be used for client sockets.
     * @param channelClass The class to be used for server channel.
     *
     * @return A new {@link HttpServer}
     */
    public static HttpServer<ByteBuf, ByteBuf> newServer(int port, EventLoopGroup serverGroup,
                                                         EventLoopGroup clientGroup,
                                                         Class<? extends ServerChannel> channelClass) {
        return _newServer(TcpServer.newServer(port, serverGroup, clientGroup, channelClass));
    }

    private static HttpServer<ByteBuf, ByteBuf> _newServer(TcpServer<ByteBuf, ByteBuf> tcpServer) {
        return HttpServerImpl.create(tcpServer);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/RequestHandler.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import rx.Observable;

/**
 * A handler for an {@link HttpServerRequest} to produce a {@link HttpServerResponse}
 *
 * @param <I> The type of objects received as content from the request.
 * @param <O> The type of objects written as content from the response.
 */
public interface RequestHandler<I, O> {

    /**
     * Provides a request and response pair to process.
     *
     * @param request Http request to process.
     * @param response Http response to populate after processing the request.
     *
     * @return An {@link Observable} that represents the processing of the request. Subscribing to this should start
     * the request processing and unsubscribing should cancel the processing.
     */
    Observable<Void> handle(HttpServerRequest<I> request, HttpServerResponse<O> response);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/protocol/http/serverNew/HttpServerRequestImpl.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.serverNew;

import io.netty.channel.Channel;
import io.netty.handler.codec.http.ClientCookieEncoder;
import io.netty.handler.codec.http.Cookie;
import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpHeaders.Names;
import io.netty.handler.codec.http.HttpMethod;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpVersion;
import io.reactivex.netty.protocol.http.CookiesHolder;
import io.reactivex.netty.protocol.http.internal.HttpContentSubscriberEvent;
import io.reactivex.netty.protocol.http.server.UriInfoHolder;
import rx.Observable;
import rx.Observable.OnSubscribe;
import rx.Subscriber;

import java.text.ParseException;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class HttpServerRequestImpl<T> extends HttpServerRequest<T> {

    private final Channel nettyChannel;
    private final HttpRequest nettyRequest;
    private final CookiesHolder cookiesHolder;
    private final UriInfoHolder uriInfoHolder;

    public HttpServerRequestImpl(HttpRequest nettyRequest, Channel nettyChannel) {
        this.nettyRequest = nettyRequest;
        this.nettyChannel = nettyChannel;
        uriInfoHolder = new UriInfoHolder(this.nettyRequest.uri());
        cookiesHolder = CookiesHolder.newServerRequestHolder(nettyRequest.headers());
    }

    @Override
    public HttpMethod getHttpMethod() {
        return nettyRequest.method();
    }

    @Override
    public HttpVersion getHttpVersion() {
        return nettyRequest.protocolVersion();
    }

    @Override
    public String getUri() {
        return uriInfoHolder.getRawUriString();
    }

    @Override
    public String getDecodedPath() {
        return uriInfoHolder.getPath();
    }

    @Override
    public Map<String, Set<Cookie>> getCookies() {
        return cookiesHolder.getAllCookies();
    }

    @Override
    public Map<String, List<String>> getQueryParameters() {
        return uriInfoHolder.getQueryParameters();
    }

    @Override
    public boolean containsHeader(CharSequence name) {
        return nettyRequest.headers().contains(name);
    }

    @Override
    public boolean containsHeader(CharSequence name, CharSequence value, boolean ignoreCaseValue) {
        return nettyRequest.headers().contains(name, value, ignoreCaseValue);
    }

    @Override
    public Iterator<Entry<String, String>> headerIterator() {
        return nettyRequest.headers().iterator();
    }

    @Override
    public String getHeader(CharSequence name) {
        return nettyRequest.headers().get(name);
    }

    @Override
    public String getHeader(CharSequence name, String defaultValue) {
        return HttpHeaders.getHeader(nettyRequest, name, defaultValue);
    }

    @Override
    public List<String> getAllHeaderValues(CharSequence name) {
        return nettyRequest.headers().getAll(name);
    }

    @Override
    public long getContentLength() {
        return HttpHeaders.getContentLength(nettyRequest);
    }

    @Override
    public long getContentLength(long defaultValue) {
        return HttpHeaders.getContentLength(nettyRequest, defaultValue);
    }

    @Override
    public Date getDateHeader(CharSequence name) throws ParseException {
        return HttpHeaders.getDateHeader(nettyRequest, name);
    }

    @Override
    public Date getDateHeader(CharSequence name, Date defaultValue) {
        return HttpHeaders.getDateHeader(nettyRequest, name, defaultValue);
    }

    @Override
    public String getHostHeader() {
        return HttpHeaders.getHost(nettyRequest);
    }

    @Override
    public String getHostHeader(String defaultValue) {
        return HttpHeaders.getHost(nettyRequest, defaultValue);
    }

    @Override
    public int getIntHeader(CharSequence name) {
        return HttpHeaders.getIntHeader(nettyRequest, name);
    }

    @Override
    public int getIntHeader(CharSequence name, int defaultValue) {
        return HttpHeaders.getIntHeader(nettyRequest, name, defaultValue);
    }

    @Override
    public boolean is100ContinueExpected() {
        return HttpHeaders.is100ContinueExpected(nettyRequest);
    }

    @Override
    public boolean isContentLengthSet() {
        return HttpHeaders.isContentLengthSet(nettyRequest);
    }

    @Override
    public boolean isKeepAlive() {
        return HttpHeaders.isKeepAlive(nettyRequest);
    }

    @Override
    public boolean isTransferEncodingChunked() {
        return HttpHeaders.isTransferEncodingChunked(nettyRequest);
    }

    @Override
    public Set<String> getHeaderNames() {
        return nettyRequest.headers().names();
    }

    @Override
    public HttpServerRequest<T> addHeader(CharSequence name, Object value) {
        nettyRequest.headers().add(name, value);
        return this;
    }

    @Override
    public HttpServerRequest<T> addCookie(Cookie cookie) {
        nettyRequest.headers().add(Names.COOKIE,
                                   ClientCookieEncoder.encode(cookie) /*Since this is a request object, cookies are
                                   as if coming from a client*/);
        return this;

    }

    @Override
    public HttpServerRequest<T> addDateHeader(CharSequence name, Date value) {
        HttpHeaders.addDateHeader(nettyRequest, name, value);
        return this;
    }

    @Override
    public HttpServerRequest<T> addDateHeader(CharSequence name, Iterable<Date> values) {
        for (Date value : values) {
            HttpHeaders.addDateHeader(nettyRequest, name, value);
        }
        return this;
    }

    @Override
    public HttpServerRequest<T> addHeader(CharSequence name, Iterable<Object> values) {
        nettyRequest.headers().add(name, values);
        return this;
    }

    @Override
    public HttpServerRequest<T> setDateHeader(CharSequence name, Date value) {
        HttpHeaders.setDateHeader(nettyRequest, name, value);
        return this;
    }

    @Override
    public HttpServerRequest<T> setHeader(CharSequence name, Object value) {
        nettyRequest.headers().set(name, value);
        return this;
    }

    @Override
    public HttpServerRequest<T> setDateHeader(CharSequence name, Iterable<Date> values) {
        for (Date value : values) {
            HttpHeaders.setDateHeader(nettyRequest, name, value);
        }
        return this;
    }

    @Override
    public HttpServerRequest<T> setHeader(CharSequence name, Iterable<Object> values) {
        nettyRequest.headers().add(name, values);
        return this;
    }

    @Override
    public HttpServerRequest<T> removeHeader(CharSequence name) {
        nettyRequest.headers().remove(name);
        return this;
    }

    @Override
    public Observable<T> getContent() {
        return Observable.create(new OnSubscribe<T>() {
            @Override
            public void call(Subscriber<? super T> subscriber) {
                nettyChannel.pipeline()
                            .fireUserEventTriggered(new HttpContentSubscriberEvent<T>(subscriber));
            }
        });
    }

    @Override
    public Observable<Void> discardContent() {
        return Observable.create(new OnSubscribe<Void>() {
            @Override
            public void call(Subscriber<? super Void> subscriber) {
                nettyChannel.pipeline()
                            .fireUserEventTriggered(HttpContentSubscriberEvent.discardAllInput());
                subscriber.onCompleted();
            }
        });
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/protocol/http/TrailingHeaders.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http;

import io.netty.handler.codec.http.DefaultLastHttpContent;
import io.netty.handler.codec.http.LastHttpContent;

import java.util.List;

/**
 * A mutable stateful entity containing trailing headers.
 *
 * <b>This class is not thread safe</b>
 */
public class TrailingHeaders {

    private final LastHttpContent lastHttpContent;

    public TrailingHeaders() {
        lastHttpContent = new DefaultLastHttpContent();
    }

    public TrailingHeaders(LastHttpContent lastHttpContent) {
        this.lastHttpContent = lastHttpContent;
    }

    /**
     * Adds an HTTP trailing header with the passed {@code name} and {@code value} to this request.
     *
     * @param name Name of the header.
     * @param value Value for the header.
     *
     * @return {@code this}.
     */
    public TrailingHeaders addHeader(CharSequence name, Object value) {
        lastHttpContent.trailingHeaders().add(name, value);
        return this;
    }

    /**
     * Adds an HTTP trailing header with the passed {@code name} and {@code values} to this request.
     *
     * @param name Name of the header.
     * @param values Values for the header.
     *
     * @return {@code this}.
     */
    public TrailingHeaders addHeader(CharSequence name, Iterable<Object> values) {
        lastHttpContent.trailingHeaders().add(name, values);
        return this;
    }

    /**
     * Overwrites the current value, if any, of the passed trailing header to the passed value for this request.
     *
     * @param name Name of the header.
     * @param value Value of the header.
     *
     * @return {@code this}.
     */
    public TrailingHeaders setHeader(CharSequence name, Object value) {
        lastHttpContent.trailingHeaders().set(name, value);
        return this;
    }

    /**
     * Overwrites the current value, if any, of the passed trailing header to the passed values for this request.
     *
     * @param name Name of the header.
     * @param values Values of the header.
     *
     * @return {@code this}.
     */
    public TrailingHeaders setHeader(CharSequence name, Iterable<Object> values) {
        lastHttpContent.trailingHeaders().set(name, values);
        return this;
    }

    /**
     * Returns the value of a header with the specified name.  If there are more than one values for the specified name,
     * the first value is returned.
     *
     * @param name The name of the header to search
     *
     * @return The first header value or {@code null} if there is no such header
     */
    public String getHeader(CharSequence name) {
        return lastHttpContent.trailingHeaders().get(name);
    }

    /**
     * Returns the values of headers with the specified name
     *
     * @param name The name of the headers to search
     *
     * @return A {@link List} of header values which will be empty if no values are found
     */
    public List<String> getAllHeaderValues(CharSequence name) {
        return lastHttpContent.trailingHeaders().getAll(name);
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClient.java;<<<<<<< MINE
public abstract class HttpClient<I, O> {
=======
public abstract class HttpClient<I, O> implements MetricEventsPublisher<HttpClientMetricsEvent<?>> {

    public static final String HTTP_CLIENT_NO_NAME = "TcpClient-no-name";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClientResponse.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.reactivex.netty.protocol.http.clientNew;

import io.netty.handler.codec.http.Cookie;
import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpMessage;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http.HttpVersion;
import rx.Observable;
import rx.Subscriber;

import java.text.ParseException;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 * HTTP response for {@link HttpClient}
 *
 * <h2>Thread safety</h2>
 *
 * This object is not thread-safe and must not be used by multiple threads.
 *
 * <h2>Mutability</h2>
 *
 * Headers and trailing headers can be mutated for this response.
 */
public abstract class HttpClientResponse<T> {

    /**
     * Returns the HTTP version for this response.
     *
     * @return The HTTP version for this response.
     */
    public abstract HttpVersion getHttpVersion();

    /**
     * Returns the HTTP status for this response.
     *
     * @return The HTTP status for this response.
     */
    public abstract HttpResponseStatus getStatus();

    /**
     * Returns an immutable map of cookie names and cookies contained in this response.
     *
     * @return An immutable map of cookie names and cookies contained in this response.
     */
    public abstract Map<String, Set<Cookie>> getCookies();

    /**
     * Checks if there is a header with the passed name in this response.
     *
     * @param name Name of the header.
     *
     * @return {@code true} if there is a header with the passed name in this response.
     */
    public abstract boolean containsHeader(CharSequence name);

    /**
     * Checks if there is a header with the passed name and value in this response.
     *
     * @param name Name of the header.
     * @param value Value of the header.
     * @param ignoreCaseValue {@code true} then the value comparision is done ignoring case.
     *
     * @return {@code true} if there is a header with the passed name and value in this response.
     */
    public abstract boolean containsHeader(CharSequence name, CharSequence value, boolean ignoreCaseValue);

    /**
     * Returns an iterator over the header entries. Multiple values for the same header appear as separate entries in
     * the returned iterator.
     *
     * @return An iterator over the header entries
     */
    public abstract Iterator<Entry<String, String>> headerIterator();

    /**
     * Returns the value of a header with the specified name.  If there are more than one values for the specified name,
     * the first value is returned.
     *
     * @param name The name of the header to search
     * @return The first header value or {@code null} if there is no such header
     */
    public abstract String getHeader(CharSequence name);

    /**
     * Returns the value of a header with the specified name.  If there are more than one values for the specified name,
     * the first value is returned.
     *
     * @param name The name of the header to search
     * @param defaultValue Default if the header does not exist.
     *
     * @return The first header value or {@code defaultValue} if there is no such header
     */
    public abstract String getHeader(CharSequence name, String defaultValue);

    /**
     * Returns the values of headers with the specified name
     *
     * @param name The name of the headers to search
     *
     * @return A {@link List} of header values which will be empty if no values are found
     */
    public abstract List<String> getAllHeaderValues(CharSequence name);

    /**
     * Returns the length of the content.
     *
     * @return the content length
     *
     * @throws NumberFormatException if the message does not have the {@code "Content-Length"} header or its value is
     * not a number.
     */
    public abstract long getContentLength();

    /**
     * Returns the length of the content.
     *
     * @param defaultValue Default value if the message does not have a {@code "Content-Length"} header or its value is
     * not a number
     *
     * @return the content length or {@code defaultValue} if this message does not have the {@code "Content-Length"}
     * header or its value is not a number
     */
    public abstract long getContentLength(long defaultValue);

    /**
     * Returns the date header value with the specified header name.  If there are more than one header value for the
     * specified header name, the first value is returned.
     * The value is parsed as per the
     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> using the format:
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name The name of the header to search
     *
     * @return the header value
     *
     * @throws ParseException if there is no such header or the header value is not a formatted date
     */
    public abstract Date getDateHeader(CharSequence name) throws ParseException;

    /**
     * Returns the date header value with the specified header name.  If there are more than one header value for the
     * specified header name, the first value is returned.
     * The value is parsed as per the
     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> using the format:
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name The name of the header to search
     * @param defaultValue Default value if there is no header with this name.
     *
     * @return the header value or {@code defaultValue} if there is no header with this name.
     */
    public abstract Date getDateHeader(CharSequence name, Date defaultValue);

    /**
     * Returns the value of the {@code "Host"} header.
     */
    public abstract String getHostHeader();

    /**
     * Returns the value of the {@code "Host"} header.
     *
     * @param defaultValue Default if the header does not exist.
     *
     * @return The value of the {@code "Host"} header or {@code defaultValue} if there is no such header.
     */
    public abstract String getHost(String defaultValue);

    /**
     * Returns the integer header value with the specified header name.  If there are more than one header value for
     * the specified header name, the first value is returned.
     *
     * @param name The name of the header to search
     *
     * @return the header value
     *
     * @throws NumberFormatException if there is no such header or the header value is not a number
     */
    public abstract int getIntHeader(CharSequence name);

    /**
     * Returns the integer header value with the specified header name.  If there are more than one header value for
     * the specified header name, the first value is returned.
     *
     * @param name The name of the header to search
     * @param defaultValue Default if the header does not exist.
     *
     * @return the header value or the {@code defaultValue} if there is no such header or the header value is not a
     * number
     */
    public abstract int getIntHeader(CharSequence name, int defaultValue);

    /**
     * Returns {@code true} if and only if this response has the content-length header set.
     */
    public abstract boolean isContentLengthSet();

    /**
     * Returns {@code true} if and only if the connection can remain open and thus 'kept alive'.  This methods respects
     * the value of the {@code "Connection"} header first and then the return value of
     * {@link HttpVersion#isKeepAliveDefault()}.
     */
    public abstract boolean isKeepAlive();

    /**
     * Checks to see if the transfer encoding of this response is chunked
     *
     * @return True if transfer encoding is chunked, otherwise false
     */
    public abstract boolean isTransferEncodingChunked();

    /**
     * Returns a new {@link Set} that contains the names of all headers in this response.  Note that modifying the
     * returned {@link Set} will not affect the state of this response.
     */
    public abstract Set<String> getHeaderNames();

    /**
     * Adds an HTTP header with the passed {@code name} and {@code value} to this response.
     *
     * @param name Name of the header.
     * @param value Value for the header.
     *
     * @return {@code this}
     */
    public abstract HttpClientResponse<T> addHeader(CharSequence name, Object value);

    /**
     * Adds the passed {@code cookie} to this response.
     *
     * @param cookie Cookie to add.
     *
     * @return {@code this}
     */
    public abstract HttpClientResponse<T> addCookie(Cookie cookie);

    /**
     * Adds the passed header as a date value to this response. The date is formatted using netty's
     * {@link HttpHeaders#addDateHeader(HttpMessage, CharSequence, Date)} which formats the date as per the
     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> into the format:
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name Name of the header.
     * @param value Value of the header.
     *
     * @return {@code this}
     */
    public abstract HttpClientResponse<T> addDateHeader(CharSequence name, Date value);

    /**
     * Adds multiple date values for the passed header name to this response. The date values are formatted using netty's
     * {@link HttpHeaders#addDateHeader(HttpMessage, CharSequence, Date)} which formats the date as per the
     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> into the format:
     *
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name Name of the header.
     * @param values Values for the header.
     *
     * @return {@code this}
     */
    public abstract HttpClientResponse<T> addDateHeader(CharSequence name, Iterable<Date> values);

    /**
     * Adds an HTTP header with the passed {@code name} and {@code values} to this response.
     *
     * @param name Name of the header.
     * @param values Values for the header.
     *
     * @return {@code this}
     */
    public abstract HttpClientResponse<T> addHeader(CharSequence name, Iterable<Object> values);

    /**
     * Overwrites the current value, if any, of the passed header to the passed date value for this response. The date is
     * formatted using netty's {@link HttpHeaders#addDateHeader(HttpMessage, CharSequence, Date)} which formats the date
     * as per the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a> into
     * the format:
     * <p/>
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name Name of the header.
     * @param value Value of the header.
     *
     * @return {@code this}
     */
    public abstract HttpClientResponse<T> setDateHeader(CharSequence name, Date value);

    /**
     * Overwrites the current value, if any, of the passed header to the passed value for this response.
     *
     * @param name Name of the header.
     * @param value Value of the header.
     *
     * @return {@code this}
     */
    public abstract HttpClientResponse<T> setHeader(CharSequence name, Object value);

    /**
     * Overwrites the current value, if any, of the passed header to the passed date values for this response. The date
     * is formatted using netty's {@link HttpHeaders#addDateHeader(HttpMessage, CharSequence, Date)} which formats the
     * date as per the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">HTTP specifications</a>
     * into the format:
     * <p/>
     * <PRE>"E, dd MMM yyyy HH:mm:ss z"</PRE>
     *
     * @param name Name of the header.
     * @param values Values of the header.
     *
     * @return {@code this}
     */
    public abstract HttpClientResponse<T> setDateHeader(CharSequence name, Iterable<Date> values);

    /**
     * Overwrites the current value, if any, of the passed header to the passed values for this response.
     *
     * @param name Name of the header.
     * @param values Values of the header.
     *
     * @return {@code this}
     */
    public abstract HttpClientResponse<T> setHeader(CharSequence name, Iterable<Object> values);

    /**
     * Removes the passed header from this response.
     *
     * @param name Name of the header.
     *
     * @return {@code this}
     */
    public abstract HttpClientResponse<T> removeHeader(CharSequence name);

    /**
     * Returns the content as a stream. There can only be one {@link Subscriber} to the returned {@link Observable}, any
     * subsequent subscriptions will get an error.
     *
     * @return Stream of content.
     */
    public abstract Observable<T> getContent();

    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append(getHttpVersion().text())
               .append(' ')
               .append(getStatus().code())
               .append(' ')
               .append(getStatus().reasonPhrase())
               .append('\n');

        Iterator<Entry<String, String>> headers = headerIterator();
        while (headers.hasNext()) {
            Entry<String, String> next = headers.next();
            builder.append(next.getKey())
                   .append(": ")
                   .append(next.getValue());
        }
        builder.append('\n');

        return builder.toString();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClientRequest.java;<<<<<<< MINE
public abstract class HttpClientRequest<I, O> extends Observable<HttpClientResponse<O>>
        implements HttpClientRequestOperations<I, HttpClientRequest<I, O>> {
=======
public abstract class HttpClientRequest<I, O> extends Observable<HttpClientResponse<O>> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/protocol/http/clientNew/HttpClientResponseImpl.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.clientNew;

import io.netty.channel.Channel;
import io.netty.handler.codec.http.ClientCookieEncoder;
import io.netty.handler.codec.http.Cookie;
import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpResponse;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http.HttpVersion;
import io.reactivex.netty.protocol.http.CookiesHolder;
import io.reactivex.netty.protocol.http.internal.HttpContentSubscriberEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import rx.Observable;
import rx.Observable.OnSubscribe;
import rx.Subscriber;

import java.text.ParseException;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.regex.Pattern;

public final class HttpClientResponseImpl<T> extends HttpClientResponse<T> {

    private static final Logger logger = LoggerFactory.getLogger(HttpClientResponseImpl.class);

    public static final String KEEP_ALIVE_HEADER_NAME = "Keep-Alive";
    private static final Pattern PATTERN_COMMA = Pattern.compile(",");
    private static final Pattern PATTERN_EQUALS = Pattern.compile("=");
    public static final String KEEP_ALIVE_TIMEOUT_HEADER_ATTR = "timeout";

    private final HttpResponse nettyResponse;
    private final CookiesHolder cookiesHolder;
    private final Channel nettyChannel;

    protected HttpClientResponseImpl(HttpResponse nettyResponse, Channel nettyChannel) {
        this.nettyResponse = nettyResponse;
        this.nettyChannel = nettyChannel;
        cookiesHolder = CookiesHolder.newClientResponseHolder(nettyResponse.headers());
    }

    @Override
    public HttpVersion getHttpVersion() {
        return nettyResponse.protocolVersion();
    }

    @Override
    public HttpResponseStatus getStatus() {
        return nettyResponse.status();
    }

    @Override
    public Map<String, Set<Cookie>> getCookies() {
        return cookiesHolder.getAllCookies();
    }

    @Override
    public boolean containsHeader(CharSequence name) {
        return nettyResponse.headers().contains(name);
    }

    @Override
    public boolean containsHeader(CharSequence name, CharSequence value, boolean ignoreCaseValue) {
        return nettyResponse.headers().contains(name, value, ignoreCaseValue);
    }

    @Override
    public Iterator<Entry<String, String>> headerIterator() {
        return nettyResponse.headers().iterator();
    }

    @Override
    public String getHeader(CharSequence name) {
        return nettyResponse.headers().get(name);
    }

    @Override
    public String getHeader(CharSequence name, String defaultValue) {
        return HttpHeaders.getHeader(nettyResponse, name, defaultValue);
    }

    @Override
    public List<String> getAllHeaderValues(CharSequence name) {
        return nettyResponse.headers().getAll(name);
    }

    @Override
    public long getContentLength() {
        return HttpHeaders.getContentLength(nettyResponse);
    }

    @Override
    public long getContentLength(long defaultValue) {
        return HttpHeaders.getContentLength(nettyResponse, defaultValue);
    }

    @Override
    public Date getDateHeader(CharSequence name) throws ParseException {
        return HttpHeaders.getDateHeader(nettyResponse, name);
    }

    @Override
    public Date getDateHeader(CharSequence name, Date defaultValue) {
        return HttpHeaders.getDateHeader(nettyResponse, name, defaultValue);
    }

    @Override
    public String getHostHeader() {
        return HttpHeaders.getHost(nettyResponse);
    }

    @Override
    public String getHost(String defaultValue) {
        return HttpHeaders.getHost(nettyResponse, defaultValue);
    }

    @Override
    public int getIntHeader(CharSequence name) {
        return HttpHeaders.getIntHeader(nettyResponse, name);
    }

    @Override
    public int getIntHeader(CharSequence name, int defaultValue) {
        return HttpHeaders.getIntHeader(nettyResponse, name, defaultValue);
    }

    @Override
    public boolean isContentLengthSet() {
        return HttpHeaders.isContentLengthSet(nettyResponse);
    }

    @Override
    public boolean isKeepAlive() {
        return HttpHeaders.isKeepAlive(nettyResponse);
    }

    @Override
    public boolean isTransferEncodingChunked() {
        return HttpHeaders.isTransferEncodingChunked(nettyResponse);
    }

    @Override
    public Set<String> getHeaderNames() {
        return nettyResponse.headers().names();
    }

    @Override
    public HttpClientResponse<T> addHeader(CharSequence name, Object value) {
        nettyResponse.headers().add(name, value);
        return this;
    }

    @Override
    public HttpClientResponse<T> addCookie(Cookie cookie) {
        nettyResponse.headers().add(HttpHeaders.Names.SET_COOKIE, ClientCookieEncoder.encode(cookie));
        return this;
    }

    @Override
    public HttpClientResponse<T> addDateHeader(CharSequence name, Date value) {
        HttpHeaders.addDateHeader(nettyResponse, name, value);
        return this;
    }

    @Override
    public HttpClientResponse<T> addDateHeader(CharSequence name, Iterable<Date> values) {
        for (Date value : values) {
            HttpHeaders.addDateHeader(nettyResponse, name, value);
        }
        return this;
    }

    @Override
    public HttpClientResponse<T> addHeader(CharSequence name, Iterable<Object> values) {
        nettyResponse.headers().add(name, values);
        return this;
    }

    @Override
    public HttpClientResponse<T> setDateHeader(CharSequence name, Date value) {
        HttpHeaders.setDateHeader(nettyResponse, name, value);
        return this;
    }

    @Override
    public HttpClientResponse<T> setHeader(CharSequence name, Object value) {
        nettyResponse.headers().set(name, value);
        return this;
    }

    @Override
    public HttpClientResponse<T> setDateHeader(CharSequence name, Iterable<Date> values) {
        for (Date value : values) {
            HttpHeaders.setDateHeader(nettyResponse, name, value);
        }
        return this;
    }

    @Override
    public HttpClientResponse<T> setHeader(CharSequence name, Iterable<Object> values) {
        nettyResponse.headers().set(name, values);
        return this;
    }

    @Override
    public HttpClientResponse<T> removeHeader(CharSequence name) {
        nettyResponse.headers().remove(name);
        return this;
    }

    @Override
    public Observable<T> getContent() {
        return Observable.create(new OnSubscribe<T>() {
            @Override
            public void call(Subscriber<? super T> subscriber) {
                nettyChannel.pipeline()
                            .fireUserEventTriggered(new HttpContentSubscriberEvent<T>(subscriber));
            }
        });
    }

    /**
     * Parses the timeout value from the HTTP keep alive header (with name {@link #KEEP_ALIVE_HEADER_NAME}) as described in
     * <a href="http://tools.ietf.org/id/draft-thomson-hybi-http-timeout-01.html">this spec</a>
     *
     * @return The keep alive timeout or {@code null} if this response does not define the appropriate header value.
     */
    public Long getKeepAliveTimeoutSeconds() {
        String keepAliveHeader = nettyResponse.headers().get(KEEP_ALIVE_HEADER_NAME);
        if (null != keepAliveHeader && !keepAliveHeader.isEmpty()) {
            String[] pairs = PATTERN_COMMA.split(keepAliveHeader);
            if (pairs != null) {
                for (String pair: pairs) {
                    String[] nameValue = PATTERN_EQUALS.split(pair.trim());
                    if (nameValue != null && nameValue.length >= 2) {
                        String name = nameValue[0].trim().toLowerCase();
                        String value = nameValue[1].trim();
                        if (KEEP_ALIVE_TIMEOUT_HEADER_ATTR.equals(name)) {
                            try {
                                return Long.valueOf(value);
                            } catch (NumberFormatException e) {
                                logger.info("Invalid HTTP keep alive timeout value. Keep alive header: "
                                            + keepAliveHeader + ", timeout attribute value: " + nameValue[1], e);
                                return null;
                            }
                        }
                    }
                }
            }
        }
        return null;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/channel/FlushSelectorOperator.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.channel;

import io.netty.channel.Channel;
import rx.Observable.Operator;
import rx.Subscriber;
import rx.functions.Func1;

public class FlushSelectorOperator<T> implements Operator<T, T> {

    private final Func1<T, Boolean> flushSelector;
    private final Channel channel;

    public FlushSelectorOperator(Func1<T, Boolean> flushSelector, Channel channel) {
        this.flushSelector = flushSelector;
        this.channel = channel;
    }

    @Override
    public Subscriber<? super T> call(final Subscriber<? super T> subscriber) {

        return new Subscriber<T>(subscriber) {
            @Override
            public void onCompleted() {
                subscriber.onCompleted();
            }

            @Override
            public void onError(Throwable e) {
                subscriber.onError(e);
            }

            @Override
            public void onNext(T next) {
                subscriber.onNext(next);
                /*Call the selector _after_ writing an element*/
                if (flushSelector.call(next)) {
                    channel.flush();
                }
            }
        };
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/channel/CollaboratedReadInputSubscriber.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.channel;

import io.netty.channel.Channel;
import io.netty.channel.ChannelConfig;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandler;
import rx.Producer;
import rx.Subscriber;
import rx.annotations.Beta;
import rx.exceptions.MissingBackpressureException;
import rx.functions.Action0;
import rx.internal.operators.NotificationLite;
import rx.subscriptions.Subscriptions;

/**
 * A subscriber for {@link Connection} input.
 *
 * <h2> Thread safety </h2>
 *
 * This class assumes sequential invocation of:
 * <ul>
 <li>{@link #onCompleted()}</li>
 <li>{@link #onNext(Object)}</li>
 <li>{@link #onError(Throwable)}</li>
 </ul>
 *
 * The following methods can be called concurrently with any other method:
 * <ul>
 <li>{@link #unsubscribe()}</li>
 <li>{@link #request(long)}</li>
 </ul>
 *
 * <h2>Backpressure</h2>
 *
 * This subscriber is backpressure enabled and uses the following strategy:
 * <ul>
 <li>If the requested items from downstream are more than the items emitted, then invoke the original
 {@link Subscriber}</li>
 <li>If the requested items from downstream are less than the items emitted, then throw
 {@link MissingBackpressureException}.</li>
 <li>Whenever supply increases demand, turn off {@link ChannelConfig#isAutoRead()}.</li>
 <li>For every call to {@link Producer#request(long)} if the downstream subscriber requires more data and channel does
 not have {@link ChannelConfig#isAutoRead()} set to {@code true}, then trigger a {@link Channel#read()}</li>
 <li>The data producer of this subscriber (one calling {@link #onNext(Object)}) must make sure to call
 {@link Channel#read()} on receiving {@link ChannelInboundHandler#channelReadComplete(ChannelHandlerContext)} event and
 if {@link #shouldReadMore()} returns {@code true} </li>
 </ul>
 *
 * @author Nitesh Kant
 */
@Beta
public final class CollaboratedReadInputSubscriber<I> extends Subscriber<I> {

    private final Channel channel;

    /**
     * This is to protect agains duplicate terminal notifications, this will not necessarily mean original subsciber is
     * unsubscribed.
     */
    private boolean terminated;
    private final NotificationLite<I> nl = NotificationLite.instance();

    private volatile boolean draining; // Single threaded access

    private final Subscriber<? super I> original;
    private final Runnable fireDrainOnRequestMoreTask;


    private CollaboratedReadInputSubscriber(final Channel channel, Subscriber<? super I> op) {
        super(op);
        this.channel = channel;

        fireDrainOnRequestMoreTask = new Runnable() {
            @Override
            public void run() {
                /*
                 * The below code has to be run on the eventloop as there is a race between if(registered) and fire
                 * event. On unregistration, the pipeline is cleared and hence the event will never propagate to the
                 * handler.
                 */
                if (channel.isRegistered()) {
                    //channel.pipeline().fireUserEventTriggered(DrainInputSubscriberBuffer.INSTANCE);
                } else {
                    //drain();
                }

                /*
                 * Since, this operation has to be after the drain (to check if drain caused was sufficient for the
                 * subscriber), it is done in this task.
                 */
                if (!channel.config().isAutoRead() && shouldReadMore()) {
                    /*If the draining exhausted requested, then don't trigger read.*/
                    channel.read();
                }
            }
        };

        original = op;
        original.add(Subscriptions.create(new Action0() {
            @Override
            public void call() {
                /* When unsubscribed, drain the buffer to discard buffered items */
                channel.eventLoop().execute(fireDrainOnRequestMoreTask);
            }
        }));
    }

    @Override
    public void setProducer(Producer producer) {
        /*
         * Delegate all backpressure request logic to the actual subscriber.
         */
        original.setProducer(producer);
    }

    @Override
    public void onCompleted() {
        if (terminated) {
            return;
        }
        terminated = true;
        original.onCompleted();
    }

    @Override
    public void onError(Throwable e) {
        if (terminated) {
            return;
        }
        terminated = true;
        original.onError(e);
    }

    @Override
    public void onNext(I item) {
/*
        if (terminated) {
            ReferenceCountUtil.release(item); // discard item if no one is subscribed.
        } else if (requested > 0) {
            invokeOnNext(item);
        } else {
            if (channel.config().isAutoRead()) {
                */
/*
                 * If auto-read was on then turn it off on buffer start as there is no reason to read and buffer data.
                 * If, it is desired to not turn off auto-read then the downstream subscriber should request larger
                 * number of items.
                 *//*

                channel.config().setAutoRead(false);
            }
            original.onError(new MissingBackpressureException("Received more data on the channel than demanded by the subscriber."));
        }
*/
    }

    public static <I> CollaboratedReadInputSubscriber<I> create(final Channel channel, Subscriber<? super I> original) {
        final CollaboratedReadInputSubscriber<I> toReturn = new CollaboratedReadInputSubscriber<I>(channel, original);
        toReturn.setProducer(new CRIProducer<I>(toReturn));
        return toReturn;
    }

    public boolean shouldReadMore() {
        return !terminated /*&& REQUEST_UPDATER.get(this) > 0*/;
    }

    /*Visible for testing*/ long getRequested() {
        return 0;
    }

    private void invokeOnNext(I item) {
        original.onNext(item);
        /*if (REQUEST_UPDATER.get(this) != Long.MAX_VALUE) {
            REQUEST_UPDATER.decrementAndGet(this);
        }*/
    }

    private static class CRIProducer<T> implements Producer {

        private final CollaboratedReadInputSubscriber<T> cri;

        private CRIProducer(CollaboratedReadInputSubscriber<T> cri) {
            this.cri = cri;
        }

        @Override
        public void request(long n) {
/*
            if (Long.MAX_VALUE != cri.requested) {
                if (Long.MAX_VALUE == n) {
                    // Now turning off backpressure
                    REQUEST_UPDATER.set(cri, Long.MAX_VALUE);
                } else {
                    // add n to field but check for overflow
                    while (true) {
                        long current = REQUEST_UPDATER.get(cri);
                        long next = current + n;
                        // check for overflow
                        if (next < 0) {
                            next = Long.MAX_VALUE;
                        }
                        if (REQUEST_UPDATER.compareAndSet(cri, current, next)) {
                            break;
                        }
                    }
                }
            }

            */
/*
             * Executing on the eventloop as it needs to check whether the channel is registered or not,
             * which introduces a race-condition.
             *//*

            cri.channel.eventLoop().execute(cri.fireDrainOnRequestMoreTask);
*/
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_8530e8d_549e21f/rev_8530e8d-549e21f/rxnetty/src/main/java/io/reactivex/netty/channel/ClientConnectionToChannelBridge.java;<<<<<<< MINE
=======

    /**
     * An event to indicate release of a {@link PooledConnection}.
     */
    public static final class PooledConnectionReleaseEvent {

        public static final PooledConnectionReleaseEvent INSTANCE = new PooledConnectionReleaseEvent();

        private PooledConnectionReleaseEvent() {
        }
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_f7e49e7_153d71b/rev_f7e49e7-153d71b/rxnetty-examples/src/test/java/io/reactivex/netty/examples/tcp/streaming/StreamingTest.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.reactivex.netty.examples.tcp.streaming;

import org.junit.Test;

import java.util.Queue;

import static io.reactivex.netty.examples.ExamplesTestUtil.*;
import static org.hamcrest.MatcherAssert.*;
import static org.hamcrest.Matchers.*;

public class StreamingTest {

    @Test(timeout = 60000)
    public void testStreaming() throws Exception {
        final Queue<String> output = setupClientLogger(StreamingClient.class);

        StreamingClient.main(null);

        assertThat("Unexpected number of messages echoed", output, hasSize(10));

        String[] content = new String[10];
        for (int i = 0; i < 10; i++) {
            content[i] = "Interval =>" + i;
        }

        assertThat("Unexpected content", output, contains(content));
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_137dbfd_a5e8a92/rev_137dbfd-a5e8a92/rxnetty/src/main/java/io/reactivex/netty/protocol/http/client/internal/HttpClientToConnectionBridge.java;<<<<<<< MINE
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.netty.protocol.http.client.internal;

import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPromise;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpMessage;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpResponse;
import io.netty.handler.codec.http.LastHttpContent;
import io.netty.util.AttributeKey;
import io.reactivex.netty.events.Clock;
import io.reactivex.netty.events.EventPublisher;
import io.reactivex.netty.protocol.http.client.events.HttpClientEventsListener;
import io.reactivex.netty.protocol.http.internal.AbstractHttpConnectionBridge;
import io.reactivex.netty.protocol.tcp.client.ClientConnectionToChannelBridge;
import io.reactivex.netty.protocol.tcp.client.ClientConnectionToChannelBridge.ConnectionReuseEvent;
import io.reactivex.netty.protocol.tcp.client.ClientConnectionToChannelBridge.PooledConnectionReleaseEvent;
import io.reactivex.netty.protocol.tcp.client.internal.TcpEventPublisherFactory;
import rx.Subscriber;
import rx.functions.Action0;
import rx.subscriptions.Subscriptions;

import java.net.InetSocketAddress;
import java.net.SocketAddress;

import static java.util.concurrent.TimeUnit.*;

public class HttpClientToConnectionBridge<C> extends AbstractHttpConnectionBridge<C> {

    /**
     * This attribute stores the value of any dynamic idle timeout value sent via an HTTP keep alive header.
     * This follows the proposal specified here: http://tools.ietf.org/id/draft-thomson-hybi-http-timeout-01.html
     * The attribute can be extracted from an HTTP response header using the helper method
     * {@link HttpClientResponseImpl#getKeepAliveTimeoutSeconds()}
     */
    public static final AttributeKey<Long> KEEP_ALIVE_TIMEOUT_MILLIS_ATTR =
            AttributeKey.valueOf("rxnetty_http_conn_keep_alive_timeout_millis");

    private HttpClientEventsListener eventsListener;
    private EventPublisher eventPublisher;
    private String hostHeader;
    private long requestWriteCompletionTimeNanos;

    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        eventsListener = ctx.channel().attr(HttpEventPublisherFactory.HTTP_CLIENT_EVENT_LISTENER).get();
        eventPublisher = ctx.channel().attr(TcpEventPublisherFactory.EVENT_PUBLISHER).get();
        super.handlerAdded(ctx);
    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        SocketAddress remoteAddr = ctx.channel().remoteAddress();
        if (remoteAddr instanceof InetSocketAddress) {
            InetSocketAddress inetSock = (InetSocketAddress) remoteAddr;
            String hostString = inetSock.getHostString(); // Don't use hostname that does a DNS lookup.
            hostHeader = hostString + ':' + inetSock.getPort();
        }
        super.channelActive(ctx);
    }

    @Override
    protected void beforeOutboundHeaderWrite(HttpMessage httpMsg, ChannelPromise promise, long startTimeNanos) {
        /*Reset on every request write, we do not currently support pipelining, otherwise, this should be stored in a
        queue.*/
        requestWriteCompletionTimeNanos = -1;
        if (null != hostHeader) {
            if (!httpMsg.headers().contains(HttpHeaderNames.HOST)) {
                httpMsg.headers().set(HttpHeaderNames.HOST, hostHeader);
            }
        }
        if (eventPublisher.publishingEnabled()) {
            eventsListener.onRequestWriteStart();
        }
    }

    @Override
    protected void onOutboundLastContentWrite(LastHttpContent msg, ChannelPromise promise,
                                              final long headerWriteStartTimeNanos) {
        if (eventPublisher.publishingEnabled()) {
            promise.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    if (eventPublisher.publishingEnabled()) {
                        requestWriteCompletionTimeNanos = Clock.newStartTimeNanos();
                        if (future.isSuccess()) {
                            eventsListener.onRequestWriteComplete(Clock.onEndNanos(headerWriteStartTimeNanos),
                                                                  NANOSECONDS);
                        } else {
                            eventsListener.onRequestWriteFailed(Clock.onEndNanos(headerWriteStartTimeNanos),
                                                                NANOSECONDS, future.cause());
                        }
                    }
                }
            });
        }
    }

    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        if (evt instanceof ConnectionReuseEvent) {
            resetSubscriptionState(connectionInputSubscriber);
            connectionInputSubscriber = null;
        } else if (PooledConnectionReleaseEvent.INSTANCE == evt) {
            onPooledConnectionRelease(connectionInputSubscriber);
        }
        super.userEventTriggered(ctx, evt);
    }

    @Override
    protected void onClosedBeforeReceiveComplete(ConnectionInputSubscriber connectionInputSubscriber) {
        if (connectionInputSubscriber.getChannel().isActive()) {
            /*
             * If the close is triggerred by the user, the channel will be active.
             * If the response, isn't complete, then the connection can not be used.
             */
            connectionInputSubscriber.getChannel().attr(ClientConnectionToChannelBridge.DISCARD_CONNECTION).set(true);
        }
    }

    @Override
    protected boolean isInboundHeader(Object nextItem) {
        return nextItem instanceof HttpResponse;
    }

    @Override
    protected boolean isOutboundHeader(Object nextItem) {
        return nextItem instanceof HttpRequest;
    }

    @Override
    protected Object newHttpObject(Object nextItem, Channel channel) {
        final HttpResponse nettyResponse = (HttpResponse) nextItem;

        if (eventPublisher.publishingEnabled()) {
            long duration = -1;
            if (requestWriteCompletionTimeNanos != -1) {
                duration = Clock.onEndNanos(requestWriteCompletionTimeNanos);
            }
            eventsListener.onResponseHeadersReceived(nettyResponse.status().code(), duration, NANOSECONDS);
        }

        final HttpClientResponseImpl<C> rxResponse = HttpClientResponseImpl.unsafeCreate(nettyResponse);
        Long keepAliveTimeoutSeconds = rxResponse.getKeepAliveTimeoutSeconds();
        if (null != keepAliveTimeoutSeconds) {
            channel.attr(KEEP_ALIVE_TIMEOUT_MILLIS_ATTR).set(keepAliveTimeoutSeconds * 1000);
        }

        if (!rxResponse.isKeepAlive()) {
            channel.attr(ClientConnectionToChannelBridge.DISCARD_CONNECTION).set(true); /*Discard connection when done with this response.*/
        }

        return rxResponse;
    }

    @Override
    protected void onContentReceived() {
        if (eventPublisher.publishingEnabled()) {
            eventsListener.onResponseContentReceived();
        }
    }

    @Override
    protected void onContentReceiveComplete(long receiveStartTimeNanos) {
        connectionInputSubscriber.onCompleted(); /*Unsubscribe from the input and hence close/release connection*/
        if (eventPublisher.publishingEnabled()) {
            long headerWriteStart = getHeaderWriteStartTimeNanos();
            eventsListener.onResponseReceiveComplete(Clock.onEndNanos(receiveStartTimeNanos), NANOSECONDS);
            eventsListener.onRequestProcessingComplete(Clock.onEndNanos(headerWriteStart), NANOSECONDS);
        }
    }

    @Override
    protected void onNewContentSubscriber(final ConnectionInputSubscriber inputSubscriber, Subscriber<? super C> newSub) {
        newSub.add(Subscriptions.create(new Action0() {
            @Override
            public void call() {
                inputSubscriber.unsubscribe();
            }
        }));
    }

    private void onPooledConnectionRelease(ConnectionInputSubscriber connectionInputSubscriber) {
        onChannelClose(connectionInputSubscriber);
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_c8efda9_215f487/rev_c8efda9-215f487/rxnetty-common/src/main/java/io/reactivex/netty/threads/RxJavaNettyBasedSchedulersHook.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package io.reactivex.netty.threads;

import io.netty.channel.EventLoopGroup;
import rx.Scheduler;
import rx.annotations.Beta;
import rx.plugins.RxJavaSchedulersHook;
import rx.schedulers.Schedulers;

/**
 * A scheduler hook for RxJava, to override the computation scheduler, as retrieved via {@link Schedulers#computation()},
 * with a scheduler to use netty's {@link EventLoopGroup}. The computation scheduler implementation is as provided as an
 * {@link RxJavaEventloopScheduler} instance. <p>
 *
 * This is to be used as <p>
 {@code
       RxJavaPlugins.getInstance().registerSchedulersHook(hook);
 }
 at startup.
 */
@Beta
public class RxJavaNettyBasedSchedulersHook extends RxJavaSchedulersHook {

    private final RxJavaEventloopScheduler computationScheduler;

    public RxJavaNettyBasedSchedulersHook(RxJavaEventloopScheduler computationScheduler) {
        this.computationScheduler = computationScheduler;
    }

    @Override
    public Scheduler getComputationScheduler() {
        return computationScheduler;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_c8efda9_215f487/rev_c8efda9-215f487/rxnetty-common/src/main/java/io/reactivex/netty/threads/RxJavaEventloopScheduler.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package io.reactivex.netty.threads;

import io.netty.channel.EventLoop;
import io.netty.channel.EventLoopGroup;
import io.netty.util.concurrent.Future;
import rx.Scheduler;
import rx.Subscription;
import rx.annotations.Beta;
import rx.functions.Action0;
import rx.internal.util.SubscriptionList;
import rx.subscriptions.Subscriptions;

import java.util.concurrent.TimeUnit;

/**
 * A scheduler that uses a provided {@link EventLoopGroup} instance to schedule tasks. This should typically be used as
 * a computation scheduler or any other scheduler that do not schedule blocking tasks. <p>
 */
@Beta
public class RxJavaEventloopScheduler extends Scheduler {

    private final EventLoopGroup eventLoopGroup;

    public RxJavaEventloopScheduler(EventLoopGroup eventLoopGroup) {
        this.eventLoopGroup = eventLoopGroup;
    }

    @Override
    public Worker createWorker() {
        final EventLoop eventLoop = eventLoopGroup.next();

        return new Worker() {

            private final SubscriptionList subs = new SubscriptionList();

            @Override
            public Subscription schedule(final Action0 action) {
                if (isUnsubscribed()) {
                    return Subscriptions.unsubscribed();
                }

                /*If already on the eventloop then execute the action, else schedule it on the eventloop*/
                if (eventLoop.inEventLoop()) {
                    action.call();
                    return Subscriptions.empty();
                } else {
                    final Future<?> result = eventLoop.submit(new Runnable() {
                        @Override
                        public void run() {
                            action.call();
                        }
                    });

                    Subscription toReturn = fromFuture(result);
                    subs.add(toReturn);
                    return toReturn;
                }
            }

            @Override
            public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {

                if (delayTime <= 0) {
                    return schedule(action);
                }

                if (isUnsubscribed()) {
                    return Subscriptions.unsubscribed();
                }

                final Future<?> result = eventLoop.schedule(new Runnable() {
                    @Override
                    public void run() {
                        action.call();
                    }
                }, delayTime, unit);

                Subscription toReturn = fromFuture(result);
                subs.add(toReturn);
                return toReturn;
            }

            @Override
            public void unsubscribe() {
                subs.unsubscribe();
            }

            @Override
            public boolean isUnsubscribed() {
                return subs.isUnsubscribed();
            }

            private Subscription fromFuture(final Future<?> result) {
                return Subscriptions.create(new Action0() {
                    @Override
                    public void call() {
                        result.cancel(false);
                    }
                });
            }
        };
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_be2a71b_752d772/rev_be2a71b-752d772/rxnetty-common/src/main/java/io/reactivex/netty/threads/RxJavaNettyBasedSchedulersHook.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package io.reactivex.netty.threads;

import io.netty.channel.EventLoopGroup;
import rx.Scheduler;
import rx.annotations.Beta;
import rx.plugins.RxJavaSchedulersHook;
import rx.schedulers.Schedulers;

/**
 * A scheduler hook for RxJava, to override the computation scheduler, as retrieved via {@link Schedulers#computation()},
 * with a scheduler to use netty's {@link EventLoopGroup}. The computation scheduler implementation is as provided as an
 * {@link RxJavaEventloopScheduler} instance. <p>
 *
 * This is to be used as <p>
 {@code
       RxJavaPlugins.getInstance().registerSchedulersHook(hook);
 }
 at startup.
 */
@Beta
public class RxJavaNettyBasedSchedulersHook extends RxJavaSchedulersHook {

    private final RxJavaEventloopScheduler computationScheduler;

    public RxJavaNettyBasedSchedulersHook(RxJavaEventloopScheduler computationScheduler) {
        this.computationScheduler = computationScheduler;
    }

    @Override
    public Scheduler getComputationScheduler() {
        return computationScheduler;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/RxNetty/revisions/rev_be2a71b_752d772/rev_be2a71b-752d772/rxnetty-common/src/main/java/io/reactivex/netty/threads/RxJavaEventloopScheduler.java;<<<<<<< MINE
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package io.reactivex.netty.threads;

import io.netty.channel.EventLoop;
import io.netty.channel.EventLoopGroup;
import io.netty.util.concurrent.Future;
import rx.Scheduler;
import rx.Subscription;
import rx.annotations.Beta;
import rx.functions.Action0;
import rx.internal.schedulers.EventLoopsScheduler;
import rx.internal.schedulers.ScheduledAction;
import rx.internal.util.SubscriptionList;
import rx.subscriptions.CompositeSubscription;
import rx.subscriptions.Subscriptions;

import java.util.concurrent.TimeUnit;

/**
 * A scheduler that uses a provided {@link EventLoopGroup} instance to schedule tasks. This should typically be used as
 * a computation scheduler or any other scheduler that do not schedule blocking tasks. <p>
 */
@Beta
public class RxJavaEventloopScheduler extends Scheduler {

    private final EventLoopGroup eventLoopGroup;

    public RxJavaEventloopScheduler(EventLoopGroup eventLoopGroup) {
        this.eventLoopGroup = eventLoopGroup;
    }

    @Override
    public Worker createWorker() {
        final EventLoop eventLoop = eventLoopGroup.next();
        return new EventloopWorker(eventLoop);
    }

    /**
     * This code is more or less copied from RxJava's {@link EventLoopsScheduler} worker code.
     **/
    /*Visible for testing*/static class EventloopWorker extends Worker {

        /**
         * Why are there two subscription holders?
         *
         * The serial subscriptions are used for non-delayed schedules which are always executed (and hence removed)
         * in order. Since SubscriptionList holds the subs as a linked list, removals are optimal for serial removes.
         * OTOH, delayed schedules are executed (and hence removed) out of order and hence a CompositeSubscription,
         * that stores the subs in a hash structure is more optimal for removals.
         */
        private final SubscriptionList serial;
        private final CompositeSubscription timed;
        private final SubscriptionList both;
        private final EventLoop eventLoop;

        public EventloopWorker(EventLoop eventLoop) {
            this.eventLoop = eventLoop;
            serial = new SubscriptionList();
            timed = new CompositeSubscription();
            both = new SubscriptionList(serial, timed);
        }

        @Override
        public Subscription schedule(final Action0 action) {
            return schedule(action, 0, TimeUnit.DAYS);
        }

        @Override
        public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {

            if (isUnsubscribed()) {
                return Subscriptions.unsubscribed();
            }

            final ScheduledAction sa;

            if (delayTime <= 0) {
                sa = new ScheduledAction(action, serial);
                serial.add(sa);
            } else {
                sa = new ScheduledAction(action, timed);
                timed.add(sa);
            }

            final Future<?> result = eventLoop.schedule(sa, delayTime, unit);
            Subscription cancelFuture = Subscriptions.create(new Action0() {
                @Override
                public void call() {
                    result.cancel(false);
                }
            });
            sa.add(cancelFuture); /*An unsubscribe of the returned sub should cancel the future*/
            return sa;
        }

        @Override
        public void unsubscribe() {
            both.unsubscribe();
        }

        @Override
        public boolean isUnsubscribed() {
            return both.isUnsubscribed();
        }

        /*Visible for testing*/boolean hasScheduledSubscriptions() {
            return serial.hasSubscriptions();
        }

        /*Visible for testing*/boolean hasDelayScheduledSubscriptions() {
            return timed.hasSubscriptions();
        }
    }
}=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package io.reactivex.netty.threads;

import io.netty.channel.EventLoop;
import io.netty.channel.EventLoopGroup;
import io.netty.util.concurrent.Future;
import rx.Scheduler;
import rx.Subscription;
import rx.annotations.Beta;
import rx.functions.Action0;
import rx.internal.util.SubscriptionList;
import rx.subscriptions.Subscriptions;

import java.util.concurrent.TimeUnit;

/**
 * A scheduler that uses a provided {@link EventLoopGroup} instance to schedule tasks. This should typically be used as
 * a computation scheduler or any other scheduler that do not schedule blocking tasks. <p>
 */
@Beta
public class RxJavaEventloopScheduler extends Scheduler {

    private final EventLoopGroup eventLoopGroup;

    public RxJavaEventloopScheduler(EventLoopGroup eventLoopGroup) {
        this.eventLoopGroup = eventLoopGroup;
    }

    @Override
    public Worker createWorker() {
        final EventLoop eventLoop = eventLoopGroup.next();

        return new Worker() {

            private final SubscriptionList subs = new SubscriptionList();

            @Override
            public Subscription schedule(final Action0 action) {
                if (isUnsubscribed()) {
                    return Subscriptions.unsubscribed();
                }

                /*If already on the eventloop then execute the action, else schedule it on the eventloop*/
                if (eventLoop.inEventLoop()) {
                    action.call();
                    return Subscriptions.empty();
                } else {
                    final Future<?> result = eventLoop.submit(new Runnable() {
                        @Override
                        public void run() {
                            action.call();
                        }
                    });

                    Subscription toReturn = fromFuture(result);
                    subs.add(toReturn);
                    return toReturn;
                }
            }

            @Override
            public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {

                if (delayTime <= 0) {
                    return schedule(action);
                }

                if (isUnsubscribed()) {
                    return Subscriptions.unsubscribed();
                }

                final Future<?> result = eventLoop.schedule(new Runnable() {
                    @Override
                    public void run() {
                        action.call();
                    }
                }, delayTime, unit);

                Subscription toReturn = fromFuture(result);
                subs.add(toReturn);
                return toReturn;
            }

            @Override
            public void unsubscribe() {
                subs.unsubscribe();
            }

            @Override
            public boolean isUnsubscribed() {
                return subs.isUnsubscribed();
            }

            private Subscription fromFuture(final Future<?> result) {
                return Subscriptions.create(new Action0() {
                    @Override
                    public void call() {
                        result.cancel(false);
                    }
                });
            }
        };
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_ede1926_2477211/rev_ede1926-2477211/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java;<<<<<<< MINE
/*
 * Copyright (C) 2012 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal.codegen;

import dagger.internal.Binding;
import dagger.internal.Linker;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.TypeMirror;

/**
 * A build time binding that injects the constructor and fields of a class.
 */
final class AtInjectBinding extends Binding<Object> {
  private final TypeElement type;
  private final List<String> keys;
  private final Binding<?>[] bindings;
  private final String supertypeKey;
  private Binding supertypeBinding;

  private AtInjectBinding(String provideKey, String membersKey,
      TypeElement type, List<String> keys, String supertypeKey) {
    super(provideKey, membersKey, type.getAnnotation(Singleton.class) != null,
        type.getQualifiedName().toString());
    this.type = type;
    this.keys = keys;
    this.bindings = new Binding<?>[keys.size()];
    this.supertypeKey = supertypeKey;
  }

  static AtInjectBinding create(TypeElement type, boolean mustHaveInjections) {
    List<String> requiredKeys = new ArrayList<String>();
    boolean hasInjectConstructor = false;
    boolean hasNoArgsConstructor = false;

    for (Element enclosed : type.getEnclosedElements()) {
      switch (enclosed.getKind()) {
      case FIELD:
        if (hasAtInject(enclosed) && !enclosed.getModifiers().contains(Modifier.STATIC)) {
          // Attach the non-static fields of 'type'.
          requiredKeys.add(GeneratorKeys.get((VariableElement) enclosed));
        }
        break;

      case CONSTRUCTOR:
        ExecutableElement constructor = (ExecutableElement) enclosed;
        List<? extends VariableElement> parameters = constructor.getParameters();
        if (hasAtInject(enclosed)) {
          if (hasAtSingleton(enclosed)) {
            throw new IllegalArgumentException("Singleton annotations have no effect on "
                + "constructors. Did you mean to annotate the class? "
                + type.getQualifiedName().toString());
          }
          if (hasInjectConstructor) {
            throw new IllegalArgumentException("Too many injectable constructors on "
                + type.getQualifiedName().toString());
          }
          hasInjectConstructor = true;
          for (VariableElement parameter : parameters) {
            requiredKeys.add(GeneratorKeys.get(parameter));
          }
        } else if (parameters.isEmpty()) {
          hasNoArgsConstructor = true;
        }
        break;

      default:
        if (hasAtInject(enclosed)) {
          throw new IllegalArgumentException("Unexpected @Inject annotation on " + enclosed);
        }
      }
    }

    if (!hasInjectConstructor && requiredKeys.isEmpty() && mustHaveInjections) {
      throw new IllegalArgumentException("No injectable members on "
          + type.getQualifiedName().toString() + ". Do you want to add an injectable constructor?");
    }

    // Attach the supertype.
    TypeMirror supertype = CodeGen.getApplicationSupertype(type);
    String supertypeKey = supertype != null
        ? GeneratorKeys.rawMembersKey(supertype)
        : null;

    String provideKey = hasInjectConstructor || (hasNoArgsConstructor && !requiredKeys.isEmpty())
        ? GeneratorKeys.get(type.asType())
        : null;
    String membersKey = GeneratorKeys.rawMembersKey(type.asType());
    return new AtInjectBinding(provideKey, membersKey, type, requiredKeys, supertypeKey);
  }

  private static boolean hasAtInject(Element enclosed) {
    return enclosed.getAnnotation(Inject.class) != null;
  }

  private static boolean hasAtSingleton(Element enclosed) {
    return enclosed.getAnnotation(Singleton.class) != null;
  }

  @Override public void attach(Linker linker) {
    String requiredBy = type.getQualifiedName().toString();
    for (int i = 0; i < keys.size(); i++) {
      bindings[i] = linker.requestBinding(keys.get(i), requiredBy,
          getClass().getClassLoader());
    }
    if (supertypeKey != null) {
      supertypeBinding = linker.requestBinding(supertypeKey, requiredBy,
          getClass().getClassLoader(), false, true);
    }
  }

  @Override public Object get() {
    throw new AssertionError("Compile-time binding should never be called to inject.");
  }

  @Override public void injectMembers(Object t) {
    throw new AssertionError("Compile-time binding should never be called to inject.");
  }

  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
    Collections.addAll(get, bindings);
  }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_66e14ce_cb95092/rev_66e14ce-cb95092/core/src/main/java/dagger/internal/FailoverLoader.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2013 Square, Inc.
 * Copyright (C) 2013 Google, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal;


import dagger.internal.loaders.GeneratedAdapters;
import dagger.internal.loaders.ReflectiveAtInjectBinding;
import dagger.internal.loaders.ReflectiveModuleAdapter;
import dagger.internal.loaders.ReflectiveStaticInjection;

/**
 * Handles loading/finding of modules, injection bindings, and static injections by use of a
 * strategy of "load the appropriate generated code" or, if no such code is found, create a
 * reflective equivalent.
 */
public final class FailoverLoader implements Loader {

  /**
   * Obtains a module adapter for {@code module} from the first responding resolver.
   */
  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
    ModuleAdapter<T> result = GeneratedAdapters.initModuleAdapter(type);
    if (result == null) {
      result = ReflectiveModuleAdapter.create(type);
    }
    result.module = (instance != null) ? instance : result.newModule();
    return result;
  }

  @Override public Binding<?> getAtInjectBinding(String key, String className,
      ClassLoader classLoader, boolean mustHaveInjections) {
    try {
      Binding<?> result = GeneratedAdapters.initInjectAdapter(className, classLoader);
      if (result == null) {
        // A null classloader is the system classloader.
        classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
        Class<?> c = classLoader.loadClass(className);
        if (!c.isInterface()) {
          result = ReflectiveAtInjectBinding.create(c, mustHaveInjections);
        }
      }
      return result;
    } catch (ClassNotFoundException e) {
      throw new RuntimeException("Could not find " + className + " needed for binding " + key, e);
    }
  }

  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
    StaticInjection result = GeneratedAdapters.initStaticInjection(injectedClass);
    if (result == null) {
      result = ReflectiveStaticInjection.create(injectedClass);
    }
    return result;
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_66e14ce_cb95092/rev_66e14ce-cb95092/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2012 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal.loaders;

import dagger.internal.Binding;
import dagger.internal.Keys;
import dagger.internal.Linker;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Injects the {@code @Inject}-annotated fields and constructors of a class
 * using reflection.
 */
public final class ReflectiveAtInjectBinding<T> extends Binding<T> {
  private final Field[] fields;
  private final ClassLoader loader;
  private final Constructor<T> constructor;
  private final Class<?> supertype;
  private final String[] keys;
  private final Binding<?>[] fieldBindings;
  private final Binding<?>[] parameterBindings;
  private Binding<? super T> supertypeBinding;

  /**
   * @param keys keys for the fields, constructor parameters and supertype in
   *     that order. These are precomputed to minimize reflection when {@code
   *     attach} is called multiple times.
   * @param constructor the injectable constructor, or null if this binding
   *     supports members injection only.
   * @param supertype the injectable supertype, or null if the supertype is a
   */
  private ReflectiveAtInjectBinding(String provideKey, String membersKey, boolean singleton,
      Class<?> type, Field[] fields, Constructor<T> constructor, int parameterCount,
      Class<?> supertype, String[] keys) {
    super(provideKey, membersKey, singleton, type);
    this.constructor = constructor;
    this.fields = fields;
    this.supertype = supertype;
    this.keys = keys;
    this.parameterBindings = new Binding<?>[parameterCount];
    this.fieldBindings = new Binding<?>[fields.length];
    this.loader = type.getClassLoader();
  }

  @SuppressWarnings("unchecked") // We're careful to make keys and bindings match up.
  @Override public void attach(Linker linker) {
    int k = 0;
    for (int i = 0; i < fields.length; i++) {
      if (fieldBindings[i] == null) {
        fieldBindings[i] = linker.requestBinding(keys[k], fields[i], loader);
      }
      k++;
    }
    if (constructor != null) {
      for (int i = 0; i < parameterBindings.length; i++) {
        if (parameterBindings[i] == null) {
          parameterBindings[i] = linker.requestBinding(keys[k], constructor, loader);
        }
        k++;
      }
    }
    if (supertype != null && supertypeBinding == null) {
      supertypeBinding =
          (Binding<? super T>) linker.requestBinding(keys[k], membersKey, loader, false, true);
    }
  }

  @Override public T get() {
    if (constructor == null) {
      throw new UnsupportedOperationException();
    }
    Object[] args = new Object[parameterBindings.length];
    for (int i = 0; i < parameterBindings.length; i++) {
      args[i] = parameterBindings[i].get();
    }
    T result;
    try {
      result = constructor.newInstance(args);
    } catch (InvocationTargetException e) {
      Throwable cause = e.getCause();
      throw cause instanceof RuntimeException
          ? (RuntimeException) cause
          : new RuntimeException(cause);
    } catch (IllegalAccessException e) {
      throw new AssertionError(e);
    } catch (InstantiationException e) {
      throw new RuntimeException(e);
    }
    injectMembers(result);
    return result;
  }

  @Override public void injectMembers(T t) {
    try {
      for (int i = 0; i < fields.length; i++) {
        fields[i].set(t, fieldBindings[i].get());
      }
      if (supertypeBinding != null) {
        supertypeBinding.injectMembers(t);
      }
    } catch (IllegalAccessException e) {
      throw new AssertionError(e);
    }
  }

  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
    if (parameterBindings != null) {
      Collections.addAll(get, parameterBindings);
    }
    Collections.addAll(injectMembers, fieldBindings);
    if (supertypeBinding != null) {
      injectMembers.add(supertypeBinding);
    }
  }

  @Override public String toString() {
    return provideKey != null ? provideKey : membersKey;
  }

  public static <T> Binding<T> create(Class<T> type, boolean mustHaveInjections) {
    boolean singleton = type.isAnnotationPresent(Singleton.class);
    List<String> keys = new ArrayList<String>();

    // Lookup the injectable fields and their corresponding keys.
    List<Field> injectedFields = new ArrayList<Field>();
    for (Class<?> c = type; c != Object.class; c = c.getSuperclass()) {
      for (Field field : c.getDeclaredFields()) {
        if (!field.isAnnotationPresent(Inject.class) || Modifier.isStatic(field.getModifiers())) {
          continue;
        }
        if ((field.getModifiers() & Modifier.PRIVATE) != 0) {
          throw new IllegalStateException("Can't inject private field: " + field);
        }
        field.setAccessible(true);
        injectedFields.add(field);
        keys.add(Keys.get(field.getGenericType(), field.getAnnotations(), field));
      }
    }

    // Look up @Inject-annotated constructors. If there's no @Inject-annotated
    // constructor, use a default public constructor if the class has other
    // injections. Otherwise treat the class as non-injectable.
    Constructor<T> injectedConstructor = null;
    for (Constructor<T> constructor : getConstructorsForType(type)) {
      if (!constructor.isAnnotationPresent(Inject.class)) {
        continue;
      }
      if (injectedConstructor != null) {
        throw new IllegalArgumentException("Too many injectable constructors on " + type.getName());
      }
      injectedConstructor = constructor;
    }
    if (injectedConstructor == null) {
      if (!injectedFields.isEmpty()) {
        try {
          injectedConstructor = type.getDeclaredConstructor();
        } catch (NoSuchMethodException ignored) {
        }
      } else if (mustHaveInjections) {
        throw new IllegalArgumentException("No injectable members on " + type.getName()
            + ". Do you want to add an injectable constructor?");
      }
    }

    int parameterCount;
    String provideKey;
    if (injectedConstructor != null) {
      if ((injectedConstructor.getModifiers() & Modifier.PRIVATE) != 0) {
        throw new IllegalStateException("Can't inject private constructor: " + injectedConstructor);
      }

      provideKey = Keys.get(type);
      injectedConstructor.setAccessible(true);
      Type[] types = injectedConstructor.getGenericParameterTypes();
      parameterCount = types.length;
      if (parameterCount != 0) {
        Annotation[][] annotations = injectedConstructor.getParameterAnnotations();
        for (int p = 0; p < types.length; p++) {
          keys.add(Keys.get(types[p], annotations[p], injectedConstructor));
        }
      }
    } else {
      provideKey = null;
      parameterCount = 0;
      if (singleton) {
        throw new IllegalArgumentException(
            "No injectable constructor on @Singleton " + type.getName());
      }
    }

    Class<? super T> supertype = type.getSuperclass();
    if (supertype != null) {
      if (Keys.isPlatformType(supertype.getName())) {
        supertype = null;
      } else {
        keys.add(Keys.getMembersKey(supertype));
      }
    }

    String membersKey = Keys.getMembersKey(type);
    return new ReflectiveAtInjectBinding<T>(provideKey, membersKey, singleton, type,
        injectedFields.toArray(new Field[injectedFields.size()]), injectedConstructor,
        parameterCount, supertype, keys.toArray(new String[keys.size()]));
  }

  @SuppressWarnings("unchecked") // Class.getDeclaredConstructors is an unsafe API.
  private static <T> Constructor<T>[] getConstructorsForType(Class<T> type) {
    return (Constructor<T>[]) type.getDeclaredConstructors();
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_66e14ce_cb95092/rev_66e14ce-cb95092/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2012 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal.loaders;

import dagger.Lazy;
import dagger.Module;
import dagger.Provides;
import dagger.internal.Binding;
import dagger.internal.Keys;
import dagger.internal.Linker;
import dagger.internal.ModuleAdapter;
import dagger.internal.SetBinding;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.Map;
import java.util.Set;
import javax.inject.Provider;
import javax.inject.Singleton;

public final class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
  final Class<?> moduleClass;

  public ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
    super(
        injectableTypesToKeys(annotation.injects()),
        annotation.staticInjections(),
        annotation.overrides(),
        annotation.includes(),
        annotation.complete(),
        annotation.library());
    this.moduleClass = moduleClass;
  }

  private static String[] injectableTypesToKeys(Class<?>[] injectableTypes) {
    String[] result = new String[injectableTypes.length];
    for (int i = 0; i < injectableTypes.length; i++) {
      Class<?> injectableType = injectableTypes[i];
      result[i] = injectableType.isInterface()
          ? Keys.get(injectableType)
          : Keys.getMembersKey(injectableType);
    }
    return result;
  }

  @Override public void getBindings(Map<String, Binding<?>> bindings) {
    for (Class<?> c = moduleClass; !c.equals(Object.class); c = c.getSuperclass()) {
      for (Method method : c.getDeclaredMethods()) {
        Provides provides = method.getAnnotation(Provides.class);
        if (provides != null) {
          Type genericReturnType = method.getGenericReturnType();

          Type typeToCheck = genericReturnType;
          if (genericReturnType instanceof ParameterizedType) {
            typeToCheck = ((ParameterizedType) genericReturnType).getRawType();
          }
          if (Provider.class.equals(typeToCheck)) {
            throw new IllegalStateException("@Provides method must not return Provider directly: "
                + c.getName()
                + "."
                + method.getName());
          }
          if (Lazy.class.equals(typeToCheck)) {
            throw new IllegalStateException("@Provides method must not return Lazy directly: "
                + c.getName()
                + "."
                + method.getName());
          }

          String key = Keys.get(genericReturnType, method.getAnnotations(), method);
          switch (provides.type()) {
            case UNIQUE:
              handleBindings(bindings, method, key, library);
              break;
            case SET:
              handleSetBindings(bindings, method, key, library);
              break;
            default:
              throw new AssertionError("Unknown @Provides type " + provides.type());
          }
        }
      }
    }
  }

  private <T> void handleBindings(Map<String, Binding<?>> bindings, Method method, String key,
      boolean library) {
    bindings.put(key, new ProviderMethodBinding<T>(method, key, module, library));
  }

  private <T> void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String key,
      boolean library) {
    String setKey = Keys.getSetKey(method.getGenericReturnType(), method.getAnnotations(), method);
    SetBinding.<T>add(bindings, setKey, new ProviderMethodBinding<T>(method, key, module,
        library));
  }

  @Override public Object newModule() {
    try {
      Constructor<?> constructor = moduleClass.getDeclaredConstructor();
      constructor.setAccessible(true);
      return constructor.newInstance();
    } catch (InvocationTargetException e) {
      throw new IllegalArgumentException(e.getCause());
    } catch (NoSuchMethodException e) {
      throw new IllegalArgumentException("Could not construct " + moduleClass.getName()
          + " as it lacks an accessible no-args constructor. This module must be passed"
          + " in as an instance, or an accessible no-args constructor must be added.", e);
    } catch (InstantiationException e) {
      throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
    } catch (IllegalAccessException e) {
      throw new AssertionError();
    }
  }

  /**
   * Creates a ReflectiveModuleAdapter or throws an {@code IllegalArgumentException}.
   */
  @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
  public static <T> ModuleAdapter<T> create(Class<? extends T> moduleClass) {
    Module annotation = moduleClass.getAnnotation(Module.class);
    if (annotation == null) {
      throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
    }
    if (!moduleClass.getSuperclass().equals(Object.class)) {
      throw new IllegalArgumentException(
          "Modules must not extend from other classes: " + moduleClass.getName());
    }
    return (ModuleAdapter<T>) new ReflectiveModuleAdapter(moduleClass, annotation);
  }

  /**
   * Invokes a method to provide a value. The method's parameters are injected.
   */
  private final class ProviderMethodBinding<T> extends Binding<T> {
    private Binding<?>[] parameters;
    private final Method method;
    private final Object instance;

    public ProviderMethodBinding(Method method, String key, Object instance, boolean library) {
      super(key, null, method.isAnnotationPresent(Singleton.class),
          moduleClass.getName() + "." + method.getName() + "()");
      this.method = method;
      this.instance = instance;
      method.setAccessible(true);
      setLibrary(library);
    }

    @Override public void attach(Linker linker) {
      Type[] types = method.getGenericParameterTypes();
      Annotation[][] annotations = method.getParameterAnnotations();
      parameters = new Binding[types.length];
      for (int i = 0; i < parameters.length; i++) {
        String key = Keys.get(types[i], annotations[i], method + " parameter " + i);
        parameters[i] = linker.requestBinding(key, method, instance.getClass().getClassLoader());
      }
    }

    @SuppressWarnings("unchecked") // We defined 'T' in terms of the method's return type.
    @Override public T get() {
      Object[] args = new Object[parameters.length];
      for (int i = 0; i < parameters.length; i++) {
        args[i] = parameters[i].get();
      }
      try {
        return (T) method.invoke(instance, args);
      } catch (InvocationTargetException e) {
        Throwable cause = e.getCause();
        throw cause instanceof RuntimeException
            ? (RuntimeException) cause
            : new RuntimeException(cause);
      } catch (IllegalAccessException e) {
        throw new RuntimeException(e);
      }
    }

    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
      for (Binding<?> binding : parameters) {
        get.add(binding);
      }
    }

    @Override public void injectMembers(T t) {
      throw new AssertionError("Provides method bindings are not MembersInjectors");
    }

    @Override public String toString() {
      return method.toString();
    }
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_66e14ce_cb95092/rev_66e14ce-cb95092/core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2012 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal.loaders;

import dagger.internal.Binding;
import dagger.internal.Keys;
import dagger.internal.Linker;
import dagger.internal.StaticInjection;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;

/**
 * Uses reflection to inject the static fields of a class.
 */
public final class ReflectiveStaticInjection extends StaticInjection {
  private final ClassLoader loader;
  private final Field[] fields;
  private Binding<?>[] bindings;

  private ReflectiveStaticInjection(ClassLoader loader, Field[] fields) {
    this.fields = fields;
    this.loader = loader;
  }

  @Override public void attach(Linker linker) {
    bindings = new Binding<?>[fields.length];
    for (int i = 0; i < fields.length; i++) {
      Field field = fields[i];
      String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
      bindings[i] = linker.requestBinding(key, field, loader);
    }
  }

  @Override public void inject() {
    try {
      for (int f = 0; f < fields.length; f++) {
        fields[f].set(null, bindings[f].get());
      }
    } catch (IllegalAccessException e) {
      throw new AssertionError(e);
    }
  }

  public static StaticInjection create(Class<?> injectedClass) {
    List<Field> fields = new ArrayList<Field>();
    for (Field field : injectedClass.getDeclaredFields()) {
      if (Modifier.isStatic(field.getModifiers()) && field.isAnnotationPresent(Inject.class)) {
        field.setAccessible(true);
        fields.add(field);
      }
    }
    if (fields.isEmpty()) {
      throw new IllegalArgumentException("No static injections: " + injectedClass.getName());
    }
    return new ReflectiveStaticInjection(injectedClass.getClassLoader(),
        fields.toArray(new Field[fields.size()]));
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_66e14ce_cb95092/rev_66e14ce-cb95092/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2013 Square, Inc.
 * Copyright (C) 2013 Google, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal.loaders;

import dagger.internal.Binding;
import dagger.internal.ModuleAdapter;
import dagger.internal.StaticInjection;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * A utility for loading and initializing generated adapters.
 */
public final class GeneratedAdapters {
  private static final String SEPARATOR = "$$";
  public static final String INJECT_ADAPTER_SUFFIX = SEPARATOR + "InjectAdapter";
  public static final String MODULE_ADAPTER_SUFFIX = SEPARATOR + "ModuleAdapter";
  public static final String STATIC_INJECTION_SUFFIX = SEPARATOR + "StaticInjection";
  private static final Logger logger = Logger.getLogger(GeneratedAdapters.class.getName());

  private GeneratedAdapters() { }

  public static <T> ModuleAdapter<T> initModuleAdapter(Class<? extends T> moduleClass) {
    return instantiate(moduleClass.getName() + MODULE_ADAPTER_SUFFIX, moduleClass.getClassLoader());
  }

  public static Binding<?> initInjectAdapter(String className, ClassLoader classLoader) {
    return instantiate(className + INJECT_ADAPTER_SUFFIX, classLoader);
  }

  public static StaticInjection initStaticInjection(Class<?> injectedClass) {
    return instantiate(injectedClass.getName() + STATIC_INJECTION_SUFFIX,
        injectedClass.getClassLoader());
  }

  private static <T> T instantiate(String name, ClassLoader classLoader) {
    try {
      // A null classloader is the system classloader.
      classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
      Class<?> generatedClass = classLoader.loadClass(name);
      Constructor<?> constructor = generatedClass.getDeclaredConstructor();
      constructor.setAccessible(true);
      return (T) constructor.newInstance();
    } catch (ClassNotFoundException e) {
      if (logger.isLoggable(Level.FINE)) {
        logger.log(Level.FINE, name + " could not be found.", e);
      }
      return null; // Not finding a class is not inherently an error, unlike finding a bad class.
    } catch (NoSuchMethodException e) {
      throw new RuntimeException("No default constructor found on " + name, e);
    } catch (InstantiationException e) {
      throw new RuntimeException("Failed to initialize " + name, e);
    } catch (IllegalAccessException e) {
      throw new RuntimeException("Failed to initialize " + name, e);
    } catch (InvocationTargetException e) {
      throw new RuntimeException("Error while initializing " + name, e.getCause());
    }
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_66e14ce_cb95092/rev_66e14ce-cb95092/core/src/main/java/dagger/internal/Modules.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2012 Square, Inc.
 * Copyright (C) 2012 Google, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal;


import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Static helper for organizing modules.
 */
public final class Modules {

  private Modules() { }

  /**
   * Returns a full set of module adapters, including module adapters for included
   * modules.
   */
  public static Map<Class<?>, ModuleAdapter<?>> getAllModuleAdapters(Loader plugin,
      Object[] seedModules) {
    // Create a module adapter for each seed module.
    ModuleAdapter<?>[] seedAdapters = new ModuleAdapter<?>[seedModules.length];
    int s = 0;
    for (Object module : seedModules) {
      if (module instanceof Class) {
        seedAdapters[s++] = plugin.getModuleAdapter((Class<?>) module, null); // Loader constructs.
      } else {
        seedAdapters[s++] = plugin.getModuleAdapter(module.getClass(), module);
      }
    }

    Map<Class<?>, ModuleAdapter<?>> adaptersByModuleType
        = new LinkedHashMap<Class<?>, ModuleAdapter<?>>();

    // Add the adapters that we have module instances for. This way we won't
    // construct module objects when we have a user-supplied instance.
    for (ModuleAdapter<?> adapter : seedAdapters) {
      adaptersByModuleType.put(adapter.getModule().getClass(), adapter);
    }

    // Next add adapters for the modules that we need to construct. This creates
    // instances of modules as necessary.
    for (ModuleAdapter<?> adapter : seedAdapters) {
      collectIncludedModulesRecursively(plugin, adapter, adaptersByModuleType);
    }

    return adaptersByModuleType;
  }

  /**
   * Fills {@code result} with the module adapters for the includes of {@code
   * adapter}, and their includes recursively.
   */
  private static void collectIncludedModulesRecursively(Loader plugin, ModuleAdapter<?> adapter,
      Map<Class<?>, ModuleAdapter<?>> result) {
    for (Class<?> include : adapter.includes) {
      if (!result.containsKey(include)) {
        ModuleAdapter<Object> includedModuleAdapter = plugin.getModuleAdapter(include, null);
        result.put(include, includedModuleAdapter);
        collectIncludedModulesRecursively(plugin, includedModuleAdapter, result);
      }
    }
  }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/core/src/main/java/dagger/internal/ProvidesBinding.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2013 Google, Inc.
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal;

/**
 * A {@code Binding<T>} which delegates to a module method.
 */
public abstract class ProvidesBinding<T> extends Binding<T> {
  protected final String moduleClass;

  protected final String methodName;

  /**
   * Creates a new {@code ProvidesBinding} with the given "provides" key, a flag as to whether
   * this binding should be scoped, and the requiredBy object for traceability.
   */
  public ProvidesBinding(String key, boolean singleton, String moduleClass, String methodName) {
    // Set requiredBy as fullMethodName to preserve older debugging meaning.
    super(key, null, singleton, moduleClass + "." + methodName + "()");
    this.moduleClass = moduleClass;
    this.methodName = methodName;
  }

  /**
   * A provides binding is responsible for implementing storage of the module instance, and
   * delegation to that module instance's method.
   */
  @Override
  public abstract T get();

  @Override public String toString() {
    return getClass().getName() + "[key=" + provideKey
        + " method=" + moduleClass + "." + methodName + "()" + "]";
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/core/src/main/java/dagger/internal/Binding.java;<<<<<<< MINE
=======

  /** An exception thrown by anything attempting to construct a binding which is invalid. */
  public static class InvalidBindingException extends RuntimeException {
    public final String type;

    public InvalidBindingException(String type, String error) {
      super(error);
      this.type = type;
    }

    public InvalidBindingException(String type, String error, Throwable cause) {
      super("Binding for " + type + " was invalid: " + error, cause);
      this.type = type;
    }
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/core/src/main/java/dagger/internal/Loader.java;<<<<<<< MINE
   * Instantiates a class using its default constructor and the given {@link ClassLoader}.
=======
   * Instantiates a class using its default constructor and the given {@link ClassLoader}. This
   * method does not attempt to {@linkplain AccessibleObject#setAccessible set accessibility}.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/core/src/main/java/dagger/internal/BindingsGroup.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2013 Square, Inc.
 * Copyright (C) 2013 Google, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 * A grouping of bindings that fails when existing values are clobbered, to be used in collecting
 * the initial set of bindings for a graph (from provides methods).
 */
public abstract class BindingsGroup {
  private final Map<String, Binding<?>> bindings = new LinkedHashMap<String, Binding<?>>();

  public abstract Binding<?> contributeSetBinding(String key, SetBinding<?> value);

  public Binding<?> contributeProvidesBinding(String key, ProvidesBinding<?> value) {
    return put(key, value);
  }

  protected Binding<?> put(String key, Binding<?> value) {
    Binding<?> clobbered = bindings.put(key, value);
    if (clobbered != null) {
      bindings.put(key, clobbered); // Put things back as they were.
      throw new IllegalArgumentException("Duplicate:\n    " + clobbered + "\n    " + value);
    }
    return null;
  }

  public Binding<?> get(String key) {
    return bindings.get(key);
  }

  public final Set<Entry<String, Binding<?>>> entrySet() {
    return bindings.entrySet();
  }

  @Override public String toString() {
    return getClass().getSimpleName() + bindings.toString();
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/core/src/main/java/dagger/internal/Memoizer.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * Represents an operation to be
 */
abstract class Memoizer<K, V> {
  private final Map<K, V> map;
  private final Lock readLock;
  private final Lock writeLock;

  public Memoizer() {
    this.map = new LinkedHashMap<K, V>();
    ReadWriteLock lock = new ReentrantReadWriteLock();
    this.readLock = lock.readLock();
    this.writeLock = lock.writeLock();
  }

  public final V get(K key) {
    if (key == null) {
      throw new NullPointerException("key == null");
    }

    // check to see if we already have a value
    readLock.lock();
    try {
      V value = map.get(key);
      if (value != null) {
        return value;
      }
    } finally {
      readLock.unlock();
    }

    // create a new value.  this may race and we might create more than one instance, but that's ok
    V newValue = create(key);
    if (newValue == null) {
      throw new NullPointerException("create returned null");
    }

    // write the new value and return it
    writeLock.lock();
    try {
      map.put(key, newValue);
      return newValue;
    } finally {
      writeLock.unlock();
    }
  }

  protected abstract V create(K key);

  @Override public final String toString() {
    readLock.lock();
    try {
      return map.toString();
    } finally {
      readLock.unlock();
    }
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/core/src/main/java/dagger/ObjectGraph.java;<<<<<<< MINE
=======


  /**
   * A BindingsGroup which fails when existing values are clobbered and sets aside
   * {@link SetBinding}.
   */
  private static final class StandardBindings extends BindingsGroup {
    private final List<SetBinding<?>> setBindings;

    public StandardBindings() {
      setBindings = new ArrayList<SetBinding<?>>();
    }

    public StandardBindings(List<SetBinding<?>> baseSetBindings) {
      setBindings = new ArrayList<SetBinding<?>>(baseSetBindings.size());
      for (SetBinding<?> sb : baseSetBindings) {
        @SuppressWarnings({ "rawtypes", "unchecked" })
        SetBinding<?> child = new SetBinding(sb);
        setBindings.add(child);
        put(child.provideKey, child);
      }
    }

    @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
      setBindings.add(value);
      return super.put(key, value);
    }
  }

  /**
   * A BindingsGroup which throws an {@link IllegalArgumentException} when a
   * {@link SetBinding} is contributed, since overrides modules cannot contribute such
   * bindings.
   */
  private static final class OverridesBindings extends BindingsGroup {
    OverridesBindings() { }

    @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
      throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
    }
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/core/src/test/java/dagger/internal/TestingModuleAdapter.java;<<<<<<< MINE
  private final class ProviderMethodBinding<T> extends Binding<T> {
=======
  private static final class ReflectiveProvidesBinding<T> extends ProvidesBinding<T> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/core/src/test/java/dagger/SetBindingTest.java;<<<<<<< MINE
=======
  @Test public void duplicateValuesContributed() {
    class TestEntryPoint {
      @Inject Set<String> strings;
    }

    @Module(injects = TestEntryPoint.class)
    class TestModule {
      @Provides(type=SET) String provideString1() { return "a"; }
      @Provides(type=SET) String provideString2() { return "a"; }
      @Provides(type=SET) String provideString3() { return "b"; }
    }

    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
    assertThat(ep.strings).containsOnly("a", "b");
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/core/src/test/java/dagger/SetBindingTest.java;<<<<<<< MINE
=======
  @Test public void validateLibraryModules() {
    class TestEntryPoint {}

    @Module(library = true)
    class SetModule {
      @Provides(type = SET)
      public String provideString() {
        return "";
      }
    }

    @Module(injects = TestEntryPoint.class, includes = SetModule.class)
    class TestModule {}

    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(),
        new TestModule(), new SetModule());
    graph.validate();
  }

  @Test public void validateLibraryModules_nonLibraryContributors() {
    class TestEntryPoint {}

    @Module(library = true)
    class SetModule1 {
      @Provides(type = SET)
      public String provideString() {
        return "a";
      }
    }

    @Module
    class SetModule2 {
      @Provides(type = SET)
      public String provideString() {
        return "b";
      }
    }

    @Module(injects = TestEntryPoint.class, includes = { SetModule1.class, SetModule2.class })
    class TestModule {}

    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(),
        new TestModule(), new SetModule1(), new SetModule2());
    try {
      graph.validate();
      fail();
    } catch (IllegalStateException expected) {}
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2013 Google Inc.
 * Copyright (C) 2013 Square Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger;

import dagger.internal.TestingLoader;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import javax.inject.Inject;
import javax.inject.Singleton;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static dagger.Provides.Type.SET;
import static org.fest.assertions.Assertions.assertThat;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

@RunWith(JUnit4.class)
public final class ExtensionWithSetBindingsTest {
  private static final AtomicInteger counter = new AtomicInteger(0);

  @Singleton
  static class RealSingleton {
    @Inject Set<Integer> ints;
  }

  @Singleton
  static class Main {
    @Inject Set<Integer> ints;
  }

  @Module(injects = RealSingleton.class)
  static class RootModule {
    @Provides(type=SET) @Singleton Integer provideA() { return counter.getAndIncrement(); }
    @Provides(type=SET) @Singleton Integer provideB() { return counter.getAndIncrement(); }
  }

  @Module(addsTo = RootModule.class, injects = Main.class )
  static class ExtensionModule {
    @Provides(type=SET) @Singleton Integer provideC() { return counter.getAndIncrement(); }
    @Provides(type=SET) @Singleton Integer provideD() { return counter.getAndIncrement(); }
  }

  @Module
  static class EmptyModule {
  }

  @Module(library = true)
  static class DuplicateModule {
    @Provides @Singleton String provideFoo() { return "foo"; }
    @Provides @Singleton String provideBar() { return "bar"; }
  }

  @Test public void basicInjectionWithExtension() {
    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
    RealSingleton rs = root.get(RealSingleton.class);
    assertThat(rs.ints).containsOnly(0, 1);

    ObjectGraph extension = root.plus(new ExtensionModule());
    Main main = extension.get(Main.class);
    assertThat(main.ints).containsOnly(0, 1, 2, 3);

    // Second time around.
    ObjectGraph extension2 = root.plus(new ExtensionModule());
    Main main2 = extension2.get(Main.class);
    assertThat(main2.ints).containsOnly(0, 1, 4, 5);
  }

  @Module(includes = ExtensionModule.class, overrides = true)
  static class TestModule {
    @Provides(type=SET) @Singleton Integer provide9999() { return 9999; }
  }

  @Test public void basicInjectionWithExtensionAndOverrides() {
    try {
      ObjectGraph.createWith(new TestingLoader(), new RootModule()).plus(new TestModule());
      fail("Should throw exception.");
    } catch (IllegalArgumentException e) {
      assertEquals("TestModule: Module overrides cannot contribute set bindings.", e.getMessage());
    }
  }

  @Test public void duplicateBindingsInSecondaryModule() {
    try {
      ObjectGraph.createWith(new TestingLoader(), new EmptyModule(), new DuplicateModule());
      fail("Should throw exception.");
    } catch (IllegalArgumentException e) {
      assertTrue(e.getMessage().startsWith("DuplicateModule: Duplicate"));
    }
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/main/java/dagger/internal/codegen/Util.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2013 Google, Inc.
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal.codegen;

import dagger.internal.Keys;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.AnnotationValue;
import javax.lang.model.element.AnnotationValueVisitor;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.ArrayType;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.ErrorType;
import javax.lang.model.type.PrimitiveType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.type.TypeVariable;
import javax.lang.model.util.SimpleAnnotationValueVisitor6;
import javax.lang.model.util.SimpleTypeVisitor6;

/**
 * Utilities for handling types in annotation processors
 */
final class Util {
  private Util() {
  }

  public static PackageElement getPackage(Element type) {
    while (type.getKind() != ElementKind.PACKAGE) {
      type = type.getEnclosingElement();
    }
    return (PackageElement) type;
  }

  /**
   * Returns the supertype, or {@code null} if the supertype is a platform
   * class. This is intended for annotation processors that assume platform
   * classes will never be annotated with application annotations.
   */
  public static TypeMirror getApplicationSupertype(TypeElement type) {
    TypeMirror supertype = type.getSuperclass();
    return Keys.isPlatformType(supertype.toString()) ? null : supertype;
  }

  /** Returns a fully qualified class name to complement {@code type}. */
  public static String adapterName(TypeElement typeElement, String suffix) {
    StringBuilder builder = new StringBuilder();
    rawTypeToString(builder, typeElement, '$');
    builder.append(suffix);
    return builder.toString();
  }

  /** Returns a string for {@code type}. Primitive types are always boxed. */
  public static String typeToString(TypeMirror type) {
    StringBuilder result = new StringBuilder();
    typeToString(type, result, '.');
    return result.toString();
  }

  /** Returns a string for the raw type of {@code type}. Primitive types are always boxed. */
  public static String rawTypeToString(TypeMirror type, char innerClassSeparator) {
    if (!(type instanceof DeclaredType)) {
      throw new IllegalArgumentException("Unexpected type: " + type);
    }
    StringBuilder result = new StringBuilder();
    DeclaredType declaredType = (DeclaredType) type;
    rawTypeToString(result, (TypeElement) declaredType.asElement(), innerClassSeparator);
    return result.toString();
  }

  /**
   * Appends a string for {@code type} to {@code result}. Primitive types are
   * always boxed.
   *
   * @param innerClassSeparator either '.' or '$', which will appear in a
   *     class name like "java.lang.Map.Entry" or "java.lang.Map$Entry".
   *     Use '.' for references to existing types in code. Use '$' to define new
   *     class names and for strings that will be used by runtime reflection.
   */
  public static void typeToString(final TypeMirror type, final StringBuilder result,
      final char innerClassSeparator) {
    type.accept(new SimpleTypeVisitor6<Void, Void>() {
      @Override public Void visitDeclared(DeclaredType declaredType, Void v) {
        TypeElement typeElement = (TypeElement) declaredType.asElement();
        rawTypeToString(result, typeElement, innerClassSeparator);
        List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
        if (!typeArguments.isEmpty()) {
          result.append("<");
          for (int i = 0; i < typeArguments.size(); i++) {
            if (i != 0) {
              result.append(", ");
            }
            typeToString(typeArguments.get(i), result, innerClassSeparator);
          }
          result.append(">");
        }
        return null;
      }
      @Override public Void visitPrimitive(PrimitiveType primitiveType, Void v) {
        result.append(box((PrimitiveType) type).getName());
        return null;
      }
      @Override public Void visitArray(ArrayType arrayType, Void v) {
        TypeMirror type = arrayType.getComponentType();
        if (type instanceof PrimitiveType) {
          result.append(type.toString()); // Don't box, since this is an array.
        } else {
          typeToString(arrayType.getComponentType(), result, innerClassSeparator);
        }
        result.append("[]");
        return null;
      }
      @Override public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
        result.append(typeVariable.asElement().getSimpleName());
        return null;
      }
      @Override public Void visitError(ErrorType errorType, Void v) {
        // Error type found, a type may not yet have been generated, but we need the type
        // so we can generate the correct code in anticipation of the type being available
        // to the compiler.

        // Paramterized types which don't exist are returned as an error type whose name is "<any>"
        if ("<any>".equals(errorType.toString())) {
          throw new CodeGenerationIncompleteException(
              "Type reported as <any> is likely a not-yet generated parameterized type.");
        }
        // TODO(cgruber): Figure out a strategy for non-FQCN cases.
        result.append(errorType.toString());
        return null;
      }
      @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {
        throw new UnsupportedOperationException(
            "Unexpected TypeKind " + typeMirror.getKind() + " for "  + typeMirror);
      }
    }, null);
  }

  private static final AnnotationValueVisitor<Object, Void> VALUE_EXTRACTOR =
      new SimpleAnnotationValueVisitor6<Object, Void>() {
        @Override public Object visitString(String s, Void p) {
          if ("<error>".equals(s)) {
            throw new CodeGenerationIncompleteException("Unknown type returned as <error>.");
          } else if ("<any>".equals(s)) {
            throw new CodeGenerationIncompleteException("Unknown type returned as <any>.");
          }
          return s;
        }
        @Override public Object visitType(TypeMirror t, Void p) {
          return t;
        }
        @Override protected Object defaultAction(Object o, Void v) {
          return o;
        }
        @Override public Object visitArray(List<? extends AnnotationValue> values, Void v) {
          Object[] result = new Object[values.size()];
          for (int i = 0; i < values.size(); i++) {
            result[i] = values.get(i).accept(this, null);
          }
          return result;
        }
      };

  /**
   * Returns the annotation on {@code element} formatted as a Map. This returns
   * a Map rather than an instance of the annotation interface to work-around
   * the fact that Class and Class[] fields won't work at code generation time.
   * See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5089128
   */
  public static Map<String, Object> getAnnotation(Class<?> annotationType, Element element) {
    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
      if (!rawTypeToString(annotation.getAnnotationType(), '$')
          .equals(annotationType.getName())) {
        continue;
      }

      Map<String, Object> result = new LinkedHashMap<String, Object>();
      for (Method m : annotationType.getMethods()) {
        result.put(m.getName(), m.getDefaultValue());
      }
      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> e
          : annotation.getElementValues().entrySet()) {
        String name = e.getKey().getSimpleName().toString();
        Object value = e.getValue().accept(VALUE_EXTRACTOR, null);
        Object defaultValue = result.get(name);
        if (!lenientIsInstance(defaultValue.getClass(), value)) {
          throw new IllegalStateException(String.format(
              "Value of %s.%s is a %s but expected a %s\n    value: %s",
              annotationType, name, value.getClass().getName(), defaultValue.getClass().getName(),
              value instanceof Object[] ? Arrays.toString((Object[]) value) : value));
        }
        result.put(name, value);
      }
      return result;
    }
    return null; // Annotation not found.
  }

  /**
   * Returns true if {@code value} can be assigned to {@code expectedClass}.
   * Like {@link Class#isInstance} but more lenient for {@code Class<?>} values.
   */
  private static boolean lenientIsInstance(Class<?> expectedClass, Object value) {
    if (expectedClass.isArray()) {
      Class<?> componentType = expectedClass.getComponentType();
      if (!(value instanceof Object[])) {
        return false;
      }
      for (Object element : (Object[]) value) {
        if (!lenientIsInstance(componentType, element)) return false;
      }
      return true;
    } else if (expectedClass == Class.class) {
      return value instanceof TypeMirror;
    } else {
      return expectedClass == value.getClass();
    }
  }

  // TODO(sgoldfed): better format for other types of elements?
  static String elementToString(Element element) {
    switch (element.getKind()) {
      case FIELD:
      // fall through
      case CONSTRUCTOR:
      // fall through
      case METHOD:
        return element.getEnclosingElement() + "." + element;
      default:
        return element.toString();
    }
  }

  static void rawTypeToString(StringBuilder result, TypeElement type,
      char innerClassSeparator) {
    String packageName = getPackage(type).getQualifiedName().toString();
    String qualifiedName = type.getQualifiedName().toString();
    if (packageName.isEmpty()) {
        result.append(qualifiedName.replace('.', innerClassSeparator));
    } else {
      result.append(packageName);
      result.append('.');
      result.append(
          qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
    }
  }

  private static Class<?> box(PrimitiveType primitiveType) {
    switch (primitiveType.getKind()) {
      case BYTE:
        return Byte.class;
      case SHORT:
        return Short.class;
      case INT:
        return Integer.class;
      case LONG:
        return Long.class;
      case FLOAT:
        return Float.class;
      case DOUBLE:
        return Double.class;
      case BOOLEAN:
        return Boolean.class;
      case CHAR:
        return Character.class;
      case VOID:
        return Void.class;
      default:
        throw new AssertionError();
    }
  }

  /**
   * Returns the no-args constructor for {@code type}, or null if no such
   * constructor exists.
   */
  public static ExecutableElement getNoArgsConstructor(TypeElement type) {
    for (Element enclosed : type.getEnclosedElements()) {
      if (enclosed.getKind() != ElementKind.CONSTRUCTOR) {
        continue;
      }
      ExecutableElement constructor = (ExecutableElement) enclosed;
      if (constructor.getParameters().isEmpty()) {
        return constructor;
      }
    }
    return null;
  }

  /**
   * Returns true if generated code can invoke {@code constructor}. That is, if
   * the constructor is non-private and its enclosing class is either a
   * top-level class or a static nested class.
   */
  public static boolean isCallableConstructor(ExecutableElement constructor) {
    if (constructor.getModifiers().contains(Modifier.PRIVATE)) {
      return false;
    }
    TypeElement type = (TypeElement) constructor.getEnclosingElement();
    return type.getEnclosingElement().getKind() == ElementKind.PACKAGE
        || type.getModifiers().contains(Modifier.STATIC);
  }


  /**
   * Returns a user-presentable string like {@code coffee.CoffeeModule}.
   */
  public static String className(ExecutableElement method) {
    return ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();
  }

  public static boolean isInterface(TypeMirror typeMirror) {
    return typeMirror instanceof DeclaredType
        && ((DeclaredType) typeMirror).asElement().getKind() == ElementKind.INTERFACE;
  }

  static boolean isStatic(Element element) {
    for (Modifier modifier : element.getModifiers()) {
      if (modifier.equals(Modifier.STATIC)) {
        return true;
      }
    }
    return false;
  }

  /**
   * An exception thrown when a type is not extant (returns as an error type),
   * usually as a result of another processor not having yet generated its types upon
   * which a dagger-annotated type depends.
   */
  final static class CodeGenerationIncompleteException extends IllegalStateException {
    public CodeGenerationIncompleteException(String s) {
      super(s);
    }
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java;<<<<<<< MINE
=======

  /** A Comparator for Bindings so we can insure a consistent ordering of output. */
  private static class BindingComparator implements Comparator<Binding<?>> {
    @Override
    public int compare(Binding<?> left, Binding<?> right) {
      return getStringForBinding(left).compareTo(getStringForBinding(right));
    }

    private String getStringForBinding(Binding<?> binding) {
      return binding == null ? "" : binding.toString();
    }
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2013 Google, Inc.
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal.codegen;

import dagger.Module;
import dagger.Provides;
import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.inject.Inject;
import javax.inject.Qualifier;
import javax.inject.Scope;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;

import static dagger.internal.codegen.Util.elementToString;
import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
import static javax.lang.model.element.ElementKind.METHOD;
import static javax.lang.model.element.Modifier.ABSTRACT;

/**
 * Checks for errors that are not directly related to modules and
 *  {@code @Inject} annotated elements.
 *
 *  <p> Warnings for invalid use of qualifier annotations can be suppressed
 *  with @SuppressWarnings("qualifiers")
 *
 *  <p> Warnings for invalid use of scoping annotations can be suppressed
 *  with @SuppressWarnings("scoping")
 */
@SupportedAnnotationTypes({ "*" })
public final class ValidationProcessor extends AbstractProcessor {

  @Override public SourceVersion getSupportedSourceVersion() {
    return SourceVersion.latestSupported();
  }

  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
    List<Element> allElements = new ArrayList<Element>();
    Map<Element, Element> parametersToTheirMethods = new LinkedHashMap<Element, Element>();
    getAllElements(env, allElements, parametersToTheirMethods);
    for (Element element : allElements) {
      try {
        validateProvides(element);
      } catch (CodeGenerationIncompleteException e) {
        continue; // Upstream compiler issue in play. Ignore this element.
      }
      validateScoping(element);
      validateQualifiers(element, parametersToTheirMethods);
    }
    return false;
  }

  private void validateProvides(Element element) {
    if (element.getAnnotation(Provides.class) != null
        && Util.getAnnotation(Module.class, element.getEnclosingElement()) == null) {
      error("@Provides methods must be declared in modules: " + elementToString(element), element);
    }
  }

  private void validateQualifiers(Element element, Map<Element, Element> parametersToTheirMethods) {
    boolean suppressWarnings =
        element.getAnnotation(SuppressWarnings.class) != null && Arrays.asList(
            element.getAnnotation(SuppressWarnings.class).value()).contains("qualifiers");
    int numberOfQualifiersOnElement = 0;
    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
      if (annotation.getAnnotationType().asElement().getAnnotation(Qualifier.class) == null) {
       continue;
      }
      switch (element.getKind()) {
        case FIELD:
          numberOfQualifiersOnElement++;
          if (element.getAnnotation(Inject.class) == null && !suppressWarnings) {
            warning("Dagger will ignore qualifier annotations on fields that are not "
                + "annotated with @Inject: " + elementToString(element), element);
          }
          break;
        case METHOD:
          numberOfQualifiersOnElement++;
          if (!isProvidesMethod(element) && !suppressWarnings) {
            warning("Dagger will ignore qualifier annotations on methods that are not "
                + "@Provides methods: " + elementToString(element), element);
          }
          break;
        case PARAMETER:
          numberOfQualifiersOnElement++;
          if (!isInjectableConstructorParameter(element, parametersToTheirMethods)
              && !isProvidesMethodParameter(element, parametersToTheirMethods)
              && !suppressWarnings) {
            warning("Dagger will ignore qualifier annotations on parameters that are not "
                + "@Inject constructor parameters or @Provides method parameters: "
                + elementToString(element), element);
          }
          break;
        default:
          error("Qualifier annotations are only allowed on fields, methods, and parameters: "
              + elementToString(element), element);
      }
    }
    if (numberOfQualifiersOnElement > 1) {
      error("Only one qualifier annotation is allowed per element: " + elementToString(element),
          element);
    }
  }

  private void validateScoping(Element element) {
    boolean suppressWarnings =
        element.getAnnotation(SuppressWarnings.class) != null && Arrays.asList(
            element.getAnnotation(SuppressWarnings.class).value()).contains("scoping");
    int numberOfScopingAnnotationsOnElement = 0;
    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
      if (annotation.getAnnotationType().asElement().getAnnotation(Scope.class) == null) {
        continue;
      }
      switch (element.getKind()) {
        case METHOD:
          numberOfScopingAnnotationsOnElement++;
          if (!isProvidesMethod(element) && !suppressWarnings) {
            warning("Dagger will ignore scoping annotations on methods that are not "
                + "@Provides methods: " + elementToString(element), element);
          }
          break;
        case CLASS:
          if (!element.getModifiers().contains(ABSTRACT)) {
            numberOfScopingAnnotationsOnElement++;
            break;
          }
        // fall through if abstract
        default:
          error("Scoping annotations are only allowed on concrete types and @Provides methods: "
              + elementToString(element), element);
      }
    }
    if (numberOfScopingAnnotationsOnElement > 1) {
      error("Only one scoping annotation is allowed per element: " + elementToString(element),
          element);
    }
  }

  private void getAllElements(
      RoundEnvironment env, List<Element> result, Map<Element, Element> parametersToTheirMethods) {
    for (Element element : env.getRootElements()) {
      addAllEnclosed(element, result, parametersToTheirMethods);
    }
  }

  private void addAllEnclosed(
      Element element, List<Element> result, Map<Element, Element> parametersToTheirMethods) {
    result.add(element);
    for (Element enclosed : element.getEnclosedElements()) {
      addAllEnclosed(enclosed, result, parametersToTheirMethods);
      if (enclosed.getKind() == METHOD || enclosed.getKind() == CONSTRUCTOR) {
        for (Element parameter : ((ExecutableElement) enclosed).getParameters()) {
          result.add(parameter);
          parametersToTheirMethods.put(parameter, enclosed);
        }
      }
    }
  }

  private boolean isProvidesMethod(Element element) {
    return element.getKind() == METHOD && element.getAnnotation(Provides.class) != null;
  }

  /**
   * @param parameter an {@code Element} whose {@code Kind} is parameter. The {@code Kind} is not
   *        tested here.
   */
  private boolean isProvidesMethodParameter(
      Element parameter, Map<Element, Element> parametersToTheirMethods) {
    return parametersToTheirMethods.get(parameter).getAnnotation(Provides.class) != null;
  }

  /**
   * @param parameter an {@code Element} whose {@code Kind} is parameter. The {@code Kind} is not
   *        tested here.
   */
  private boolean isInjectableConstructorParameter(
      Element parameter, Map<Element, Element> parametersToTheirMethods) {
    return parametersToTheirMethods.get(parameter).getKind() == CONSTRUCTOR
        && parametersToTheirMethods.get(parameter).getAnnotation(Inject.class) != null;
  }

  private void error(String msg, Element element) {
    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, element);
  }

  private void warning(String msg, Element element) {
    processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, msg, element);
  }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java;<<<<<<< MINE
  static class ProviderMethodBinding extends Binding<Object> {
=======
  static class ProviderMethodBinding extends ProvidesBinding<Object> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/test/java/dagger/tests/integration/ProcessorTestUtils.java;<<<<<<< MINE
=======
/*
 * Copyright (c) 2013 Google, Inc.
 * Copyright (c) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.tests.integration;

import dagger.internal.codegen.GraphAnalysisProcessor;
import dagger.internal.codegen.InjectAdapterProcessor;
import dagger.internal.codegen.ModuleAdapterProcessor;
import dagger.internal.codegen.ValidationProcessor;
import java.util.Arrays;
import javax.annotation.processing.Processor;

/**
 * Internal test utilities.
 */
public class ProcessorTestUtils {
  public static Iterable<? extends Processor> daggerProcessors() {
    return Arrays.asList(
        new InjectAdapterProcessor(),
        new ModuleAdapterProcessor(),
        new GraphAnalysisProcessor(),
        new ValidationProcessor());
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java;<<<<<<< MINE
=======
/**
 * Copyright (C) 2013 Google, Inc.
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.tests.integration.operation;

import dagger.Module;
import dagger.ObjectGraph;
import dagger.Provides;
import javax.inject.Inject;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static org.fest.assertions.Assertions.assertThat;

@RunWith(JUnit4.class)
public final class PrimitiveInjectionTest {
  static class ArrayInjectable {
    @Inject byte[] byteArray;
    @Inject int[] integerArray;
    @Inject boolean[] booleanArray;
    @Inject char[] charArray;
    @Inject long[] longArray;
    @Inject float[] floatArray;
    @Inject double[] doubleArray;
  }

  @Module(injects = ArrayInjectable.class)
  static class PrimitiveArrayModule {
    @Provides byte[] byteArray() { return new byte[] { Byte.MAX_VALUE }; }
    @Provides int[] provideInt() { return new int[] { Integer.MAX_VALUE }; }
    @Provides boolean[] provideBoolean() { return new boolean[] { true }; }
    @Provides long[] provideLong() { return new long[] { Long.MAX_VALUE }; }
    @Provides char[] provideChar() { return new char[] { Character.MAX_VALUE }; }
    @Provides float[] provideFloat() { return new float[] { Float.MAX_VALUE }; }
    @Provides double[] provideDouble() { return new double[] { Double.MAX_VALUE }; }
  }

  @Test public void primitiveArrayTypesAllInjected() {
    ArrayInjectable result = ObjectGraph.create(PrimitiveArrayModule.class)
        .get(ArrayInjectable.class);
    assertThat(result).isNotNull();
    assertThat(result.byteArray).isEqualTo(new byte[] { Byte.MAX_VALUE });
    assertThat(result.integerArray).isEqualTo(new int[] { Integer.MAX_VALUE });
    assertThat(result.booleanArray).isEqualTo(new boolean[] { true });
    assertThat(result.charArray).isEqualTo(new char[] { Character.MAX_VALUE });
    assertThat(result.longArray).isEqualTo(new long[] { Long.MAX_VALUE });
    assertThat(result.floatArray).isEqualTo(new float[] { Float.MAX_VALUE });
    assertThat(result.doubleArray).isEqualTo(new double[] { Double.MAX_VALUE });
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java;<<<<<<< MINE
=======
/**
 * Copyright (C) 2013 Google, Inc.
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.tests.integration.operation;

import dagger.Module;
import dagger.ObjectGraph;
import dagger.Provides;
import javax.inject.Inject;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static org.truth0.Truth.ASSERT;

@RunWith(JUnit4.class)
public final class SimpleInjectionTest {
  static abstract class AbstractFoo {
    @Inject String blah;
  }

  static class Foo extends AbstractFoo { }

  @Module(injects = Foo.class)
  static class FooModule {
    @Provides String string() { return "blah"; }
  }

  @Module(injects = Foo.class)
  static class ProvidingFooModule {
    @Provides String string() { return "blah"; }
    @Provides Foo foo(String blah) {
      Foo foo = new Foo();
      foo.blah = blah;
      return foo;
    }
  }

  @Test public void memberInject_WithoutProvidesMethod() {
    Foo foo = new Foo();
    ObjectGraph.create(FooModule.class).inject(foo);
    ASSERT.that(foo.blah).equals("blah");
  }

  @Test public void membersInject_WithProvidesMethod() {
    Foo foo = new Foo();
    ObjectGraph.create(ProvidingFooModule.class).inject(foo);
    ASSERT.that(foo.blah).equals("blah");
  }

  @Test public void get_WithProvidesMethod() {
    Foo foo = ObjectGraph.create(ProvidingFooModule.class).get(Foo.class);
    ASSERT.that(foo.blah).equals("blah");
  }

  static class Bar { }

  @Module(injects = Bar.class)
  static class BarModule {
  }

  @Test public void membersInject_WithNonInjectable() {
    Bar bar = new Bar();
    ObjectGraph.create(BarModule.class).inject(bar);
  }

  @Module(injects = Bar.class)
  static class ProvidingBarModule {
    @Provides public Bar bar() { return new Bar(); }
  }

  @Test public void membersInject_WithProvidedNonInjectable() {
    Bar bar = ObjectGraph.create(ProvidingBarModule.class).get(Bar.class);
    ASSERT.that(bar).isNotNull();
  }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2013 Google Inc.
 * Copyright (C) 2013 Square Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.tests.integration.codegen;

import com.google.common.base.Joiner;
import com.google.testing.compile.JavaFileObjects;
import javax.tools.JavaFileObject;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
import static org.truth0.Truth.ASSERT;

@RunWith(JUnit4.class)
public final class InjectAdapterGenerationTest {
  @Test public void basicInjectAdapter() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Basic", Joiner.on("\n").join(
        "import dagger.Module;",
        "import javax.inject.Inject;",
        "class Basic {",
        "  static class A { @Inject A() { } }",
        "  @Module(injects = A.class)",
        "  static class AModule { }",
        "}"));

    JavaFileObject expectedModuleAdapter =
        JavaFileObjects.forSourceString("Basic$AModule$$ModuleAdapter", Joiner.on("\n").join(
            "import dagger.internal.ModuleAdapter;",
            "public final class Basic$AModule$$ModuleAdapter",
            "    extends ModuleAdapter<Basic.AModule> {",
            "  private static final String[] INJECTS = {\"members/Basic$A\"};",
            "  private static final Class<?>[] STATIC_INJECTIONS = {};",
            "  private static final Class<?>[] INCLUDES = {};",
            "  public Basic$AModule$$ModuleAdapter() {",
            "    super(Basic.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES,",
            "      true, false);",
            "  }",
            "  @Override public Basic.AModule newModule() {",
            "    return new Basic.AModule();",
            "  }",
            "}"));

    JavaFileObject expectedInjectAdapter =
        JavaFileObjects.forSourceString("Basic$A$$InjectAdapter", Joiner.on("\n").join(
            "import dagger.internal.Binding;",
            "import javax.inject.Provider;",
            "public final class Basic$A$$InjectAdapter",
            "    extends Binding<Basic.A> implements Provider<Basic.A> {",
            "  public Basic$A$$InjectAdapter() {",
            "    super(\"Basic$A\", \"members/Basic$A\", NOT_SINGLETON, Basic.A.class);",
            "  }",
            "  @Override public Basic.A get() {",
            "    Basic.A result = new Basic.A();",
            "    return result;",
            "  }",
            "}"));

    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
        .compilesWithoutError().and()
        .generatesSources(expectedModuleAdapter, expectedInjectAdapter);

  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2013 Google Inc.
 * Copyright (C) 2013 Square Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.tests.integration.codegen;

import com.google.common.base.Joiner;
import com.google.testing.compile.JavaFileObjects;
import javax.tools.JavaFileObject;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
import static java.util.Arrays.asList;
import static org.truth0.Truth.ASSERT;

@RunWith(JUnit4.class)
public final class ModuleAdapterGenerationTest {
  /**
   * Shows current behavior for a {@link dagger.Provides provides method}
   * used to supply an injected ctor parameter.
   *
   * <ul>
   *   <li>{@code ProvidesAdapter} invokes the module's provides method on
   *   {@code get}</li>
   *   <li>On {@code getBindings}, the above is newed up and linked to its type
   *   key.
   *   <li>{@code InjectAdapter} contains a field for the parameter binding,
   *   referenced in {@code getDependencies} and set on {@code attach}</li>
   *   <li>On {@code get}, the injected constructor is called with the value of
   *   {@link dagger.internal.Binding#get}</li>
   * </ul>
   */
  @Test public void providerForCtorInjection() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import javax.inject.Inject;",
        "class Field {",
        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
        "  @Module(injects = { A.class, String.class })",
        "  static class AModule { @Provides String name() { return \"foo\"; }}",
        "}"));

    JavaFileObject expectedModuleAdapter =
        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
        "import dagger.internal.BindingsGroup;",
        "import dagger.internal.ModuleAdapter;",
        "import dagger.internal.ProvidesBinding;",
        "import javax.inject.Provider;",
        "public final class Field$AModule$$ModuleAdapter",
        "    extends ModuleAdapter<Field.AModule> {",
        "  private static final String[] INJECTS = ",
        "      {\"members/Field$A\", \"members/java.lang.String\"};",
        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
        "  private static final Class<?>[] INCLUDES = {};",
        "  public Field$AModule$$ModuleAdapter() {",
        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
        "  }",
        "  @Override public Field.AModule newModule() {",
        "    return new Field.AModule();",
        "  }",
        "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {",
        "    bindings.contributeProvidesBinding(\"java.lang.String\",",
        "        new NameProvidesAdapter(module));", // eager new!
        "  }",
        "  public static final class NameProvidesAdapter", // corresponds to method name
        "      extends ProvidesBinding<String> implements Provider<String> {",
        "    private final Field.AModule module;",
        "    public NameProvidesAdapter(Field.AModule module) {",
        "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
        "      this.module = module;",
        "      setLibrary(false);",
        "    }",
        "    @Override public String get() {",
        "      return module.name();", // corresponds to @Provides method
        "    }",
        "  }",
        "}"));

    JavaFileObject expectedInjectAdapter =
        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
            "import dagger.internal.Binding;",
            "import dagger.internal.Linker;",
            "import java.util.Set;",
            "import javax.inject.Provider;",
            "public final class Field$A$$InjectAdapter",
            "    extends Binding<Field.A> implements Provider<Field.A> {",
            "  private Binding<String> name;", // for ctor
            "  public Field$A$$InjectAdapter() {",
            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
            "  }",
            "  @Override @SuppressWarnings(\"unchecked\")",
            "  public void attach(Linker linker) {",
            "    name = (Binding<String>)linker.requestBinding(", // binding key is not a class
            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
            "  }",
            "  @Override public void getDependencies(",
            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
            "    getBindings.add(name);", // name is added to dependencies
            "  }",
            "  @Override public Field.A get() {",
            "    Field.A result = new Field.A(name.get());", // adds ctor param
            "    return result;",
            "  }",
            "}"));

    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
        .compilesWithoutError()
        .and()
        .generatesSources(expectedModuleAdapter, expectedInjectAdapter);

  }

  @Test public void injectsMembersInjectedAndProvidedAndConstructedTypes() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import javax.inject.Inject;",
        "class Field {",
        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
        "  static class B { @Inject String name; }",
        "  @Module(injects = { A.class, String.class, B.class })",
        "  static class AModule { @Provides String name() { return \"foo\"; }}",
        "}"));

    JavaFileObject expectedModuleAdapter =
        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
        "import dagger.internal.BindingsGroup;",
        "import dagger.internal.ModuleAdapter;",
        "import dagger.internal.ProvidesBinding;",
        "import javax.inject.Provider;",
        "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {",
        "  private static final String[] INJECTS = ",
        "      {\"members/Field$A\", \"members/java.lang.String\", \"members/Field$B\"};",
        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
        "  private static final Class<?>[] INCLUDES = {};",
        "  public Field$AModule$$ModuleAdapter() {",
        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
        "  }",
        "  @Override public Field.AModule newModule() {",
        "    return new Field.AModule();",
        "  }",
        "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {",
        "    bindings.contributeProvidesBinding(\"java.lang.String\",",
        "        new NameProvidesAdapter(module));", // eager new!
        "  }",
        "  public static final class NameProvidesAdapter", // corresponds to method name
        "      extends ProvidesBinding<String> implements Provider<String> {",
        "    private final Field.AModule module;",
        "    public NameProvidesAdapter(Field.AModule module) {",
        "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
        "      this.module = module;",
        "      setLibrary(false);",
        "    }",
        "    @Override public String get() {",
        "      return module.name();", // corresponds to @Provides method
        "    }",
        "  }",
        "}"));

    JavaFileObject expectedInjectAdapterA =
        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
            "import dagger.internal.Binding;",
            "import dagger.internal.Linker;",
            "import java.util.Set;",
            "import javax.inject.Provider;",
            "public final class Field$A$$InjectAdapter",
            "    extends Binding<Field.A> implements Provider<Field.A> {",
            "  private Binding<String> name;", // For Constructor.
            "  public Field$A$$InjectAdapter() {",
            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
            "  }",
            "  @Override @SuppressWarnings(\"unchecked\")",
            "  public void attach(Linker linker) {",
            "    name = (Binding<String>)linker.requestBinding(",
            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
            "  }",
            "  @Override public void getDependencies(",
            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
            "    getBindings.add(name);", // Name is added to dependencies.
            "  }",
            "  @Override public Field.A get() {",
            "    Field.A result = new Field.A(name.get());", // Adds constructor parameter.
            "    return result;",
            "  }",
            "}"));

    JavaFileObject expectedInjectAdapterB =
        JavaFileObjects.forSourceString("Field$B$$InjectAdapter", Joiner.on("\n").join(
            "import dagger.MembersInjector;",
            "import dagger.internal.Binding;",
            "import dagger.internal.Linker;",
            "import java.util.Set;",
            "import javax.inject.Provider;",
            "public final class Field$B$$InjectAdapter",
            "    extends Binding<Field.B> implements Provider<Field.B>, MembersInjector<Field.B> {",
            "  private Binding<String> name;", // For field.
            "  public Field$B$$InjectAdapter() {",
            "    super(\"Field$B\", \"members/Field$B\", NOT_SINGLETON, Field.B.class);",
            "  }",
            "  @Override @SuppressWarnings(\"unchecked\")",
            "  public void attach(Linker linker) {",
            "    name = (Binding<String>)linker.requestBinding(",
            "      \"java.lang.String\", Field.B.class, getClass().getClassLoader());",
            "  }",
            "  @Override public void getDependencies(",
            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
            "    injectMembersBindings.add(name);", // Name is added to dependencies.
            "  }",
            "  @Override public Field.B get() {",
            "    Field.B result = new Field.B();",
            "    injectMembers(result);",
            "    return result;",
            "  }",
            "  @Override public void injectMembers(Field.B object) {",
            "    object.name = name.get();", // Inject field.
            "  }",
            "}"));
    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
        .compilesWithoutError()
        .and()
        .generatesSources(expectedModuleAdapter, expectedInjectAdapterA, expectedInjectAdapterB);
  }


  @Test public void providesHasParameterNamedModule() {
    JavaFileObject a = JavaFileObjects.forSourceString("A", Joiner.on("\n").join(
        "import javax.inject.Inject;",
        "class A { @Inject A(){ }}"));
    JavaFileObject b = JavaFileObjects.forSourceString("B", Joiner.on("\n").join(
        "import javax.inject.Inject;",
        "class B { @Inject B(){ }}"));

    JavaFileObject module = JavaFileObjects.forSourceString("BModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import javax.inject.Inject;",
        "@Module(injects = B.class)",
        "class BModule { @Provides B b(A module) { return new B(); }}"));

    ASSERT.about(javaSources()).that(asList(a, b, module)).processedWith(daggerProcessors())
        .compilesWithoutError();
  }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java;<<<<<<< MINE
=======
/**
 * Copyright (c) 2013 Google, Inc.
 * Copyright (c) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.tests.integration.validation;

import com.google.common.base.Joiner;
import com.google.testing.compile.JavaFileObjects;
import javax.tools.JavaFileObject;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
import static org.truth0.Truth.ASSERT;

@RunWith(JUnit4.class)
public class CyclicModuleIncludesTest {
  private final JavaFileObject javaFile =
      JavaFileObjects.forSourceString("CyclicModules", Joiner.on("\n").join(
          "import dagger.Module;",
          "class CyclicModules {",
          "  @Module(includes = SelfReferencingModule.class)",
          "  static class SelfReferencingModule { }",
          "  @Module(includes = Spock.class)",
          "  static class Rock {}",
          "  @Module(includes = Rock.class)",
          "  static class Paper {}",
          "  @Module(includes = Paper.class)",
          "  static class Scissors {}",
          "  @Module(includes = Scissors.class)",
          "  static class Lizard {}",
          "  @Module(includes = Lizard.class)",
          "  static class Spock {}",
          "}"));

  @Test public void cyclicModuleSelfIncludes() {
    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
        .withErrorContaining("CyclicModules.SelfReferencingModule includes itself directly")
            .in(javaFile).onLine(4);
  }

  @Test public void cyclicModuleIncludes_full_cycle() {
    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
        .withErrorContaining("0. CyclicModules.Rock included by CyclicModules.Paper")
            .in(javaFile).onLine(6).and()
        .withErrorContaining("1. CyclicModules.Paper included by CyclicModules.Scissors")
            .in(javaFile).onLine(6).and()
        .withErrorContaining("2. CyclicModules.Scissors included by CyclicModules.Lizard")
            .in(javaFile).onLine(6).and()
        .withErrorContaining("3. CyclicModules.Lizard included by CyclicModules.Spock")
            .in(javaFile).onLine(6).and()
        .withErrorContaining("4. CyclicModules.Spock included by CyclicModules.Rock")
            .in(javaFile).onLine(6);
  }

  @Test public void cyclicModuleIncludes_initial_inclusion() {
    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
        .withErrorContaining("0. CyclicModules.Rock included by CyclicModules.Paper")
            .in(javaFile).onLine(6).and()
        .withErrorContaining("0. CyclicModules.Paper included by CyclicModules.Scissors")
            .in(javaFile).onLine(8).and()
        .withErrorContaining("0. CyclicModules.Scissors included by CyclicModules.Lizard")
            .in(javaFile).onLine(10).and()
        .withErrorContaining("0. CyclicModules.Lizard included by CyclicModules.Spock")
            .in(javaFile).onLine(12).and()
        .withErrorContaining("0. CyclicModules.Spock included by CyclicModules.Rock")
            .in(javaFile).onLine(14);
  }


}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java;<<<<<<< MINE
=======
/**
 * Copyright (c) 2013 Google, Inc.
 * Copyright (c) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.tests.integration.validation;

import com.google.common.base.Joiner;
import com.google.testing.compile.JavaFileObjects;
import java.io.IOException;
import java.io.Writer;
import java.util.Set;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.TypeElement;
import javax.tools.JavaFileObject;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static com.google.common.collect.Iterables.concat;
import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
import static java.util.Arrays.asList;
import static org.truth0.Truth.ASSERT;

/**
 * Tests that the annotation processor(s) will properly handle the case where
 * code they are processing and depending on is generated by other processors
 * in the environment, and so the types they need may not exist yet.
 */
@RunWith(JUnit4.class)
public class GeneratedTypesNotReadyTest {
  private final JavaFileObject foo = JavaFileObjects.forSourceString("Foo", Joiner.on("\n").join(
      "package myPackage;",
      "public interface Foo {}"
  ));
  private final JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
      "import javax.inject.Inject;",
      "import myPackage.Foo;",
      "class Main {",
      "  @Inject Foo f;",
      "}"));

  @Test public void withstandsMissingTypeReferencedInInjects() {
    // TODO(cgruber): remove Foo (interface) from this when injects= analysis is fixed.
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import myPackage.Foo;",
        "@Module(injects = { Main.class, myPackage.FooImpl.class })",
        "class FooModule {",
        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
        "    return impl;",
        "  }",
        "}"));

    ASSERT.about(javaSources()).that(asList(foo, main, module))
        .processedWith(concat(asList(new FooImplGenerator()), daggerProcessors()))
        .compilesWithoutError();
  }

  @Test public void withstandsMissingTypeReferencedInsideModule() {
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import myPackage.Foo;",
        "@Module(injects = { Main.class })",
        "class FooModule {",
        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
        "    return impl;",
        "  }",
        "}"));

    ASSERT.about(javaSources()).that(asList(foo, module, main))
        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
        .compilesWithoutError();
  }

  @Test public void withstandsMissingTypeReferencedByProvidesReturnType() {
    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
        "import javax.inject.Inject;",
        "class Main {",
        "  @Inject myPackage.FooImpl f;",
        "}"));
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "@Module(injects = { Main.class })",
        "class FooModule {",
        "  @Provides myPackage.FooImpl provideFoo() {",
        "    return new myPackage.FooImpl();",
        "  }",
        "}"));

    ASSERT.about(javaSources()).that(asList(foo, module, main))
        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
        .compilesWithoutError();
  }

  @Test public void failsWhenMissingGenericTypeReferencedByProvidesReturnType() {
    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
        "import javax.inject.Inject;",
        "class Main {",
        "  @Inject myPackage.FooImpl2<String> f;",
        "}"));
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "@Module(injects = { Main.class })",
        "class FooModule {",
        "  @Provides myPackage.FooImpl2<String> provideFoo() {",
        "    return new myPackage.FooImpl2<String>();",
        "  }",
        "}"));

    ASSERT.about(javaSources()).that(asList(foo, module, main))
        .processedWith(new FooImplGenerator())
        .compilesWithoutError();
    ASSERT.about(javaSources()).that(asList(foo, module, main))
        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
        .failsToCompile()
        .withErrorContaining("Could not find types required by provides methods for [FooModule]");
  }

  @Test public void withstandsMissingTypeReferencedInTransitiveJITDependency() {
    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
        "import javax.inject.Inject;",
        "import myPackage.FooImpl;",
        "class Main {",
        "  @Inject FooImpl f;",
        "}"));
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "@Module(injects = { Main.class })",
        "class FooModule {",
        "}"));

    ASSERT.about(javaSources()).that(asList(foo, module, main))
        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
        .compilesWithoutError();
  }

  @Test public void verifyFooImplGeneratorIsCompilingWithoutDagger() {
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import myPackage.Foo;",
        "@Module(injects = { Main.class })",
        "class FooModule {",
        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
        "    return impl;",
        "  }",
        "}"));
    ASSERT.about(javaSources()).that(asList(foo, module, main))
        .processedWith(new FooImplGenerator())
        .compilesWithoutError();
  }

  @SupportedAnnotationTypes("*")
  private final class FooImplGenerator extends AbstractProcessor {
    boolean written = false;
    @Override public boolean process(Set<? extends TypeElement> na1, RoundEnvironment na2) {
      if (!written) {
        try {
          JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile("FooImpl");
          Writer writer = sourceFile.openWriter();
          writer.write(Joiner.on("\n").join(
              "package myPackage;",
              "import javax.inject.Inject;",
              "public final class FooImpl implements Foo {",
              "  @Inject public FooImpl() { }",
              "}"));
          writer.close();
          sourceFile = processingEnv.getFiler().createSourceFile("FooImpl2");
          writer = sourceFile.openWriter();
          writer.write(Joiner.on("\n").join(
              "package myPackage;",
              "import javax.inject.Inject;",
              "public final class FooImpl2<T> implements Foo {",
              "  @Inject public FooImpl2() { }",
              "}"));
          writer.close();
          written = true;
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
      return false;
    }

    @Override public SourceVersion getSupportedSourceVersion() {
      return SourceVersion.latestSupported();
    }
  }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java;<<<<<<< MINE
=======
/**
 * Copyright (C) 2013 Google, Inc.
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.tests.integration.validation;

import com.google.common.base.Joiner;
import com.google.testing.compile.JavaFileObjects;
import java.util.Arrays;
import javax.tools.JavaFileObject;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
import static org.truth0.Truth.ASSERT;

@RunWith(JUnit4.class)
public final class LibraryModuleTest {
  @Test public void unusedProviderMethodsPassOnLibrary() {
    JavaFileObject source = JavaFileObjects.forSourceString("Library", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import java.lang.Override;",
        "@Module(library = true)",
        "class TestModule {",
        "  @Provides String string() {",
        "    return \"string\";",
        "  }",
        "}"));
    ASSERT.about(javaSource())
        .that(source).processedWith(daggerProcessors()).compilesWithoutError();
  }

  @Test public void unusedProviderMethodsFailOnNonLibrary() {
    JavaFileObject source = JavaFileObjects.forSourceString("Library", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import java.lang.Override;",
        "@Module(library = false)",
        "class TestModule {",
        "  @Provides String string() {",
        "    return \"string\";",
        "  }",
        "}"));
    ASSERT.about(javaSource()).that(source).processedWith(daggerProcessors()).failsToCompile()
        .withErrorContaining("Graph validation failed:").in(source).onLine(5).and()
        .withErrorContaining("You have these unused @Provider methods:").in(source).onLine(5).and()
        .withErrorContaining("1. TestModule.string()").in(source).onLine(5).and()
        .withErrorContaining("Set library=true in your module").in(source).onLine(5);
  }

  @Test public void injectsOfInterfaceMakesProvidesBindingNotAnOrphan() {
    JavaFileObject foo = JavaFileObjects.forSourceString("Foo", "interface Foo {}");
    JavaFileObject module = JavaFileObjects.forSourceString("TestModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import javax.inject.Singleton;",
        "@Module(injects = Foo.class, library = false)",
        "class TestModule {",
        "  @Singleton @Provides Foo provideFoo() {",
        "    return new Foo() {};",
        "  }",
        "}"));
    ASSERT.about(javaSources()).that(Arrays.asList(foo, module))
        .processedWith(daggerProcessors())
        .compilesWithoutError();
  }

  @Test public void injectsOfClassMakesProvidesBindingNotAnOrphan() {
    JavaFileObject foo = JavaFileObjects.forSourceString("Foo", "class Foo {}");
    JavaFileObject module = JavaFileObjects.forSourceString("TestModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import javax.inject.Singleton;",
        "@Module(injects = Foo.class, library = false)",
        "class TestModule {",
        "  @Singleton @Provides Foo provideFoo() {",
        "    return new Foo() {};",
        "  }",
        "}"));
    ASSERT.about(javaSources()).that(Arrays.asList(foo, module))
        .processedWith(daggerProcessors())
        .compilesWithoutError();
  }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java;<<<<<<< MINE
=======
/**
 * Copyright (c) 2013 Google, Inc.
 * Copyright (c) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.tests.integration.validation;

import com.google.common.base.Joiner;
import com.google.testing.compile.JavaFileObjects;
import javax.tools.JavaFileObject;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
import static java.util.Arrays.asList;
import static org.truth0.Truth.ASSERT;

/**
 * Integration tests for the validation processors related to the use
 * of Scoping Annotations.
 */
// TODO(cgruber): Audit this class when http://github.com/google/compile-testing
//                has error/warning counts and other warning predicates available.
@RunWith(JUnit4.class)
public class ScopeAnnotationUseTest {
  private static final String ABSTRACTION_SCOPING_TEXT =
      "Scoping annotations are only allowed on concrete types and @Provides methods:";

  // TODO(cgruber): uncomment when http://github.com/google/compile-testing supports warnings.
  //private static final String MISUSED_SCOPE_TEXT =
  //    "Dagger will ignore scoping annotations on methods that are not @Provides methods:";

  @Test public void compileSucceedsScopeOnConcreteType() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
        "import javax.inject.Inject;",
        "import javax.inject.Singleton;",
        "@Singleton",
        "class Test {",
        "  @Inject public Test() { }",
        "}"));

    // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
    ASSERT.about(javaSource())
        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
        //.and().hasNoWarnings();
  }

  @Test public void compileSucceedsScopeOnProvidesMethod() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import javax.inject.Singleton;",
        "@Module(library = true, injects = String.class)",
        "class Test {",
        "  @Provides @Singleton public String provideString() { return \"\"; }",
        "}"));

    // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
    ASSERT.about(javaSource())
        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
        //.and().hasNoWarnings();
  }

  @Test public void compileSucceedsWithScopedSuppressedNonProvidesMethod() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
        "import javax.inject.Singleton;",
        "class Test {",
        "  @SuppressWarnings(\"scoping\")",
        "  @Singleton void method() { }",
        "}"));

    // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
    ASSERT.about(javaSource())
        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
        //.and().hasNoWarnings();
  }

  @Test public void compileSucceedsWithScopedMultiplySuppressedNonProvidesMethod() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
        "import javax.inject.Singleton;",
        "class Test {",
        "  @SuppressWarnings({\"blah\", \"scoping\", \"foo\"})",
        "  @Singleton void method() { }",
        "}"));

    // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
    ASSERT.about(javaSource())
        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
        //.and().hasNoWarnings();
  }

  @Test public void compileWarnsWithScopedNonProvidesMethod() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
        "import javax.inject.Singleton;",
        "class Test {",
        "  @Singleton void method() { }",
        "}"));

    // TODO(cgruber): uncomment when http://github.com/google/compile-testing supports warnings.
    ASSERT.about(javaSource())
        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
        //.withWarningContaining(MISUSED_SCOPE_TEXT).in(sourceFile).onLine(3).atColumn(49).and()
        //.withWarningContaining("Test.method()").in(sourceFile).onLine(3).atColumn(49);
  }

  @Test public void compileWarnsWithScopedIncorrectlySuppressedNonProvidesMethod() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
        "import javax.inject.Singleton;",
        "class Test {",
        "  @SuppressWarnings(\"some string other than 'scoping'\")",
        "  @Singleton void method() { }",
        "}"));

    // TODO(cgruber): uncomment when http://github.com/google/compile-testing supports warnings.
    ASSERT.about(javaSource())
        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
        //.withWarningContaining(MISUSED_SCOPE_TEXT).in(sourceFile).onLine(4).atColumn(49).and()
        //.withWarningContaining("Test.method()").in(sourceFile).onLine(4).atColumn(49);
  }

  @Test public void compileFailsWithScopeOnInterface() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
        "import dagger.Module;",
        "import javax.inject.Singleton;",
        "class Test {",
        "  @Module(injects = TestType.class) class TestModule { }",
        "  @Singleton interface TestType { }",
        "}"));

    ASSERT.about(javaSource())
        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(14).and()
        .withErrorContaining("Test.TestType").in(sourceFile).onLine(5).atColumn(14);
  }

  @Test public void compileFailsWithScopeOnAbstractClass() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
        "import dagger.Module;",
        "import javax.inject.Singleton;",
        "class Test {",
        "  @Module(injects = TestType.class) class TestModule { }",
        "  @Singleton abstract class TestType { }",
        "}"));

    ASSERT.about(javaSource())
        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(23).and()
        .withErrorContaining("Test.TestType").in(sourceFile).onLine(5).atColumn(23);
  }

  @Test public void compileFailsWithScopeOnField() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
        "import dagger.Module;",
        "import javax.inject.Inject;",
        "import javax.inject.Singleton;",
        "class Test {",
        "  @Singleton String field;",
        "  @Inject public Test() { }",
        "  @Module(injects = Test.class) class TestModule { }",
        "}"));

    ASSERT.about(javaSource())
        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(21).and()
        .withErrorContaining("Test.field").in(sourceFile).onLine(5).atColumn(21);
  }

  @Test public void compileFailsWithScopeOnMethodParameter() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import javax.inject.Singleton;",
        "@Module(library = true, injects = String.class)",
        "class Test {",
        "  @Provides int provideInteger() { return 0; }",
        "  @Provides String provideString(@Singleton int intParam) { return \"\"; }",
        "}"));

    ASSERT.about(javaSource())
        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(7).atColumn(49).and()
        .withErrorContaining("intParam").in(sourceFile).onLine(7).atColumn(49);
  }

  @Test public void compileFailsWithMultipleScopeAnnotations() {
    JavaFileObject annotation = JavaFileObjects.forSourceString("MyScope", Joiner.on("\n").join(
        "import java.lang.annotation.Retention;",
        "import javax.inject.Scope;",
        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
        "@Scope @Retention(RUNTIME) public @interface MyScope { }"));

    JavaFileObject module = JavaFileObjects.forSourceString("MyModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import javax.inject.Singleton;",
        "@Module(library = true, injects = Injectable.class)",
        "class MyModule {",
        "  @Provides @Singleton @MyScope String method() { return \"\"; }",
        "}"));

    JavaFileObject injectable = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
        "import javax.inject.Inject;",
        "import javax.inject.Singleton;",
        "@Singleton @MyScope",
        "class Injectable {",
        "  @Inject String string;",
        "}"));

    String error = "Only one scoping annotation is allowed per element: ";

    ASSERT.about(javaSources()).that(asList(annotation, module, injectable))
        .processedWith(daggerProcessors()).failsToCompile()
        .withErrorContaining(error + "MyModule.method()").in(module).onLine(6).atColumn(40).and()
        .withErrorContaining(error + "Injectable").in(injectable).onLine(4).atColumn(1);
  }

  @Test public void compileFailsWithScopeOnConstructor() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
        "import dagger.Module;",
        "import javax.inject.Inject;",
        "import javax.inject.Singleton;",
        "class Test {",
        "  @Singleton @Inject public Test() { }",
        "  @Module(injects = Test.class) class TestModule { }",
        "}"));

   String singletonErrorText = ""
        + "Singleton annotations have no effect on constructors. "
        + "Did you mean to annotate the class?";

    ASSERT.about(javaSource())
        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(29).and()
        .withErrorContaining("Test.Test()").in(sourceFile).onLine(5).atColumn(29).and()
        .withErrorContaining(singletonErrorText).in(sourceFile).onLine(6).atColumn(33);
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java;<<<<<<< MINE
=======
/**
 * Copyright (c) 2013 Google, Inc.
 * Copyright (c) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.tests.integration.validation;

import com.google.common.base.Joiner;
import com.google.testing.compile.JavaFileObjects;
import javax.tools.JavaFileObject;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
import static org.truth0.Truth.ASSERT;

@RunWith(JUnit4.class)
public class SimpleMissingDependencyTest {

  @Test public void missingDependency() {
    JavaFileObject file = JavaFileObjects.forSourceString("MissingDep", Joiner.on("\n").join(
        "import dagger.Module;",
        "import javax.inject.Inject;",
        "class MissingDep {",
        "  @Inject Dependency dep;",
        "  static interface Dependency {",
        "    void doit();",
        "  }",
        "  @Module(injects = MissingDep.class)",
        "  static class DaModule {",
        "    /* missing */ // @Provides Dependency a() { return new Dependency(); }",
        "  }",
        "}"));

    ASSERT.about(javaSource())
        .that(file).processedWith(daggerProcessors())
        .failsToCompile()
        .withErrorContaining("MissingDep$Dependency could not be bound").in(file).onLine(9).and()
        .withErrorContaining("required by MissingDep for MissingDep.DaModule").in(file).onLine(9);
  }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/demonstration/projects/dagger/revisions/rev_1bc7c83_8f2e49e/rev_1bc7c83-8f2e49e/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java;<<<<<<< MINE
=======
/**
 * Copyright (c) 2013 Google, Inc.
 * Copyright (c) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.tests.integration.validation;

import com.google.common.base.Joiner;
import com.google.testing.compile.JavaFileObjects;
import javax.tools.JavaFileObject;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
import static org.truth0.Truth.ASSERT;

@RunWith(JUnit4.class)
public class CyclicDependencyTest {

  @Test public void cyclicDepsWithInjectables() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("CyclicDeps", Joiner.on("\n").join(
        "import dagger.Module;",
        "import javax.inject.Inject;",
        "class CyclicDeps {",
        "  static class Foo {",
        "    @Inject Foo(Bar b) { }",
        "  }",
        "  static class Bar {",
        "    @Inject Bar(Blah b) { }",
        "  }",
        "  static class Blah {",
        "    @Inject Blah(Foo f) { }",
        "  }",
        "  static class EntryPoint {",
        "    @Inject Foo f;",
        "  }",
        "  @Module(injects = EntryPoint.class)",
        "  static class TestModule { }",
        "}"));

    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
        .withErrorContaining("0. CyclicDeps$Foo bound by").in(sourceFile).onLine(17).and()
        .withErrorContaining("1. CyclicDeps$Bar bound by").in(sourceFile).onLine(17).and()
        .withErrorContaining("2. CyclicDeps$Blah bound by").in(sourceFile).onLine(17);
  }

  @Test public void cyclicDepsWithProvidesMethods() {
    JavaFileObject sourceFile = JavaFileObjects.forSourceString("CyclicDeps", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "class CyclicDeps {",
        "  static class A { }",
        "  static class B { }",
        "  static class C { }",
        "  static class D { }",
        "  @Module(injects = D.class)",
        "  static class CyclicModule {",
        "    @Provides A a(D d) { return null; }",
        "    @Provides B b(A a) { return null; }",
        "    @Provides C c(B b) { return null; }",
        "    @Provides D d(C c) { return null; }",
        "  }",
        "}"));

    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
        .withErrorContaining("0. CyclicDeps$A bound by Provides").in(sourceFile).onLine(9).and()
        .withErrorContaining("1. CyclicDeps$D bound by Provides").in(sourceFile).onLine(9).and()
        .withErrorContaining("2. CyclicDeps$C bound by Provides").in(sourceFile).onLine(9).and()
        .withErrorContaining("3. CyclicDeps$B bound by Provides").in(sourceFile).onLine(9);
  }

}>>>>>>> YOURS
